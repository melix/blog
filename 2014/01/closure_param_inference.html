<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cédric Champeau's blog: Closure parameter type inference for Groovy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">    

    <!-- Le styles -->
    <link href="/blog/css/bootstrap.min.css" rel="stylesheet">
    <link href="/blog/css/asciidoctor.css" rel="stylesheet">
    <link href="/blog/css/base.css" rel="stylesheet">
   <script src="https://kit.fontawesome.com/fefa3ec5bf.js" crossorigin="anonymous"></script>
      
    <script src="/blog/js/highlight.min.js"></script>
    <link href="/blog/css/equilibrium-gray-light.min.css" rel="stylesheet">
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../../favicon.ico">
  </head>
  <body>
    <div id="wrap">
   
	
	<!-- Fixed navbar -->
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
          <div class="container">
	    <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/blog">Cédric Champeau's blog</a>
	    </div>
            <div class="navbar-collapse collapse">
              <ul class="nav navbar-nav">                
                <li><a href="/blog/about.html">About</a></li>
		<li><a href="/blog/projects.html">Projects</a></li>
		<li><a href="/blog/astronomy.html">Astronomy</a></li>
		<li class="dropdown">
          		<a data-toggle="dropdown" href="#">Topics<b class="caret"></b></a>
		          <ul class="dropdown-menu" role="menu">
				<li><a href="/blog/tags/gradle.html">Gradle</a></li>
                <li><a href="/blog/tags/groovy.html">Groovy</a></li>
                <li><a href="/blog/tags/micronaut.html">Micronaut</a></li>
                <li><a href="/blog/tags/index.html">See all tags</a></li>
		          </ul>
	       </li>
                <li><a href="/blog/feed.xml">Feed</a></li>                
              </ul>
	      <ul class="nav navbar-nav navbar-right">
	      	<li><a href="https://github.com/melix"><i class="fa fa-github"></i></a></li>
	        <li><a href="https://twitter.com/CedricChampeau"><i class="fa fa-twitter"></i></a></li>
	        <li><a rel="me" href="https://mastodon.xyz/@melix"><i class="fa-brands fa-mastodon"></i></a></li>
	        <li><a rel="me" href="https://astrodon.social/@melix"><i class="fa-brands fa-mastodon"></i></a></li>
	      </ul>
            </div>
          </div>
      </div>
      <div class="container">
	
	<div class="page-header">
		<h1>Closure parameter type inference for Groovy</h1>
	</div>

	<p><em>07 January 2014</em></p>
	<p><em>Tags: </em>
		<a href="/blog/tags/groovy.html">groovy</a> 
	</em>
		<a href="/blog/tags/closure.html">closure</a> 
	</em>
		<a href="/blog/tags/type-checking.html">type checking</a> 
	</em>
		<a href="/blog/tags/inference.html">inference</a> 
	</p>
	<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s start 2014 with a new blog post about a long standing request since we introduced static type checking in Groovy 2: closure parameter type inference.
Before we start, let me wish you a happy new year and a lot of open source contributions!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_type_checking_closure_parameter_types">Type checking closure parameter types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To illustrate the problem, let&#8217;s start with this very simple, standard, Groovy code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">void test() {
    assert ['foo','bar','baz'].collect { it.toUpperCase() } == ['FOO','BAR','BAZ']
}
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code compiles and runs perfectly fine. Now if you want the <em>test</em> method to be type safe, you can annotate it with <em>@TypeChecked</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">import groovy.transform.TypeChecked

@TypeChecked
void test() {
    assert ['foo','bar','baz'].collect { it.toUpperCase() } == ['FOO','BAR','BAZ']
}
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you compile this, you will notice that the compiler fails with an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Static type checking] - Cannot find matching method java.lang.Object#toUpperCase(). Please check if the declared type is right and if the method exists.
 at line: 5, column: 42</pre>
</div>
</div>
<div class="paragraph">
<p>Fixing this requires an explicit closure parameter type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">import groovy.transform.TypeChecked

@TypeChecked
void test() {
    assert ['foo','bar','baz'].collect { String it -&gt; it.toUpperCase() } == ['FOO','BAR','BAZ']
}
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem comes from the <em>collect</em> method, which accepts a <code>Closure</code>. In Groovy, a <code>Closure</code> is a block of code which may capture variables, but it is also
represented as an object of the class <code>Closure</code>. This is a different concept from Java 8 lambdas, which have no <em>Lambda</em> class, for example. A Java 8 lambda can
be considered as purely syntactic sugar, which is interpreted as an interface implementation at compile time, although a <code>Closure</code> can be manipulated. To illustrate
this, let&#8217;s compare the signatures of <em>collect</em> (in Groovy) and <code>Map</code> (in Java 8) which correspond to the same concept:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">public static &lt;T,U&gt; List&lt;U&gt; collect(List&lt;T&gt; source, Closure&lt;U&gt; closure) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>items of the source list are of type T and converted to type U using the closure</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Function is an interface, the lambda expression will be converted into this target interface</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The Java 8 equivalent would therefore be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">list.stream().map((it)-&gt;it.toUpperCase()).collect(Collectors.toList()); <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>we&#8217;re not using the smarter method reference notation here, to illustrate the concept</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As you can see, Java allows the same thing as Groovy but doesn&#8217;t require an explicit type. The reason is that for Java, there&#8217;s no ambiguity:
it makes use of <em>target typing</em>. Since a lambda is targetting an interface, the type of the parameters can be inferred from the interface type.
In Groovy, we can&#8217;t do this, because <code>Closure</code> is not an interface. It is a class which can be manipulated. At this point, you may wonder why
we don&#8217;t do the same as in Java, and there are several reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>historical reason first, <code>Closure</code> was one of the key features of the language, 10 years ago!</p>
</li>
<li>
<p>a single class, <code>Closure</code>, is enough for <strong>all</strong> usages of an open block. We don&#8217;t need Function, Consumer, BiFunction, &#8230;&#8203; So we can dramatically
reduce the amount of "design interfaces"</p>
</li>
<li>
<p>last but not least, <em>Closures</em> support various delegation strategies. This is something Java (or even Scala) is totally unable to do. <code>Closure</code> can
be <em>cloned</em>, <em>curried</em>, <em>trampolined</em>, &#8230;&#8203; and it always returns an instance of another <code>Closure</code>. This closure can change the delegate, which is the
key for nice builder like DSLs. The delegate is used whenever a method call in a closure doesn&#8217;t have an explicit receiver. For example:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">mail {
   from 'austin.powers@groovy.baby'
   to 'mini.me@evil.com'
   subject 'Attention please!'
   body '...'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this DSL, the <em>from</em>, <em>to</em>, <em>subject</em> and <em>body</em> method calls are done on the <em>delegate</em>. Being able to set the <em>delegate</em> absolutely requires a
<code>Closure</code> class. The implementation of the mail method may have something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">class EmailSpecification {
    void from(String sender) { ... }
    void to(String to) { ... }
    void subject(String subject) { ... }
    void body(String body) { ... }
    void mail(Closure mail) {
       def mailSpec = mail.clone()
       mailSpec.delegate = this
       mailSpec()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem with this approach is that if the closure requires parameters, like in the <em>collect</em> case, the Java type system, as well as the Groovy type
system (which is the same), isn&#8217;t expressive enough to let you define them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">public static &lt;T,U&gt; List&lt;U&gt; collect(List&lt;T&gt; source, Closure&lt;U&gt; closure) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We could like to say that Closure returns a U, but also that it consumes a T</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Of course the first option that was studied was defining lots of <code>Closure</code> interfaces, corresponding to the various number of arguments (up to some arbitrary limit):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">public static &lt;T,U&gt; List&lt;U&gt; collect(List&lt;T&gt; source, Closure1&lt;T,U&gt; closure) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Closure1 is a kind of closure which accepts a single argument and returns a value</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>While this works, it has several drawbacks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it requires a lot of arbitrary, totally useless in a dynamic context, number of interfaces/classes to define closures</p>
</li>
<li>
<p>it doesn&#8217;t solve the case of polymorphic closures</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_polymorphic_closures">Polymorphic closures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Polywhat? In Groovy, closures can be polymorphic. To illustrate the concept, let&#8217;s take a look at a common method that iterates on map entries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">def map = [key1: 'value 1', key2: 'value2']
map.each { k,v -&gt; println "Key is $k, value is $v" } <b class="conum">(1)</b>
map.each { e -&gt; println "Key is ${e.key], value is ${e.value}" } <b class="conum">(2)</b>
map.each { println "Key is ${it.key], value is ${it.value}" } <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>version where the map entry is automatically converted into a key and value arguments</p>
</li>
<li>
<p>version where the closure takes a single, <code>Map.Entry</code> argument</p>
</li>
<li>
<p>version with an implicit argument, it, is a <code>Map.Entry</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In all cases, it is always the <strong>same</strong> method which is called, that is to say <em>each(Closure)</em> on a <code>Map</code>. The signature of this method is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">public static &lt;K,V&gt; each(Map&lt;K,V&gt; self, Closure&lt;?&gt; onEachEntry)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, the return type of the closure doesn&#8217;t help here, and just reading that signature, you have absolutely no way to guess that the closure
will accept either a <code>Map.Entry</code> or a pair of <code>K,V</code>. Nor does the compiler. At best, your IDE knows it, and it does because it is hardcoded! This is
exactly why the compiler fails, and also why so many people think it&#8217;s <a href="https://jira.codehaus.org/browse/GROOVY-5924">a bug</a>.</p>
</div>
<div class="paragraph">
<p>Not convinced? Let&#8217;s make the same signature more cryptic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">public static &lt;Dead,Pool&gt; magneto(Map&lt;Dead,Pool&gt; self, Closure&lt;?&gt; professorX)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now can you guess what <em>professorX</em> accepts as parameters? ;)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tweaking_the_type_system">Tweaking the type system</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have discussed several options and we took the time to think about it, and after the last Groovy DevCon, which took place just before the
<a href="https://skillsmatter.com/event-details/home/groovy-grails-exchange-2013">Groovy and Grails eXchange 2013</a> in London, I decided to work on an implementation.
For Groovy 2.1, we had introduced <em>@DelegatesTo</em> for closures, to be able to help the compiler in the case we described above (hinting at the delegate type)
but we were still missing parameter type inference. My guess was that it was possible to do something similar to what <em>@DelegatesTo</em> does, but for parameter
types.</p>
</div>
<div class="sect2">
<h3 id="_annotating_closures">Annotating closures</h3>
<div class="paragraph">
<p>The idea is to annotate closures so that the compiler can fetch the information and infer the argument types from the context. In the case of a simple method
accepting a closure, a simple annotation could do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">void doSomething(String src, @ClosureParams(String.class) Closure cl) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>@ClosureParams</em> annotation is here to instruct the compiler that the closure will accept either an <em>implicit</em> or <em>explicit</em> parameter of type <em>String</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">doSomething {
   it.toUpperCase()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the compiler determines that the method which will be called is <em>doSomething</em> (remember that this is only possible if type checking is activated), then an
additional lookup on the <em>doSomething</em> signature can be done, and we can retrieve the list of expected parameter types from the closure annotation. Success!</p>
</div>
<div class="paragraph">
<p>Well, not really:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we still don&#8217;t support polymorphic closures</p>
</li>
<li>
<p>generics, GENERICS, aaahhhh, GENERICS!</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_introducing_generics">Introducing&#8230;&#8203; generics!</h3>
<div class="paragraph">
<p>To make things a bit more complicated, we have generics. Don&#8217;t get me wrong. From a user perspective, generics are very good because they make the code more readable
and help reduce the amount of boilerplate (think of vectors/maps before Java 1.5&#8230;&#8203;). The typical case is the <em>collect</em> example that we used initially:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">public static &lt;T,U&gt; List&lt;U&gt; collect(List&lt;T&gt; source, Closure&lt;U&gt; closure) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, we want to say that the closure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>is monomorphic</p>
</li>
<li>
<p>accepts a single parameter of type T</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and the problem is&#8230;&#8203; how to express this? One might think that you could write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">public static &lt;T,U&gt; List&lt;U&gt; collect(List&lt;T&gt; source, @ClosureParams(T) Closure&lt;U&gt; closure) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>but the truth is that the JVM doesn&#8217;t support placeholders as annotation values, nor does it support parametrized types (like <code>@Foo(List&lt;T&gt;</code>)). This tells us that the simple strategy doesn&#8217;t work.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_solution">The solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The solution we propose is to decouple the declaration of the parameter types from the type itself. In other words, instead of declaring the types in the annotation, we will declare an object
which is used as a hint to compute the types <strong>at compile time</strong>. In the case of <em>collect</em>, we end up with this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static &lt;T,E&gt; List&lt;T&gt; collect(List&lt;E&gt; self, @ClosureParams(FirstParam.FirstGenericType.class) Closure&lt;? extends T&gt; transform)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, <code>FirstParam.FirstGenericType</code> doesn&#8217;t represent the type itself. It&#8217;s a hint used by the compiler, which says "the type of the argument is the type of the first generic type of the first parameter". In this case, the first parameter is <code>List&lt;E&gt;</code>, so the first generic type is <code>E</code>. This means that if you call the method with a <code>List&lt;String&gt;</code>, now the compiler can infer that <code>E</code> is a <code>String</code>.</p>
</div>
<div class="sect2">
<h3 id="_type_hints">Type hints</h3>
<div class="paragraph">
<p>At this point, you may actually think that this "solution" is a bit complex. However, you have to remember that this kind of work is only necessary if you want to support type inference, so it is really only necessary if you use type checking. This makes this a tool primarily aimed at framework builders. In particular, lots of frameworks are written in Java (including Groovy itself), so the syntax <strong>has</strong> to be compatible with Java. Second, there&#8217;s no need to define one <code>FirstParam.FirstGenericType</code> class per method. The same class can be reused for all cases where it makes sense. Remember that it doesn&#8217;t represent the type of the parameters but a way to fetch the type (one level of indirection).</p>
</div>
<div class="paragraph">
<p>To make things easier for framework writers, the <a href="https://github.com/groovy/groovy-core/pull/307">candidate implementation</a> provides a set of predefined hint classes that should fit most of
the use cases. Let&#8217;s go through the list:</p>
</div>
<div class="sect3">
<h4 id="_firstparam">FirstParam</h4>
<div class="paragraph">
<p><code>FirstParam</code> is a hint that says that the expected parameter type corresponds to the first parameter of the method call, like in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void downto(BigInteger self, Number to, @ClosureParams(FirstParam.class) Closure closure)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The closure accepts a single parameter of type <code>BigInteger</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_firstparam_firstgenerictype">FirstParam.FirstGenericType</h4>
<div class="paragraph">
<p>This hint is used when the type to use is not the type of the parameter, but the type of the first generic type of the first argument, like in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static &lt;T,E&gt; Collection&lt;T&gt; collect(Collection&lt;E&gt; self, Collection&lt;T&gt; collector, @ClosureParams(FirstParam.FirstGenericType.class) Closure&lt;? extends T&gt; transform)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if you have a <code>Collection</code> defined like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">class PersonList extends LinkedList&lt;Person&gt; {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and that you call collect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">list.collect { it.name }</code></pre>
</div>
</div>
<div class="paragraph">
<p>the compiler will be capable of inferring that the type of the first generic type is actually a <code>Person</code>.</p>
</div>
<div class="paragraph">
<p><code>FirstParam</code> also supports <code>SecondGenericType</code> and <code>ThirdGenericType</code>. You can also find <code>SecondParam</code> and <code>ThirdParam</code> which follow the same structure.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mapentryorkeyvalue">MapEntryOrKeyValue</h4>
<div class="paragraph">
<p>This hint is used for cases where the closure may accept a <code>Map.Entry</code> or a <em>key,value</em> pair, which is quite common in the Groovy GDK, like <em>each</em> on maps:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static &lt;K, V&gt; Map&lt;K, V&gt; each(Map&lt;K, V&gt; self, @ClosureParams(MapEntryOrKeyValue.class) Closure closure)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is an example of polymorphic closure. This hint does all the job of telling that the parameter types may be a <code>K,V</code> pair or a <code>Map.Entry&lt;K,V&gt;</code>. For that, it expects the map to be the first parameter of the method.</p>
</div>
</div>
<div class="sect3">
<h4 id="_simpletype">SimpleType</h4>
<div class="paragraph">
<p>Simple type can be used for monomorphic closures, in the cases the closure accepts parameters of a non-parametrized type. In this case, you need to use an option to specify the fully qualified name, like in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void eachByte(InputStream is, @ClosureParams(value=SimpleType.class, options="byte") Closure closure)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the closure accepts a single parameter of type <code>byte</code>. For a non primitive type, you need the fully qualified name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static Writable filterLine(InputStream self, @ClosureParams(value=SimpleType.class, options="java.lang.String") Closure predicate)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the closure accepts multiple arguments then you need options to be an array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static &lt;T&gt; T withObjectStreams(Socket socket, @ClosureParams(value=SimpleType.class, options={"java.io.ObjectInputStream","java.io.ObjectOutputStream"}) Closure&lt;T&gt; closure)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fromstring">FromString</h4>
<div class="paragraph">
<p>The last predefined hint can be used whenever none of the previous hints is suitable. A good example is the <em>sort</em> method on a collection, which takes a closure which either accepts a single
parameter of type <code>T</code> (where <code>T</code> is the component type) or two parameters of type <code>T</code> in which case we have a comparator-style closure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static &lt;T&gt; List&lt;T&gt; sort(Collection&lt;T&gt; self, @ClosureParams(value=FromString.class, options={"T","T,T"} Closure c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, in this example, the <em>options</em> map defines two possible signatures. The string literal are used at compile time to match those of the method signature. Since it involves much more work for the compiler, it is not recommanded to use <code>FromString</code> if other options are available, because it would be slower at compile time.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_future_work">Future work</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The candidate implementation is available on <a href="https://github.com/groovy/groovy-core/pull/307">GitHub</a>. It works pretty well, and honestly, I couldn&#8217;t come with any better idea. One very good point of this implementation is that it is Java friendly. You can annotate classes written in pure Java and the Groovy compiler would be able to use the extra information. In the future, we could probably support a nicer syntax for Groovy, but it would require a grammar change, which is not planned until Groovy 3. For example, we could write this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">public static &lt;T&gt; List&lt;T&gt; sort(Collection&lt;T&gt; self, Closure&lt;T or T,T -&gt; ?&gt; c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which would totally avoid the "ugliness" of the annotation, while using the same backing tool.</p>
</div>
<div class="paragraph">
<p>Last thing, do not hesitate to comment on this blog about the solution we found. Of course, it took some time, and the discussions can be found here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://groovy.329449.n5.nabble.com/TypeChecked-type-inference-does-not-work-with-closure-td5709972.html#a5709981">an example of user complaint</a></p>
</li>
<li>
<p><a href="https://groovy.329449.n5.nabble.com/Closure-parameter-types-inference-td4978037.html">Initial, not satisfying, solution, two years ago</a></p>
</li>
<li>
<p><a href="https://groovy.329449.n5.nabble.com/Closure-parameter-type-inference-td5717804.html">discussion about this solution</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thanks to everybody who participated in the discussion, and, of course, thank you for your comments if any: this is still a <em>candidate</em> solution, so if you come with any better idea, I&#8217;m open!</p>
</div>
</div>
</div></p>
   


<div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'melixblog';
	var disqus_identifier = 'closure_param_inference';
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

	<hr>
	
		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
	<p class="muted credit">All posts on this blog are published with a <em>Creative Commons by-nc-sa</em> license.<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/2.0/fr/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/2.0/fr/88x31.png"/></a></p>
        <p class="muted credit">&copy; 2013 | Mixed with <a href="https://twitter.github.com/bootstrap/">Bootstrap v3.0.3</a> | Baked with <a href="https://jbake.org">JBake v2.6.6</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/blog/js/jquery-1.11.1.min.js"></script>
    <script src="/blog/js/bootstrap.min.js"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
   <script>hljs.highlightAll();</script>
    <script type="text/javascript">
    var disqus_shortname = 'melixblog';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
<script type="text/javascript">
  window.___gcfg = {lang: 'fr'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45962373-1', 'melix.github.io');
  ga('send', 'pageview');

</script>
  </body>
</html>
