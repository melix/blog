<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cédric Champeau's blog: Static builders inception</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">    

    <!-- Le styles -->
    <link href="/blog/css/bootstrap.min.css" rel="stylesheet">
    <link href="/blog/css/asciidoctor.css" rel="stylesheet">
    <link href="/blog/css/base.css" rel="stylesheet">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
    </head>
  <body>
    <div id="wrap">
	
	<!-- Fixed navbar -->
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
          <div class="container">
	    <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/blog">Cédric Champeau's blog</a>
	    </div>
            <div class="navbar-collapse collapse">
              <ul class="nav navbar-nav">                
                <li><a href="/blog/about.html">About</a></li>
		<li><a href="/blog/conferences.html">Conferences</a></li>
		<li class="dropdown">
          		<a data-toggle="dropdown" href="#">Topics<b class="caret"></b></a>
		          <ul class="dropdown-menu" role="menu">
				<li><a href="/blog/tags/groovy.html">Groovy</a></li>
				<li><a href="/blog/2013/07/30/deck2pdf_exporting_html5_slide_decks.html">deck2pdf</a></li>
				<li><a href="/blog/tags/jlangdetect.html">JLangDetect</a></li>
		          </ul>
	       </li>
                <li><a href="/blog/feed.xml">Feed</a></li>                
              </ul>
	      <ul class="nav navbar-nav navbar-right">
	      	<li><a href="https://github.com/melix"><i class="fa fa-github"></i></a></li>
	        <li><a href="https://twitter.com/CedricChampeau"><i class="fa fa-twitter"></i></a>
	      </ul>
            </div>
          </div>
      </div>
      <div class="container">
	
	<div class="page-header">
		<h1>Static builders inception</h1>
	</div>

	<p><em>13 février 2013</em></p>
	<p><em>Tags: </em>
		<a href="/blog/tags/builder.html">builder</a> 
	</em>
		<a href="/blog/tags/compilation.html"> compilation</a> 
	</em>
		<a href="/blog/tags/groovy.html"> groovy</a> 
	</em>
		<a href="/blog/tags/programming.html"> programming</a> 
	</em>
		<a href="/blog/tags/static.html"> static</a> 
	</p>
	<a href="https://twitter.com/share" class="twitter-share-button" data-url="http://melix.github.io/blog/2013/02/13/static_builders_inception.html" data-via="CedricChampeau" data-lang="fr">Tweeter</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
	<div class="g-plusone" data-size="medium" data-href="http://melix.github.io/blog/2013/02/13/static_builders_inception.html"></div>

	<p><div class="sect1">
<h2 id="_documentation_is_good_for_everybody">Documentation is good for everybody</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As part of the <a href="http://groovy.329449.n5.nabble.com/ANN-Documentation-effort-and-site-redesign-tp5712875.html">Groovy documentation effort</a>, I started writing documentation for several features of Groovy, including <a href="http://docs.codehaus.org/display/GROOVY/Advanced+compiler+configuration">compiler configuration</a>, <a href="http://docs.codehaus.org/display/GROOVY/Type+checking+extensions">type checking extensions</a>, and yesterday the <a href="http://docs.codehaus.org/display/GROOVY/The+@DelegatesTo+annotation">@DelegatesTo annotation</a>.</p>
</div>
<div class="paragraph">
<p>What is interesting when you do so, apart from the fact that this should have been done much sooner, is that it is interesting for our users, of course, but also for us. In particular, when I wrote the statically compiled builder example in the <a href="http://docs.codehaus.org/display/GROOVY/The+@DelegatesTo+annotation">@DelegatesTo documentation</a>, I found myself thinking there was a lot of repetitive code in there… And that gave me a new idea…</p>
</div>
<div class="paragraph">
<p>In the following post, I will show you how I combined several features of Groovy 2.1 to provide an implementation of a statically compiled HTML builder: static compilation, @DelegatesTo, meta-annotations, custom type checking extensions and of course AST transformations, without having to write all the boilerplate necessary to make it type safe! Nothing less…</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_statically_compiled_markup_builder">Statically compiled markup builder</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What if we could annotate a class as a markup builder, describe its schema, then, if a user wants to statically compile the builder usage, have a type-safe, statically compiled builder? That means, if you write this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code>@groovy.transform.CompileStatic
String build() {
    def builder = new HTMLBuilder()
    builder.html {
        body {
            p {
                out &lt;&lt; "Hello, this is "
                a(href:'http://groovy.codehaus.org') { out &lt;&lt; 'Groovy' }
            }
        }
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you want <strong>compile-time errors</strong> if any of the tags used in the builder is not recognized or at the wrong place. As you know, builders are normally dynamic in Groovy, but the documentation for <a href="http://docs.codehaus.org/display/GROOVY/The+@DelegatesTo+annotation">@DelegatesTo documentation</a> showed that it was possible to create a statically checked (and statically compiled) builder.</p>
</div>
<div class="paragraph">
<p>There were two problems in the approach from the documentation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>unnecessary repetitive/verbose code (inner classes)</p>
</li>
<li>
<p>no ability to perform checks on the allowed attributes of a tag at <strong>compile-time</strong></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_here_comes_the_statically_compiled_markup_builder_experiment">Here comes the statically compiled markup builder experiment!</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_night_hacker">The night hacker</h3>
<div class="paragraph">
<p>So last night, I started an experiment to see if I could make things easier and after two hours of coding, I had indeed a first working implementation, which allowed me to define a schema for my builder, but didn’t check attributes yet.</p>
</div>
<div class="paragraph">
<p>Today, I spent several hours fixing bugs for Groovy 2.1.1, including some that prevented me from going further (including one with nasty classloading issues that prevented Gradle from loading some classes from my AST transformation…). After that, I could eventually fix my prototype and I now have a fully working implementation…</p>
</div>
</div>
<div class="sect2">
<h3 id="_checking_out_the_sources">Checking out the sources</h3>
<div class="paragraph">
<p>First of all, all the code is available on <a href="https://github.com/melix/staticbuilder">GitHub</a>. It makes uses of the gradle wrapper, so all you need is to run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code>    $ ./gradlew test
</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_builder">The builder</h3>
<div class="paragraph">
<p>Creating a statically checked builder is easy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code>    import groovyx.transform.StaticMarkupBuilder

    @StaticMarkupBuilder
    class HTMLBuilder {
        static schema = {
            html {
                head { title() }
                body {
                   p()
                   a(attributes:['href', 'target'])
                }
            }
        }
    }
</code></pre>
</div>
</div>
<div class="paragraph">
<p>For examples of several builders, you can take a look at the <a href="http://bit.ly/XAOvhJ">unit test</a>.</p>
</div>
<div class="paragraph">
<p>What is important here is that using the <strong>@StaticMarkupBuilder</strong>, we are not using a builder, we are defining one:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a statically compiled builder</p>
</li>
<li>
<p>which accepts a predefined schema</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here, the schema is very simple. It says that at the top level, we can find the <em>html</em> tag. This tag can include either a <em>head</em> or a <em>body</em> tag. Below body, you can find either <em>p</em> or <em>a</em>, and if it’s an <em>a</em>, then the only allowed attributes are <em>href</em> and <em>target</em>.</p>
</div>
<div class="paragraph">
<p>It’s a very simple schema that of course doesn’t matches what you can do in HTML5, but remember that it’s a prototype aimed at showing off the amazing capabilities of Groovy 2.1.</p>
</div>
<div class="paragraph">
<p>To use it, you can do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code>    @CompileStatic
    void test() { // using a method to ensure that the builder will be statically compiled!
        def out = new ByteArrayOutputStream()
        def builder = new Builder3(out)
        builder.html {
            body {
                p 'Hello, Groovy!'
            }
        }
        println out.toString()
    }
</code></pre>
</div>
</div>
<div class="paragraph">
<p>What we’re doing here is creating a builder inside a statically compiled portion of code (so that you can make sure that the builder usage is indeed statically compiled). If you run this code, it will show:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code>    Hello, Groovy!
</code></pre>
</div>
</div>
<div class="paragraph">
<p>But what is really interesting is showing what would happen if you use a wrong tag:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code>    @CompileStatic
    void test() { // using a method to ensure that the builder will be statically compiled!
        def out = new ByteArrayOutputStream()
        def builder = new Builder3(out)
        builder.html {
            bodyp { // compile-time error!
                p 'Hello, Groovy!'
            }
        }
        println out.toString()
    }
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, Groovy will fail at compile-time!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    Groovyc: [Static type checking] - Cannot find matching method groovyx.transform.StaticMarkupBuilderTest#bodyp(groovy.lang.Closure). Please check if the declared type is right and if the method exists.
    Groovyc: [Static type checking] - Cannot find matching method groovyx.transform.StaticMarkupBuilderTest#p(java.lang.String). Please check if the declared type is right and if the method exists.</pre>
</div>
</div>
<div class="paragraph">
<p>Of course, the error message can be improved (there are ways to do this), but what is interesting is that you really fail before the test gets executed!</p>
</div>
<div class="sect3">
<h4 id="_behind_the_magic">Behind the magic</h4>
<div class="paragraph">
<p>To acheive this first example, there are two things in action:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a meta-annotation, called <em>@StaticMarkupBuilder</em> that will expand itself into <em>@CompileStatic</em> and <em>StaticMarkupBuilderGenerator</em>: this way, using a single annotation, I am saying that the builder will be statically compiled without having to use @CompileStatic explicitely. The second annotation is an AST transformation:</p>
</li>
<li>
<p>an AST transformation that transforms the schema definition into a set of inner-classes, close to what the documentation says</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The AST transformation is very powerful. Say you have this schema:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code>    static schema = {
        html {}
    }
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the AST transformation will create an inner class called <em>HTMLBuilder$HtmlTag</em>, then also create, in the <em>HTMLBuilder class</em>, a method which name is <em>html</em> and uses a closure… Of course, it will add the <em>@DelegatesTo</em> annotation transparently, so the generated method signature will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code>    void html(@DelegatesTo(HTMLBuilder$HtmlTag) Closure body) { ... }
</code></pre>
</div>
</div>
<div class="paragraph">
<p>For sub-tags, the principle is the same, but instead of generating the method in the HTMLBuilder class, it is added to the appropriate inner tag class… Of course, the AST transform does a bit more work:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>make the builder and each generated inner class extend a base class (<em>AbstractTag</em>), this class defining how a tag should be rendered.</p>
</li>
<li>
<p>generate methods for string only arguments (<em>p `text'</em>) or empty tags</p>
</li>
<li>
<p>generate a method for tags accepting attributes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The latter is very important as it will help us demonstrate how we can also check that when the builder is used, the attributes being used are checked against a list of valid tags.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_attribute_checking_problem">The attribute checking problem</h4>
<div class="paragraph">
<p>Here, we have an interesting problem: our schema allows us to say that the <em>a</em> tag only accepts <em>href</em> and <em>target</em> attributes. But can we prevent the user from using other attributes at <strong>compile-time?</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>    builder {
        ...
        a(notGood:'invalid attribute') { out &lt;&lt; 'Link text' }
    }</pre>
</div>
</div>
<div class="paragraph">
<p>Let’s see what happens if we don’t perform additional magic. When the builder is checked by the type checker, it will find a method named <em>a</em>, which accepts a map and a closure as arguments. This method exists, so it passes compilation. This is bad, because we wanted a compile-time error here. We could have, when we generated the builder class, added a check into the <em>a</em> method body that verifies that the map keys are in the authorized list, but it’s a runtime check and here we want a compile-time one…</p>
</div>
<div class="paragraph">
<p>So we have a new challenge:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>how to make the authorized attributes list known when the builder usage is compiled?</p>
</li>
<li>
<p>how to make the static compiler <strong>check</strong> that the user only picks attributes from that list</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the first part, my choice was to add an annotation in the map parameter of the generated method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code>    void a(@CheckedAttributes(['href','target']) Map attributes, @DelegatesTo(...) Closure code) { ... }
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alright, so now we have the information available at runtime, when the compiler will select this method, the method will have an annotation that we can reflect to retrieve the list of attributes… Still, the compiler won’t use that information, so we’re doomed, right?</p>
</div>
<div class="paragraph">
<p>Not really, because Groovy 2.1 includes <a href="http://docs.codehaus.org/display/GROOVY/Type+checking+extensions">type checking extensions</a>. A type checking extension will allow us to plug into the type checking system and perform additional checks that the compiler normally doesn’t do. Here, if it chooses this method, we will ask it to check the annotation and check that the actual arguments, those provided by the user, are using keys allowed by the builder!</p>
</div>
<div class="paragraph">
<p>The code of this type checking extension can be found <a href="http://bit.ly/Yryqb7">here</a>.</p>
</div>
<div class="paragraph">
<p>We’re almost done! The only problem with this solution is that one has to annotate every method that uses our builder with @CompileStatic(extension=’groovyx/transform/StaticBuilderExtension.groovy’). This is not as cool as seeing the extension being automatically applied…</p>
</div>
</div>
<div class="sect3">
<h4 id="_global_ast_transformations_to_the_rescue">Global AST transformations to the rescue</h4>
<div class="paragraph">
<p>There’s one solution to this. We will use a global AST transformation here. Unlike local AST transformations that are triggered by seeing an annotation in the code, global AST transformations are automatically loaded by the compiler and applied to every class being compiled. Thanks to this feature, we will be able to scan classes being compiled and if we find something annotated with @CompileStatic, then change it to @CompileStatic(extensions=’…’). That’s all!</p>
</div>
<div class="paragraph">
<p>The code for such an annotation can be found <a href="http://bit.ly/UfjmjQ">here</a>.</p>
</div>
<div class="paragraph">
<p>You must remember that using global AST transformations have a significant impact on compilation times, since they are applied on every class, so always make sure you don’t use unnecessary transforms.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main focus of this blog post wasn’t to describe in details how the AST transformation works, but rather show you how a smart combination of the features of Groovy 2.1 can allow you to perform tasks that would seem impossible, like type checking at compile-time the usage of a builder, statically compiling the code and eventually, performing checks on things that are normally unchecked by the compiler (arguments of a call).</p>
</div>
<div class="paragraph">
<p>In the end, this example is not complete, of course:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the definition of the schema is insufficient (what about tags that allow arbitrary tags, …)</p>
</li>
<li>
<p>allowText attribute isn’t used yet</p>
</li>
<li>
<p>the error messages can be improved (yes, it is possible to replace them with tags!)</p>
</li>
<li>
<p>the API can be improved for more fluency</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>But what is more important is that using such techniques, I am pretty sure that someone even crazier than me could write a more complete implementation that would accept, say… a real schema (think of xsd)!</p>
</div>
</div>
</div></p>

<div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'melixblog';
	var disqus_identifier = 'static_builders_inception';
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

	<hr>
	
		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
	<p class="muted credit">All posts on this blog are published with a <em>Creative Commons by-nc-sa</em> license.<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/fr/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/2.0/fr/88x31.png"/></a></p>
        <p class="muted credit">&copy; 2013 | Mixed with <a href="http://twitter.github.com/bootstrap/">Bootstrap v3.0.3</a> | Baked with <a href="http://jbake.org">JBake v2.3.0-SNAPSHOT</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/blog/js/jquery-1.9.1.min.js"></script>
    <script src="/blog/js/bootstrap.min.js"></script>
    <script src="/blog/js/run_prettify.js"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    <script type="text/javascript">
    var disqus_shortname = 'melixblog';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
<script type="text/javascript">
  window.___gcfg = {lang: 'fr'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45962373-1', 'melix.github.io');
  ga('send', 'pageview');

</script>
<script src="http://cdn.lanyrd.net/badges/person-v1.min.js"></script>
  </body>
</html>
