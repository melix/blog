<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cédric Champeau's blog: Composition over inheritance: Gradle vs Maven</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">    

    <!-- Le styles -->
    <link href="/blog/css/bootstrap.min.css" rel="stylesheet">
    <link href="/blog/css/asciidoctor.css" rel="stylesheet">
    <link href="/blog/css/base.css" rel="stylesheet">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
    </head>
  <body>
    <div id="wrap">
	
	<!-- Fixed navbar -->
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
          <div class="container">
	    <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/blog">Cédric Champeau's blog</a>
	    </div>
            <div class="navbar-collapse collapse">
              <ul class="nav navbar-nav">                
                <li><a href="/blog/about.html">About</a></li>
		<li><a href="/blog/projects.html">Projects</a></li>
		<li><a href="/blog/astronomy.html">Astronomy</a></li>
		<li class="dropdown">
          		<a data-toggle="dropdown" href="#">Topics<b class="caret"></b></a>
		          <ul class="dropdown-menu" role="menu">
				<li><a href="/blog/tags/groovy.html">Groovy</a></li>
                <li><a href="/blog/tags/groovy.html">Gradle</a></li>
				<li><a href="/blog/2013/07/30/deck2pdf_exporting_html5_slide_decks.html">deck2pdf</a></li>
				<li><a href="/blog/tags/jlangdetect.html">JLangDetect</a></li>
		          </ul>
	       </li>
                <li><a href="/blog/feed.xml">Feed</a></li>                
              </ul>
	      <ul class="nav navbar-nav navbar-right">
	      	<li><a href="https://github.com/melix"><i class="fa fa-github"></i></a></li>
	        <li><a href="https://twitter.com/CedricChampeau"><i class="fa fa-twitter"></i></a>
	      </ul>
            </div>
          </div>
      </div>
      <div class="container">
	
	<div class="page-header">
		<h1>Composition over inheritance: Gradle vs Maven</h1>
	</div>

	<p><em>01 December 2021</em></p>
	<p><em>Tags: </em>
		<a href="/blog/tags/gradle.html">gradle</a> 
	</em>
		<a href="/blog/tags/maven.html"> maven</a> 
	</em>
		<a href="/blog/tags/composition.html"> composition</a> 
	</em>
		<a href="/blog/tags/inheritance.html"> inheritance</a> 
	</p>
	<p><div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In general, when I read comments about Maven vs Gradle, people focus on the cosmetics (XML vs Groovy/Kotlin) when it&#8217;s from my point of view the least interesting aspect of the comparison.
In this quickie, I want to focus on one particular aspect which differentiates the 2 build tools: the famous <strong>composition over inheritance</strong> paradigm.
In different aspects (POM files, lifecycle), Apache Maven is using <em>inheritance</em>, while Gradle is using <em>composition</em>.
It is a particularly important difference which completely changes the way we think about building software.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_inheritance_in_maven_builds">Inheritance in Maven builds</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A typical Maven project is built with a <em>pom.xml</em> file, which declares everything the module needs to build:
- the dependencies
- the build plugins and their configuration</p>
</div>
<div class="paragraph">
<p>Very quickly, it turns out that there are <em>common things</em> that you want to share between modules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>they would use the same compiler options</p>
</li>
<li>
<p>they would use the same plugins and configuration</p>
</li>
<li>
<p>they would apply a number of common dependencies</p>
</li>
<li>
<p>etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s imagine that we have a project which consists of 3 modules:
- a <code>library</code> module, pure Java
- an <code>application</code> module which uses the <code>library</code> and the <a href="https://micronaut.io">Micronaut Framework</a>
- and a <code>documentation</code> module which provides a user manual for the application using <a href="https://asciidoctor.org">Asciidoctor</a>.</p>
</div>
<div class="paragraph">
<p>The idiomatic way to solve the problem of sharing the configuration of the <code>library</code> and <code>application</code> modules (which are both Java) in Maven is to define a so-called "parent POM" which declares all of these common things, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint xml language-xml"><code>&lt;project xmlns="https://maven.apache.org/POM/4.0.0" xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;example-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;

    &lt;name&gt;Common Config&lt;/name&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;junit.jupiter.version&gt;5.8.1&lt;/junit.jupiter.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
            &lt;version&gt;${junit.jupiter.version}&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.0.0-M5&lt;/version&gt;
            &lt;/plugin&gt;

            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.8.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;${java.version}&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To simplify things, we could call this a "convention": by convention, all modules which will use this parent POM will apply all those plugins and dependencies.</p>
</div>
<div class="paragraph">
<p>Then a "child POM" only has to declare the parent to "inherit" from the parent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint xml language-xml"><code>&lt;project xmlns="https://maven.apache.org/POM/4.0.0" xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.example&lt;/groupId&gt;
        &lt;artifactId&gt;example-parent&lt;/artifactId&gt;
        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;application&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.example&lt;/groupId&gt;
            &lt;artifactId&gt;library&lt;/artifactId&gt;
            &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This model works really well when all modules have a lot in common, for example if they are all libraries.
The inheritance model also makes it simple to override things.
In the example above, we don&#8217;t have to specify the <code>groupId</code> and <code>version</code> of our module because it will be inherited from the parent.</p>
</div>
<div class="paragraph">
<p>However, this model comes with a number of drawbacks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>as soon as you have different modules which share different set of dependencies, or use different sets of plugins, you have to create different parents and have an inheritance model between parents. Unfortunately this is the case here, since only our <code>library</code> and <code>application</code> modules have something in common.</p>
</li>
<li>
<p>you can only have a <em>single</em> parent, meaning that you cannot inherit from a framework parent POM <em>and</em> from your own conventions.</p>
</li>
<li>
<p>it&#8217;s not great for performance, because you end up configuring a lot of things which will never be necessary for your particular "child" module.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is typically the case when you are using a framework like <a href="https://micronaut.io">Micronaut</a> or <a href="https://spring.io/projects/spring-boot">Spring Boot</a>.
Because those frameworks are built with developer productivity in mind, they come with their own "parent POMs" which makes the lives of developers easier by avoiding a lot of copy and paste of hundreds of lines of XML.
They also need to provide this parent POM because they would come with their own Maven plugin which works around the limitations of the lifecycle model.</p>
</div>
<div class="paragraph">
<p>But then, we have a problem: on one side, you have this "parent POM" which is provided by the framework, and on the other side, you have your own "parent POM" which is providing, say, company-specific conventions (like checkstyle configuration, coordinates of Maven repositories for publication, &#8230;).</p>
</div>
<div class="paragraph">
<p>In order to be able to use both conventions, you have to create a new parent POM, and you have no choice but making your company convention parent POM inherit from the framework POM: obviously you can&#8217;t change the framework POM!
This is problematic, because it means that for every release of the framework, you have to update your company convention parent POM.
This is also problematic for another aspect: not all the modules of your multi-project build are "Spring Boot" or "Micronaut" applications.
Some of them may be simple Java libraries which are used by your app, but do <em>not</em> require the framework. As a consequence, you have to create <em>multiple</em> parents, and duplicate the configuration in each of those POM files.</p>
</div>
<div class="paragraph">
<p>This inheritance problem surfaces in different places in Maven. Another one is, as I mentioned, the "lifecycle" which works in phases.
Basically, in Maven everything is executed in linear phases: if you want to do <em>test</em>, then you <em>have to</em> execute everything which is <em>before</em> that phase.
This may sound reasonable, but this model completely breaks: this is no surprise that <em>every single plugin</em> has to implement their own <code>-DskipTest</code> variant, in order to avoid doing work which shouldn&#8217;t be done.
I had <a href="https://lists.apache.org/list?<a href="mailto:users@maven.apache.org">users@maven.apache.org</a>:2021-9">an interesting use case when implementing the GraalVM native Maven plugin</a>, which requires to configure the surefire plugin to pass extra arguments.
Long story short: this isn&#8217;t possible with Maven.
Consequence: the only workaround is the multiplication of Maven profiles, which a user has to understand, maintain, and remember.</p>
</div>
<div class="sect2">
<h3 id="_composition_in_gradle_builds">Composition in Gradle builds</h3>
<div class="paragraph">
<p>Gradle builds use a very different model: <strong>composit</strong>.
In a nutshell, in a Gradle project you don&#8217;t explain <em>how to build</em>, but <em>what you build</em>: that is, you would say "this is a library", or "this is a CLI application" or "this is a documentation module".
Because a library exposes an API and an application doesn&#8217;t, those are <em>different things</em>, so their conventions, and capabilities, are different.</p>
</div>
<div class="paragraph">
<p>The way you "say" this is in a Gradle build is by <em>applying plugins</em>.</p>
</div>
<div class="paragraph">
<p>A typical Java library would apply the <code>java-library</code> plugin, while an application would apply the <code>application</code> plugin and a documentation project would apply, say, the <code>asciidoctor</code> plugin.
What do a Java library project and a documentation project have in common? Barely nothing. A Java Library has Java sources, a number of dependencies, code quality plugins applied, etc. The documentation module, on its side, is a set of markdown or asciidoc files, and resources.
The layout of the projects is different, the <em>conventions</em> are different, and the set of plugins are different.
Java projects may share the same conventions for source layout, but they are obviously different for the docs.
Also, there&#8217;s <em>no reason</em> to let the user declare "implementation" dependencies on the documentation project: it doesn&#8217;t make sense so it should be an error to do so.</p>
</div>
<div class="paragraph">
<p>On the other hand all those modules may share a number of things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>they are all published to a Maven repository</p>
</li>
<li>
<p>they need to use the same Java toolchain</p>
</li>
<li>
<p>they need to comply to security policies of your company</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The way Gradle solves this problem is by <em>composing plugins</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a plugin can "apply" another plugin</p>
</li>
<li>
<p>each plugin is guaranteed to be applied only once, even if several plugins use it</p>
</li>
<li>
<p>a plugin can "react" to the application of other plugins, allowing fine-grained customizations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So in the example above, the <code>application</code> use case can be easily solved:
first, you&#8217;d have your own "convention plugin" which defines your company conventions (e.g apply the <code>checkstyle</code> plugin with a number of rules).
Then, you&#8217;d have the Micronaut application plugin.
Finally, your application module would simply <em>apply both plugins</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>plugins {
   id 'com.mycompany.conventions' version '1.0.0'
   id 'io.micronaut.application' version '3.0.0'
}

micronaut {
    version '3.2.0'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What becomes <em>more interesting</em> is that you can (and you actually <em>should</em>)  create your own "component types" which apply a number of plugins.
In the example above, we could replace the application of the 2 plugins with a single one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>plugins {
   id 'com.mycompany.micronaut-application' version '3.0.0'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>note that we moved the configuration of the <code>micronaut</code> version to our convention plugin.
I&#8217;m not going to explain how to write a custom Gradle plugin in this blog post, but the <em>code</em> of this plugin would very much look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>plugins {
    id 'com.mycompany.conventions' version '1.0.0'
    id 'io.micronaut.application' version '3.0.0'
}

micronaut {
    version '3.2.0'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Does it look familiar? Yes it does, this is <em>exactly</em> what we had in the beginning.
I encourage you to take a look at <a href="https://docs.gradle.org/current/userguide/structuring_software_products.html">this documentation</a> for further details about writing your own convention plugins.</p>
</div>
<div class="paragraph">
<p>Interestingly, as I said, in Gradle plugins are allowed to <em>react</em> to the presence of other plugins.
This makes it particularly interesting for defining dynamically more tasks depending on the context.
For example, a plugin can do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>pluginManager.withPlugin('io.micronaut.application') {
    // configure the Micronaut application plugin
}
pluginManager.withPlugin('io.micronaut.library') {
    // configure the Micronaut library plugin
}
pluginManager.withPlugin('io.spring.boot') {
    // configure the Spring Boot plugin
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which is very resilient to the fact that the plugins may be applied in any order and that they can combine with each other to provide higher level constructs.
It also makes it possible to <em>give choice</em> to users regarding their preferences: you provide a single convention plugin which is aware of what to do if the user prefers to use Spring Boot over Micronaut.</p>
</div>
<div class="paragraph">
<p>In the end, <code>com.mycompany.micronaut-application</code> is defined as a combination of the <code>io.micronaut.application</code>, <code>your.company.conventions</code> plugins.
Instead of declaring <em>how to build</em> your company application, you simply described <em>what it is</em>.</p>
</div>
<div class="paragraph">
<p>This is only touching the surface of the Gradle world here, but when I read that Gradle is "just Ant on steroids", nothing could be more wrong.
Gradle in this case is much superior, because it focuses on <em>convention over configuration</em>, while providing better constructs than Maven to do it.</p>
</div>
<div class="paragraph">
<p>But let&#8217;s come back to our multi-project example: each of the modules would apply a different plugin (which is also why it&#8217;s important to drop the <em>allprojects</em> pattern, which is not enforcing good design):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>library</code> would apply the <code>com.mycompany.library</code> plugin</p>
</li>
<li>
<p><code>application</code> would apply the <code>com.mycompany.application</code> plugin</p>
</li>
<li>
<p><code>docs</code> would apply the <code>com.mycompany.docs</code> plugin</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>com.mycompany.library</code> plugin would, for example, apply the <code>java-library</code> and <code>com.mycompany.java-conventions</code> plugin.
The <code>com.mycompany.application</code> plugin would, for example, apply the <code>io.micronaut.application</code> and <code>com.mycompany.java-conventions</code> plugin (knowing that the <code>io.micronaut.application</code> plugin applied the <code>application</code> plugin and more, such as the GraalVM plugin)
The <code>com.mycompany.docs</code> plugin would, for example, apply the <code>org.asciidoctor.jvm.convert</code> plugin and the <code>com.mycompany.docs</code> plugin.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll notice how those actually combine together, making it easier to maintain and upgrade builds: should you change the company conventions, all you have to do is release a new version of the convention plugin.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this quickie, I have explained a major difference in how Maven and Gradle envision build configuration.
While both of them are designed with <em>convention over configuration</em> in mind, the inheritance model of Maven makes it difficult to build conventions on top of each other without duplication.
On the other hand, Gradle uses a <em>composition</em> model which makes it possible to design your own conventions while being aware of other plugins being applied by the user: Gradle builds are more lenient and more maintainable.</p>
</div>
<div class="paragraph">
<p>As a complement, you might be interested in:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>reading the <a href="https://docs.gradle.org/current/userguide/structuring_software_products.html">structuring large projects</a> documentation from the Gradle docs</p>
</li>
<li>
<p>watching my <a href="https://www.youtube.com/watch?v=MaansFoPHKg&amp;feature=youtu.be">10 mins video</a> about authoring Gradle builds</p>
</li>
<li>
<p>following my former team mate Jendrik who created <a href="https://www.youtube.com/playlist?list=PLWQK2ZdV4Yl2k2OmC_gsjDpdIBTN0qqkE">a series of videos about modern Gradle</a></p>
</li>
</ul>
</div>
</div>
</div></p>
   


<div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'melixblog';
	var disqus_identifier = 'gradle-maven-compo-inheritance-draft';
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

	<hr>
	
		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
	<p class="muted credit">All posts on this blog are published with a <em>Creative Commons by-nc-sa</em> license.<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/fr/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/2.0/fr/88x31.png"/></a></p>
        <p class="muted credit">&copy; 2013 | Mixed with <a href="http://twitter.github.com/bootstrap/">Bootstrap v3.0.3</a> | Baked with <a href="http://jbake.org">JBake v2.3.0</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/blog/js/jquery-1.9.1.min.js"></script>
    <script src="/blog/js/bootstrap.min.js"></script>
    <script src="/blog/js/run_prettify.js"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    <script type="text/javascript">
    var disqus_shortname = 'melixblog';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
<script type="text/javascript">
  window.___gcfg = {lang: 'fr'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45962373-1', 'melix.github.io');
  ga('send', 'pageview');

</script>
  </body>
</html>
