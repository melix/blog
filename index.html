<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cédric Champeau's blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">    

    <!-- Le styles -->
    <link href="/blog/css/bootstrap.min.css" rel="stylesheet">
    <link href="/blog/css/asciidoctor.css" rel="stylesheet">
    <link href="/blog/css/base.css" rel="stylesheet">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <script src="/blog/js/highlight.min.js"></script>
    <link href="/blog/css/equilibrium-gray-light.min.css" rel="stylesheet">
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
  </head>
  <body>
    <div id="wrap">
   
	
	<!-- Fixed navbar -->
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
          <div class="container">
	    <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/blog">Cédric Champeau's blog</a>
	    </div>
            <div class="navbar-collapse collapse">
              <ul class="nav navbar-nav">                
                <li><a href="/blog/about.html">About</a></li>
		<li><a href="/blog/projects.html">Projects</a></li>
		<li><a href="/blog/astronomy.html">Astronomy</a></li>
		<li class="dropdown">
          		<a data-toggle="dropdown" href="#">Topics<b class="caret"></b></a>
		          <ul class="dropdown-menu" role="menu">
				<li><a href="/blog/tags/gradle.html">Gradle</a></li>
                <li><a href="/blog/tags/groovy.html">Groovy</a></li>
                <li><a href="/blog/tags/micronaut.html">Micronaut</a></li>
                <li><a href="/blog/tags/index.html">See all tags</a></li>
		          </ul>
	       </li>
                <li><a href="/blog/feed.xml">Feed</a></li>                
              </ul>
	      <ul class="nav navbar-nav navbar-right">
	      	<li><a href="https://github.com/melix"><i class="fa fa-github"></i></a></li>
	        <li><a href="https://twitter.com/CedricChampeau"><i class="fa fa-twitter"></i></a>
	      </ul>
            </div>
          </div>
      </div>
      <div class="container">

	<div class="page-header">
		<h1>Blog</h1>
	</div>
  			<a href="/blog/2022/07/there-is-no-single-dependency-graph.html"><h1>There is no single dependency graph</h1></a>
  			<p>04 July 2022</p>
			<p><em>Tags: </em>
		<a href="/blog/tags/gradle.html">gradle</a> 
	
		<a href="/blog/tags/dependency-management.html">dependency-management</a> 
	</p>
			
  			<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>What are the dependencies of Micronaut?
While the question may seem obvious, the answer is not.
I realized, over the years, that many developers tend to ignore the complexity of dependency management in the Java ecosystem.
In particular, I faced several occasions when discussing dependency upgrades (in particular in the context of security updates) when it became obvious that there was a big gap between the mental model that some people have, and the reality.
In this blog post I want to address some misconceptions around dependencies in the Java ecosystem.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_libraries_vs_applications">Libraries vs applications</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_applications_are_easier">Applications are easier</h3>
<div class="paragraph">
<p>First and foremost, we have to make a difference between a <em>library</em> and an <em>application</em>.
If I install, say, a desktop application, then the notion of "dependencies of the application" seem quite obvious: they are often bundled with the application in a <code>libs</code> directory, so all we have to do is look into that.
Therefore, the question "what are the dependencies of X" can be conflated to a simpler question: "what are the dependencies that application X requires at runtime to run properly".</p>
</div>
<div class="paragraph">
<p>This is already a simplfication, though: nothing prevents the application from using a plugin system.
This would make the answer to that question more complicated, but let&#8217;s focus on the simplest case.
Because we have that file list at hand, answering questions like "is X vulnerable to log4shell" is easy: we can look into the <code>libs</code> directory, and if we find a vulnerable version of log4j in there, then we know for sure if the application uses a vulnerable dependency.</p>
</div>
<div class="paragraph">
<p>This model, the "Windows installer" one, is what lots of developers have in mind.
The problem is often that they assume that the <em>libraries</em> work the same, but they don&#8217;t.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_library_dependencies">Library dependencies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For libraries (and frameworks, which can be seen as "super libraries") the answer is indeed more complex.
A library is intended to be consumed by an application, or another library.
Therefore, when we ask the question "what are the dependencies of library L", then the answer is "it depends".</p>
</div>
<div class="paragraph">
<p>In particular, libraries will introduce us to the world of <em>transitive dependencies</em>: an application will depend on libraries, which themselves have dependencies on other libraries.</p>
</div>
<div class="paragraph">
<p>For example, you can have the following dependency graph:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/blog/img/simple-dependency-graph.svg" alt="simple dependency graph" width="178" height="345">
</div>
</div>
<div class="paragraph">
<p>We can already see that we have a pelicular situation, where 2 libraries depend on the same module <code>c</code>.
If they require the same version of <code>c</code>, then we are lucky.
If they don&#8217;t, then we run in a situation called a <em>version conflict</em>, where different tools will use different strategies to solve them (no, Maven and Gradle, in particular, don&#8217;t have the same way of dealing with dependency conflicts).</p>
</div>
<div class="paragraph">
<p>Say that <code>a</code> requires <code>c 1.0</code> and that <code>d</code> requires <code>c 1.1</code>: a reasonable strategy is to do <em>optimistic upgrades</em> and to choose <code>c 1.1</code> because it&#8217;s the highest version.
This is the default strategy that Gradle uses, for example.
Maven, on the other hand, takes a simpler, but non prectictable strategy of "closest first", where "closest" actually means "first seen wins".
In other words, if <code>a</code> is seen first, then <code>c 1.0</code> will be used.
Reverse the order of dependencies and <code>c</code> will use version <code>1.1</code>.
Gradle&#8217;s strategy is immune to those problems, but we can already see that there can be a difference between the dependencies which are <em>declared in a build file</em> and the ones which will <em>effectively be used</em>.</p>
</div>
<div class="paragraph">
<p>As a consequence, <strong>it&#8217;s a mistake to look at the declared dependencies to determine what are the effective dependencies of a project</strong>.
You must always look at the resolved dependency graphs.
This is why I wrote, a few months ago, that <a href="http://localhost:8820/blog/2020/10/about-dependabot.html">Dependabot gave a false sense of security</a> (hopefully, now, they provide <a href="https://github.blog/2022-07-01-extend-your-dependency-information-in-the-github-dependency-graph-with-new-github-actions/">an API which can be used to mitigate that problem</a>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building_from_sources">Building from sources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we understand that the declared dependencies can be different from the <em>resolved</em> dependencies, and that we reckon that it&#8217;s the build tool&#8217;s responsibility to solve those conflicts, let&#8217;s address an elephant in the room: building a proejct <em>entirely</em> from sources (including transitive dependencies).</p>
</div>
<div class="paragraph">
<p>Let&#8217;s imagine that, for legal reasons, you don&#8217;t want to use Maven Central.
Instead you want to build your project against the <em>sources</em> of your dependencies and build themselves from dependencies, and so on.
Obviously, if your build tool doesn&#8217;t support resolving a dependency graph first (which implies having metadata available for transitive dependencies in some form) <em>then</em> replacing the dependencies with their sources instead of the binaries, then you have a problem: you&#8217;re going to have to figure out yourself what libraries to build, in which versions, and do everything by hand.
Spoiler alert: no build tool supports that (in the Java ecosystem, some ecosystems like Rust <em>always</em> use source dependencies, which come with a number of other issues I won&#8217;t address in this blog post).</p>
</div>
<div class="paragraph">
<p>This means that in order to build your project, you must:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>resolve all dependencies, including transitive dependencies, to figure out what <em>version</em> they need</p>
</li>
<li>
<p>find a way to fetch the sources for the particular version of each dependency that is used</p>
</li>
<li>
<p>update the build scripts of that project to use <em>source dependencies</em></p>
</li>
<li>
<p>compile each project independently, and recurse to 1.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>But hey, don&#8217;t you see the problem already (except from the fact you&#8217;d have to rewrite all build files, and figure out how to build each project according to their CI specification)?
Because resolved dependency graphs only depend on the <em>top level</em> project being compiled, you have absolutely no guarantee that you&#8217;ll use the same, resolved versions everywhere.
In the dependency graph above, if you resolve the dependency graph for <code>app</code>, then you will determine that you need to build <code>c</code> in version <code>1.1</code> from sources.
Alright, but to build <code>a</code>, we will need to build <code>c</code>&#8230;&#8203; with version <code>1.0</code>!
In other words, there&#8217;s no way you can <em>consistently</em> build such a dependency graph from source without having a <em>single, globally resolved</em> dependency graph, and a <em>single build</em>.
The only alternative to that is basically to go down the tree, build some artifacts, then replace transitive dependencies with <em>file</em> dependencies and cross fingers that everything compiles up to the top.
Of course this is completely unrealistic in the real world, unless you have millions of dollars to spend on rebuilding artifacts (and yes, some organizations do that, that&#8217;s the strategy for debian, for example, which has the "nice" side effect of having applications which have bugs which are not in the initial release, because all applications need to use the <em>same</em> dependency version).</p>
</div>
<div class="paragraph">
<p>That&#8217;s why I think the preferred solution, for security, is still to use precompiled binaries (which also would make builds faster in any case), but combine that with <a href="https://docs.gradle.org/current/userguide/dependency_verification.html">dependency verification</a>: it&#8217;s a good tradeoff, which offers the right level of security, while not having to spend incredible amounts of money in rebuilding the entire world (also, it&#8217;s better for the planet).
Note that this also guarantees trust, as your "custom built" binaries will clearly use different signatures, and possibly checksums, than what the users normally expect.</p>
</div>
<div class="paragraph">
<p>While we were talking about building from sources, we <em>also</em> forgot about one extremely important bit: <em>there is no single dependency graph</em>, even in a single project.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building_requires_multiple_dependency_graphs">Building requires multiple dependency graphs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The most obvious way to illustrate that there&#8217;s no single dependency graph in a project is to thing about <em>tests</em>.
When you compile your application, there shouldn&#8217;t be any test dependency on the compile classpath.
When you compile your <em>tests</em>, then you&#8217;d get the dependencies of the application, plus the dependencies of your test framework, plus your additional test dependencies.</p>
</div>
<div class="paragraph">
<p>Therefore, you have at least 2 distinct dependency graphs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the application compile classpath (in Gradle, it&#8217;s the <code>compileClasspath</code> configuration which represents that dependency graph)</p>
</li>
<li>
<p>the application test compile classpath (in Gradle, it&#8217;s the <code>testCompileClasspath</code> configuration which represents that dependency graph)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Maven itself makes a difference, with dependency <em>scopes</em> (<code>compile</code>, <code>runtime</code>, <code>test</code>, &#8230;&#8203;).
You can already see that in practice, we have <em>many more</em> dependency graphs: compile classpath, runtime classpath, test compile classpath, test runtime classpath, annotation processing path, functional tests compile/runtime classpath, etc.
A project can literally have dozens of different dependency graphs.</p>
</div>
<div class="paragraph">
<p>More importantly, there can be conflicts in those graphs: for example, when you compile your tests, you may introduce a dependency which will accidentally trigger an <em>upgrade</em> of a dependency, so you would get a different dependency version during testing and actual run time!
Similarly, your runtime dependencies can introduce transitive dependencies which would have the consequence of having different versions of dependencies at compile time and run time.
Note that Gradle offers different ways to mitigate those real world problems, for example <a href="https://docs.gradle.org/current/userguide/resolution_strategy_tuning.html#resolution_consistency">consistent resolution</a> or <a href="https://docs.gradle.org/6.2.1/userguide/dependency_version_alignment.html">version alignment</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I hope that after reading this, it becomes quite clear that <em>there is no single dependency graph</em>.
Therefore, it&#8217;s a mistake to ask for "what are the dependencies of Micronaut", because the answer <em>depends on the consumer</em>.
Not only does it depend on the consumer, but it also depends on either the order of dependencies (Maven for example), or the strategies being used to "force" dependency versions (which are also consumer dependent), or the kind of dependency graph which is resolved (runtime dependencies, compile dependencies).
Of course, we didn&#8217;t mention more advanced features like optional dependencies, for which I like to remind that <a href="https://blog.gradle.org/optional-dependencies">they are not optional</a>, nor did we talk about more advanced, runtime based systems like OSGi which add another layer of complexity to the problem.</p>
</div>
<div class="paragraph">
<p>If you can take away one thing from this blog post, it&#8217;s to never ask "what are the dependencies of X" anymore: minimally, the question should be more targetted:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>what are the dependencies that X need to compile?</p>
</li>
<li>
<p>what are the dependencies that X uses at runtime to run its test suite?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The question "what are the dependencies that X uses at runtime" is only valid for <em>some</em> applications (for example those which are not subject to platform dependent dependencies), not for <em>libraries</em>.</p>
</div>
</div>
</div></p>
			<p><a href="/blog/2022/07/there-is-no-single-dependency-graph.html#disqus_thread">Comments</a></p>
  			<a href="/blog/2022/05/gradle-laziness.html"><h1>Gradle quickie: laziness</h1></a>
  			<p>24 May 2022</p>
			<p><em>Tags: </em>
		<a href="/blog/tags/gradle.html">gradle</a> 
	
		<a href="/blog/tags/laziness.html">laziness</a> 
	</p>
			
  			<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Yesterday, I wrote this tweet:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/blog/img/2022-05-24-tweet.png" alt="2022 05 24 tweet">
</div>
</div>
<div class="paragraph">
<p>I got a surprisingly high number of answers, so I thought it would be a good idea to expand a bit on the topic.</p>
</div>
<div class="paragraph">
<p>Gradle <a href="https://docs.gradle.org/current/userguide/lazy_configuration.html">introduced lazy APIs several years ago</a>.
Those APIs are mostly directed at plugin authors but some build authors may have to deal with them too.
Lazy APIs are designed to improve performance, by avoiding to create tasks which would never be invoked during a build.
While lots of users wouldn&#8217;t notice the difference between a build using lazy APIs and a build which doesn&#8217;t, in some ecosystems like Android or with large projects, this makes a dramatic difference.
In other words, while Gradle&#8217;s performance is often praised, it&#8217;s easy to break performance by unintentionally trigerring configuration of tasks which shouldn&#8217;t.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_task_configuration">Task configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The discussion was trigerred when I was doing a code review yesterday.
I saw the following block:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.withType(Test) {
    testLogging {
        showStandardStreams = true
        exceptionFormat = 'full'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This block configures logging for all test tasks of the project.
At first glance, this seems appropriate, but there&#8217;s this gotcha: you should use <code>.configureEach</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.withType(Test).configureEach {
    testLogging {
        showStandardStreams = true
        exceptionFormat = 'full'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t, then <em>all tasks of type Test will always be configured</em>, even if you don&#8217;t call them in a build.
In other words, lazy configuration is about only configuring tasks which are going to be invoked.</p>
</div>
<div class="paragraph">
<p>Unfortunately, there are no warnings about eager configuration, or "unnecessary" configuration in a build.
If you use <a href="https://ge.micronaut.io">Build Scans</a>, you can have insights about configuration and realize that, but casual users wouldn&#8217;t.</p>
</div>
<div class="paragraph">
<p>Similarly, this code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">test {
    testLogging {
        showStandardStreams = true
        exceptionFormat = 'full'
    }
}
----</code></pre>
</div>
</div>
<div class="paragraph">
<p>Will configure the <code>test</code> task (not <em>all</em> test tasks) eagerly: even if the <code>test</code> task isn&#8217;t executed in a build, it would be configured.
Now you see the problem: this configuration pattern has been there basically forever, so it&#8217;s hard to remove.
To do lazy configuration, you have to write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.named('test') {
    testLogging {
        showStandardStreams = true
        exceptionFormat = 'full'
    }
}
----</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, this isn&#8217;t as nice, DSL-wise.
One thing you may wonder is why Gradle&#8217;s DSL default to the lazy version?
In other words, why doesn&#8217;t it call the lazy version instead of the eager one?</p>
</div>
<div class="paragraph">
<p>It&#8217;s because of backwards compatiblity: because this pattern has been present since day one in Gradle, eager configuration is everywhere in older builds.
If you search for configuration blocks in Stack Overflow, it&#8217;s very likely that you&#8217;ll end up copy and pasting <em>eager configuration</em> samples.
But, as the name implies, <em>lazy</em> configuration has a different behavior than <em>eager</em>: in the lazy case, the configuration block is invoked <em>only when the task is needed</em>, either because it&#8217;s going to be executed, or that another task depends on its configuration to configure itself.
In the eager case, configuration is executed immediately: unfortunately there are lots of builds which accidentally depend on this order of execution, so changing from eager to lazy could result in breaking changes!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_should_you_use">What should you use?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The consequence is that there&#8217;s a mix of lazy and eager APIs in Gradle, and making the difference between what is going to trigger configuration or not isn&#8217;t obvious, even for Gradle experts.
Let&#8217;s summarize a few patterns:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you want to configure <em>one particular task</em> by name, you should write:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.named("myTask") {
   // configure the task
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.named("myTask", SomeType) {
   // configure the task
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>If you want to all tasks of a particular type, you should write:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.withType(SomeType).configureEach {
   // configure the task
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>If you want to create a new task, <em>don&#8217;t use create</em>, but <em>register</em> instead:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.register("myTask", SomeType) {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the DSL, the following code that you find in many tutorials would <em>immediately create a task</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">task hello {
   doLast {
       println "Hello!"
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So the correct way to do this is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.register("hello") {
    doLast {
         println "Hello!"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the return type of both calls is <em>different</em>: the eager version will return a <code>Task</code>, while the 2d one returns a <code>TaskProvider</code>.
This is the reason why upgrading plugins isn&#8217;t that trivial, since it&#8217;s a binary breaking change!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_task_collections_and_implicit_dependencies">Task collections and implicit dependencies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In <a href="https://melix.github.io/blog/2022/01/understanding-provider-api.html">a previous blog post</a> I explained that the provider API is the right way to handle implicit inputs.
For example, you can pass directly a <code>TaskProvider</code> as an element of a file collection: Gradle would automatically resolve dependencies and trigger the configuration of that task, include it in the task graph and use its output as an input of the task you&#8217;re invoking.</p>
</div>
<div class="paragraph">
<p>Therefore, understanding lazy APIs means that you should understand <em>when</em> things are executed.
In the example above, the call <code>tasks.withType(Test)</code> by itself does <em>not</em> configure anything.
You can see it as a lazy predicate: it returns a <em>live task collection</em>, it&#8217;s a declaration of intent: "this models all tasks of type `Test`".</p>
</div>
<div class="paragraph">
<p>Therefore, the following blocks of code are strictly equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.withType(Test) {
   // configure
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.withType(Test).each {
    // configure
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">def testTasks = tasks.withType(Test)
testTasks.each {
    // configure
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other words, the last version explains the "magic" behind the traditional Gradle DSL.
The first line is lazy, returns a task collection, and it&#8217;s the fact of calling <code>.each</code> which triggers configuration of all tasks!
Replace <code>.each</code> with <code>.configureEach</code> and you are now lazy!</p>
</div>
<div class="paragraph">
<p>Newer APIs like <code>named</code> are lazy from day one, but are not necessarily user friendly.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_gradle_puzzle">A Gradle puzzle</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In effect, <code>named</code> is lazy in terms of <em>configuration</em>, but <em>eager</em> in terms of lookup: it will <strong>fail</strong> if the task that you&#8217;re looking for doesn&#8217;t exist.
It&#8217;s a bit strange, since in Gradle everything is now supposed to be lazy, so you can&#8217;t know <em>when</em> a task is going to be available or not.
As an illustration, let&#8217;s explore the following script (don&#8217;t write this in your own builds, this is for demonstration purposes!):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.register("hello") {
   doLast {
       println "Hello,"
   }
}

tasks.named("hello") {
   doLast {
        println "World!"
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you run <code>gradle hello</code>, then the output is what you expect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>&gt; Task :hello
Hello,
World!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, <em>invert</em> the position of the 2 tasks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.named("hello") {
   doLast {
        println "World!"
   }
}

tasks.register("hello") {
   doLast {
       println "Hello,"
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and run again. Boom!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>* Where:
Build file '/tmp/ouudfd/build.gradle' line: 1

* What went wrong:
A problem occurred evaluating root project 'ohnoes'.
&gt; Task with name 'hello' not found in root project 'ohnoes'.</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is very unexpected: I think what most people would expect is, if any change, that the <code>World!</code> and <code>Hello</code> outputs would be exchanged.
But because <code>named</code> <em>eagerly</em> searches for a task registed with a particular name, it <em>fails</em> if not found.</p>
</div>
<div class="paragraph">
<p>As a consequence, plugin authors who want to react to other plugins, or react to tasks which <em>may</em> be present or not, tend to use the following API instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.matching { it.name == 'hello' }.configureEach {
    doLast {
        println "World!"
   }
}

tasks.register("hello") {
   doLast {
       println "Hello,"
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s run our <code>hello</code> task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>&gt; Task :hello
World!
Hello,</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yay! No failure anymore, and the output is in the order we expected. Problem solved, right?</p>
</div>
<div class="paragraph">
<p>Well, not so fast.
You&#8217;ve used <code>configureEach</code>, so everything should be lazy, right?
Sorry, nope: the <code>matching</code> API is an <em>old</em>, eager API!
Actually, if you look at what the predicate uses, it becomes obvious:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java">// T is a Task!
TaskCollection&lt;T&gt; matching(Spec&lt;? super T&gt; var1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because it works on <code>Task</code> instances, it needs to <em>create and configure the tasks</em> so that you can run an arbitrary predicate on them!</p>
</div>
<div class="paragraph">
<p>That&#8217;s why if you have to write things like this, you <strong>must</strong> guard calls to <code>matching</code> with a <code>withType</code> before, which will restrict the set of tasks which will be configured.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.withType(Greeter).matching { it.name == 'hello' }.configureEach {
   messages.add("World!")
}

tasks.register("hello", Greeter) {
   messages.add("Hello,")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course the example is a bit stupid, but it makes sense when you&#8217;re not the one in control of <em>when</em> a task is configured or even if you don&#8217;t know if it will ever be.</p>
</div>
<div class="paragraph">
<p>Unfortunately, <a href="https://github.com/gradle/gradle/issues/16543">Gradle doesn&#8217;t provide an API which is <em>fully lazy</em> and lenient to tasks being present or not</a>.
If you simply want to <em>configure</em> a task, that is not a big deal since you can simply use <code>configureEach</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.configureEach {
    if (it.name == 'hello') { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is fine because the configuration block will be called for each task being configured.
However, this <code>configureEach</code> block is a <em>configurer</em>, not a <em>predicate</em>, so you can&#8217;t use it as an input to another task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">tasks.named("md5") {
    inputFiles.from(tasks.named("userguide"))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above would <em>fail</em> if the <code>userguide</code> task doesn&#8217;t exist <em>before</em> the <code>md5</code> task is configured&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this blog post, I have explained why you should use the new lazy APIs instead of their eager counterparts.
I have also described that while they are more verbose, they make it possible to have faster builds by avoiding configuration of tasks which would not be executed.
However, Gradle doesn&#8217;t warn you if you eagerly configure tasks, and it&#8217;s easy to shoot yourself in the foot.
Some would blame the docs, some would blame the APIs.</p>
</div>
<div class="paragraph">
<p>As a former Gradler, I would blame none of those: the <a href="https://docs.gradle.org/current/userguide/lazy_configuration.html">docs are here</a>, and changing the APIs to be lazy everywhere is either a binary breaking change (return type of methods which <em>create</em> instead of <em>register</em>), or a behavior change (deferred configuration vs immediate configuration).
This makes it particularly complicated to upgrade builds without pissing off a number of users!</p>
</div>
</div>
</div></p>
			<p><a href="/blog/2022/05/gradle-laziness.html#disqus_thread">Comments</a></p>
  			<a href="/blog/2022/05/astro-twitch.html"><h1>Astrophotographie: rendez-vous sur Twitch !</h1></a>
  			<p>03 May 2022</p>
			<p><em>Tags: </em>
		<a href="/blog/tags/astrophotographie.html">astrophotographie</a> 
	
		<a href="/blog/tags/twitch.html">twitch</a> 
	</p>
			
  			<p><div class="sect1">
<h2 id="_nous_ne_sommes_pas_que_des_développeurs">Nous ne sommes pas que des développeurs !</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ma passion, en dehors du développement, c&#8217;est l&#8217;astronomie.
Depuis quelques années, je me suis lancé dans l&#8217;astrophotographie: je ne fais quasiment plus que ça.
Pour un développeur comme moi, c&#8217;est assez intéressant de constater que lorsque je poste sur Twitter une photo que j&#8217;ai faite, j&#8217;ai bien souvent plus de réponses et de likes que sur mes tweets professionnels (ce qui est parfois vexant, lol !).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_des_lives_sur_twitch">Des lives sur Twitch</h2>
<div class="sectionbody">
<div style="font-size: 1.5em; padding: 6px; background-color: lightblue; border: solid; margin: 2em; text-align: center">
<b>Edit</b>: C'est fait ! L'expérience fut enrichissante pour moi, retrouvez le replay sur <a href="https://www.youtube.com/watch?v=Hudtta97gDU">Youtube</a></b>.
</div>
<div class="paragraph">
<p>J&#8217;ai, au final, souvent les mêmes questions qui reviennent:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Qu&#8217;est ce que c&#8217;est ?</p>
</li>
<li>
<p>Quel matériel tu utilises ?</p>
</li>
<li>
<p>Combien de fois ça grossit ?</p>
</li>
<li>
<p>Est-ce que ce sont de vraies couleurs ?</p>
</li>
<li>
<p>Combien de temps de pose ?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>et bien d&#8217;autres !</p>
</div>
<div class="paragraph">
<p>Alors, l&#8217;an dernier, je me suis lancé ce défi de faire un talk dans une conférence de développeurs (Devoxx) sur le sujet des "miracles du logiciel" en termes d&#8217;astrophotographie.
Malheureusement, le talk n&#8217;a pas été retenu, mais j&#8217;ai conservé en tête l&#8217;idée de présenter quelque chose.</p>
</div>
<div class="paragraph">
<p>Alors, envie de savoir comment on fait des photos comme celle-ci ?</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://www.astrobin.com/full/ollbl5/0/"><img src="/blog/img/astro/2021-11-09-flaming-star-nebula.jpg" alt="2021 11 09 flaming star nebula"></a>
</div>
<div class="title">Figure 1. The flaming star nebula</div>
</div>
<div class="paragraph">
<p>Aujourd&#8217;hui, je vous annonce donc un premier live sur Twitch pour parler d&#8217;astrophotographie !
Je dis premier, parce que je pense qu&#8217;il y a de quoi en faire plusieurs avant d&#8217;avoir fait le tour du sujet.</p>
</div>
<div class="paragraph">
<p>Attention, ça sera sans prétention, pas aussi préparé qu&#8217;un talk en conférence.
Ca sera aussi mon tout premier live et donc probablement plein de problèmes techniques, mais il faut bien se lancer un jour !</p>
</div>
<div class="paragraph">
<p>J&#8217;annonce donc le <strong>jeudi 12 mai à 20h</strong> sur <a href="https://www.twitch.tv/melix_fr">ma chaîne Twitch</a>.</p>
</div>
<div class="paragraph">
<p>Le premier sujet sera autour de mon setup photographique: quel matériel j&#8217;utilise, les principes de base de l&#8217;acquisition photo.
Attention, il ne s&#8217;agira pas d&#8217;une présentation générique sur l&#8217;astrophoto, mais bien d&#8217;une présentation spécifique à mon matériel, soupoudrée de détails sur comment ça fonctionne en règle générale.</p>
</div>
<div class="paragraph">
<p>En fonction du succès et/ou de ce que j&#8217;arrive à couvrir, d&#8217;autres lives seront programmés.</p>
</div>
<div class="paragraph">
<p>A bientôt !</p>
</div>
</div>
</div></p>
			<p><a href="/blog/2022/05/astro-twitch.html#disqus_thread">Comments</a></p>
  			<a href="/blog/2022/03/gradle-conditional-dependencies.html"><h1>Conditional dependencies with Gradle</h1></a>
  			<p>21 March 2022</p>
			<p><em>Tags: </em>
		<a href="/blog/tags/gradle.html">gradle</a> 
	
		<a href="/blog/tags/dependencies.html">dependencies</a> 
	</p>
			
  			<p><div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you ever wrote a Gradle plugin for a framework (e.g <a href="https://micronaut.io">Micronaut</a>) or a plugin which needs to add dependencies if the user configures a particular flag, then it is likely that you&#8217;ve faced some ordering issues.</p>
</div>
<div class="paragraph">
<p>For example, imagine that you have this DSL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">micronaut {
    useNetty = true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, <em>at some point in time</em>, you have to figure out if the property <code>useNetty</code> is set in order to transparently add dependencies.
A naive solution is to use the good old <code>afterEvaluate</code> block.
Many plugins do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">afterEvaluate {
    dependencies {
        if (micronaut.useNetty.get()) {
            implementation("io.netty:netty-buffer:4.1.75.Final")
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is that while <em>afterEvaluate</em> seems to fix the problem, it&#8217;s just a dirty workaround which defers the problem to a later stage: depending on the plugins which are applied, which themselves could use <code>afterEvaluate</code>, your block may, or may not, see the "final" configuration state.</p>
</div>
<div class="paragraph">
<p>In a <a href="https://melix.github.io/blog/2022/01/understanding-provider-api.html">previous post</a>, I introduced Gradle&#8217;s provider API.
In this post, we&#8217;re going to show how to use it to properly fix this problem.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_providers_for_dependencies">Using providers for dependencies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s start with the easiest.
It&#8217;s a common requirement of a plugin to provide the ability to override the version of a runtime.
For example, the <code>checkstyle</code> plugin would, by default, use version of checkstyle by convention, but it would still let you override the version if you want to use a different one.</p>
</div>
<div class="paragraph">
<p>Micronaut provides a similar feature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="gradle">micronaut {
    version = "3.3.1"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Micronaut dependencies to be added on the user classpath depend on the value of the <code>version</code> in our <code>micronaut</code> extension.
Let&#8217;s see how we can implement this.
Let&#8217;s create our Gradle project (we&#8217;re assuming that you have Gradle 7.4 installed):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">$ mkdir conditional-deps &amp;&amp; cd conditional-deps
$ gradle init --dsl groovy \
   --type java-library \
   --package me.champeau.demo \
   --incubating \
   --test-framework junit-jupiter</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we&#8217;re going to create a folder for our build logic, which will contain our plugin sources:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">$ mkdir -p build-logic/src/main/groovy/my/plugin</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s update the <code>settings.gradle</code> file to <em>include</em> that build logic:</p>
</div>
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">pluginManagement {
    // include our plugin
    includeBuild "build-logic"
}
rootProject.name = 'provider-dependencies'
include('lib')</code></pre>
</div>
</div>
<div class="paragraph">
<p>For now our plugin is an empty shell, so let&#8217;s create its <code>build.gradle</code> file so that we can use a <a href="https://docs.gradle.org/7.4.1/userguide/custom_plugins.html#sec:precompiled_plugins">precompiled script plugin</a>.</p>
</div>
<div class="listingblock">
<div class="title">build-logic/build.gradle</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">plugins {
    id 'groovy-gradle-plugin'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s define our extension, which is simply about declaring an <em>interface</em>:</p>
</div>
<div class="listingblock">
<div class="title">build-logic/src/main/groovy/my/plugin/MicronautExtension.groovy</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">package my.plugin

import org.gradle.api.provider.Property

interface MicronautExtension {
    Property&lt;String&gt; getVersion()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s now time to create our plugin: precompiled script plugins are a very easy way to create a plugin, simply by declaring a file in <code>build-logic/src/main/groovy</code> which name ends with <code>.gradle</code>:</p>
</div>
<div class="listingblock">
<div class="title">build-logic/src/main/groovy/my.plugin.gradle</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">import my.plugin.MicronautExtension

def micronautExtension = extensions.create("micronaut", MicronautExtension) <b class="conum">(1)</b>
micronautExtension.version.convention("3.3.0")                              <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create our extension, named "micronaut"</p>
</li>
<li>
<p>Assign a default value to the "version" property</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By convention, our plugin id will be <code>my.plugin</code> (it&#8217;s derived from the file name).
Our plugin is responsible for creating the extension, and it assigns a <em>convention</em> value to the <code>version</code> property: this is the value which is going to be used if the user doesn&#8217;t declare anything explicitly.</p>
</div>
<div class="paragraph">
<p>Then we can <em>use</em> the plugin in our main build, that is, in the <code>lib</code> project:</p>
</div>
<div class="listingblock">
<div class="title">lib/build.gradle</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">plugins {
    // Apply the java-library plugin for API and implementation separation.
    id 'java-library'
    // And now apply our plugin
    id 'my-plugin'
}

micronaut {
   // empty for now
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we look at the <code>lib</code> compile classpath, it will not include any Micronaut dependency for now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">$ ./gradlew lib:dependencies --configuration compileClasspath

------------------------------------------------------------
Project ':lib'
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-math3:3.6.1
\--- com.google.guava:guava:30.1.1-jre
     +--- com.google.guava:failureaccess:1.0.1
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.8.0
     +--- com.google.errorprone:error_prone_annotations:2.5.1
     \--- com.google.j2objc:j2objc-annotations:1.3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our goal is to add a dependency which is <em>derived from</em> the version defined in our Micronaut extension, so let&#8217;s do this.
Edit our <code>build-logic</code> plugin:</p>
</div>
<div class="listingblock">
<div class="title">build-logic/src/main/groovy/my.plugin.gradle</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">import my.plugin.MicronautExtension

def micronautExtension = extensions.create("micronaut", MicronautExtension)
micronautExtension.version.convention("3.3.0")

dependencies {
    implementation micronautExtension.version.map {
        v -&gt; "io.micronaut:micronaut-core:$v"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s run our dependencies report again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">$ ./gradlew lib:dependencies --configuration compileClasspath

&gt; Task :lib:dependencies

------------------------------------------------------------
Project ':lib'
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-math3:3.6.1
+--- io.micronaut:micronaut-core:3.3.0
|    \--- org.slf4j:slf4j-api:1.7.29
\--- com.google.guava:guava:30.1.1-jre
     +--- com.google.guava:failureaccess:1.0.1
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.8.0
     +--- com.google.errorprone:error_prone_annotations:2.5.1
     \--- com.google.j2objc:j2objc-annotations:1.3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Victory! Now we can see our <code>micronaut-core</code> dependency.
How did we do this?</p>
</div>
<div class="paragraph">
<p>Note that instead of using <code>afterEvaluate</code>, what we did is <em>adding a dependency</em>, but instead of using the traditional dependency notation, we used a <em>provider</em>: the actual dependency string is computed <em>only when we need it</em>.
We can check that we can actually configure the version via our extension by editing our build file:</p>
</div>
<div class="listingblock">
<div class="title">lib/build.gradle</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">micronaut {
   version = "3.3.1" // override the convention
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">$ ./gradlew lib:dependencies --configuration compileClasspath

&gt; Task :lib:dependencies

------------------------------------------------------------
Project ':lib'
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-math3:3.6.1
+--- io.micronaut:micronaut-core:3.3.1
|    \--- org.slf4j:slf4j-api:1.7.29
\--- com.google.guava:guava:30.1.1-jre
     +--- com.google.guava:failureaccess:1.0.1
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.8.0
     +--- com.google.errorprone:error_prone_annotations:2.5.1
     \--- com.google.j2objc:j2objc-annotations:1.3</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_maybe_add_maybe_not">Maybe add, maybe not!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous example, we have <em>systematically added</em> a dependency, based on the version defined in the extension.
What if we want to add a dependency if a property is set to a particular value?
For this purpose, let&#8217;s say that we define a <code>runtime</code> property which will tell what runtime to use.
Let&#8217;s add this property to our extension:</p>
</div>
<div class="listingblock">
<div class="title">build-logic/src/main/groovy/my/plugin/MicronautExtension.groovy</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">package my.plugin

import org.gradle.api.provider.Property

interface MicronautExtension {
    Property&lt;String&gt; getVersion()
    Property&lt;String&gt; getRuntime()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s update our plugin to use that property, and add a dependency based on the value of the <em>runtime</em> property:</p>
</div>
<div class="listingblock">
<div class="title">build-logic/src/main/groovy/my.plugin.gradle</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">import my.plugin.MicronautExtension

def micronautExtension = extensions.create("micronaut", MicronautExtension)
micronautExtension.version.convention("3.3.0")

dependencies {
    implementation micronautExtension.version.map { v -&gt;
        "io.micronaut:micronaut-core:$v"
    }

    implementation micronautExtension.runtime.map { r -&gt;
        switch(r) {
            case 'netty':                                                   <b class="conum">(1)</b>
                return "io.netty:netty-buffer:4.1.75.Final"
            case 'tomcat':
                return "org.apache.tomcat.embed:tomcat-embed-core:10.0.18"  <b class="conum">(2)</b>
            default:
                return null                                                 <b class="conum">(3)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add a dependency if the runtime is set to netty</p>
</li>
<li>
<p>Add a dependency if the runtime is set to tomcat</p>
</li>
<li>
<p>But do nothing if the runtime isn&#8217;t set</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The trick, therefore, is to <em>return null</em> in the provider in case no dependency needs to be added.
So let&#8217;s check first that without declaring anything, we don&#8217;t have any dependency added:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">$ ./gradlew lib:dependencies --configuration compileClasspath

&gt; Task :lib:dependencies

------------------------------------------------------------
Project ':lib'
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-math3:3.6.1
+--- io.micronaut:micronaut-core:3.3.1
|    \--- org.slf4j:slf4j-api:1.7.29
\--- com.google.guava:guava:30.1.1-jre
     +--- com.google.guava:failureaccess:1.0.1
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.8.0
     +--- com.google.errorprone:error_prone_annotations:2.5.1
     \--- com.google.j2objc:j2objc-annotations:1.3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s switch to use <code>tomcat</code>:</p>
</div>
<div class="listingblock">
<div class="title">lib/build.gradle</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="groovy">micronaut {
   version = "3.3.1"
   runtime = "tomcat"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">$ ./gradlew lib:dependencies --configuration compileClasspath

&gt; Task :lib:dependencies

------------------------------------------------------------
Project ':lib'
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-math3:3.6.1
+--- io.micronaut:micronaut-core:3.3.1
|    \--- org.slf4j:slf4j-api:1.7.29
+--- org.apache.tomcat.embed:tomcat-embed-core:10.0.18
|    \--- org.apache.tomcat:tomcat-annotations-api:10.0.18
\--- com.google.guava:guava:30.1.1-jre
     +--- com.google.guava:failureaccess:1.0.1
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.8.0
     +--- com.google.errorprone:error_prone_annotations:2.5.1
     \--- com.google.j2objc:j2objc-annotations:1.3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the dependency on Tomcat is added!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_more_complex_use_cases_are_supported">More complex use cases are supported!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;ve shown how to add a dependency and derive the dependency notation from the version defined in our extension.
We&#8217;ve then seen how we could add a dependency, or not, based on the value of an extension: either return a <em>supported dependency notation</em>, or <em>null</em> if nothing needs to be added.</p>
</div>
<div class="paragraph">
<p>Gradle actually supports more complex cases, that I will let as an exercise to the reader.
For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>adding a dependency provider and configure its rich version (see <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/dsl/DependencyHandler.html#addProvider-java.lang.String-org.gradle.api.provider.Provider-org.gradle.api.Action-">DependencyHandler#addProvider</a>).</p>
</li>
<li>
<p>adding a <em>list</em> of dependencies, instead of a <em>single</em> dependence (see <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/Configuration.html#getDependencies--">Configuration#getDependencies</a> and <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html#addAllLater-org.gradle.api.provider.Provider-">DependencySet#addAllLater</a>).</p>
</li>
<li>
<p>computing a dependency from two or more providers (see <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Provider.html#zip-org.gradle.api.provider.Provider-java.util.function.BiFunction-">Provider#zip</a>).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this post, we&#8217;ve seen how to leverage Gradle&#8217;s provider API to properly implement plugins which need to add dependencies conditionally.
This can either mean that they need to add dependencies which version depend on some user configuration, or even full dependency notations which depend on configuration.
The interest of using the provider API again lies in the fact that it is <em>lazy</em> and therefore is (largely) immune to ordering issues: instead of relying on hooks like <code>afterEvaluate</code> which come with a number of drawbacks (reliability, ordering, interaction with other plugins), we rely on the fact that it&#8217;s only when a value is <em>needed</em> that it is computed.
At this moment, we know that the configuration is complete, so we can guarantee that our dependencies will be correct.</p>
</div>
</div>
</div></p>
			<p><a href="/blog/2022/03/gradle-conditional-dependencies.html#disqus_thread">Comments</a></p>
	
	<hr />
	
	<p>Older posts are available in the <a href="/blog/archive.html">archive</a>.</p>

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
	<p class="muted credit">All posts on this blog are published with a <em>Creative Commons by-nc-sa</em> license.<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/2.0/fr/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/2.0/fr/88x31.png"/></a></p>
        <p class="muted credit">&copy; 2013 | Mixed with <a href="https://twitter.github.com/bootstrap/">Bootstrap v3.0.3</a> | Baked with <a href="https://jbake.org">JBake v2.6.6</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/blog/js/jquery-1.11.1.min.js"></script>
    <script src="/blog/js/bootstrap.min.js"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
   <script>hljs.highlightAll();</script>
    <script type="text/javascript">
    var disqus_shortname = 'melixblog';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
<script type="text/javascript">
  window.___gcfg = {lang: 'fr'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45962373-1', 'melix.github.io');
  ga('send', 'pageview');

</script>
  </body>
</html>
