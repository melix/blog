<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cédric Champeau's blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">    

    <!-- Le styles -->
    <link href="/blog/css/bootstrap.min.css" rel="stylesheet">
    <link href="/blog/css/asciidoctor.css" rel="stylesheet">
    <link href="/blog/css/base.css" rel="stylesheet">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <script src="/blog/js/highlight.min.js"></script>
    <link href="/blog/css/equilibrium-gray-light.min.css" rel="stylesheet">
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
  </head>
  <body>
    <div id="wrap">
   
	
	<!-- Fixed navbar -->
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
          <div class="container">
	    <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/blog">Cédric Champeau's blog</a>
	    </div>
            <div class="navbar-collapse collapse">
              <ul class="nav navbar-nav">                
                <li><a href="/blog/about.html">About</a></li>
		<li><a href="/blog/projects.html">Projects</a></li>
		<li><a href="/blog/astronomy.html">Astronomy</a></li>
		<li class="dropdown">
          		<a data-toggle="dropdown" href="#">Topics<b class="caret"></b></a>
		          <ul class="dropdown-menu" role="menu">
				<li><a href="/blog/tags/gradle.html">Gradle</a></li>
                <li><a href="/blog/tags/groovy.html">Groovy</a></li>
                <li><a href="/blog/tags/micronaut.html">Micronaut</a></li>
                <li><a href="/blog/tags/index.html">See all tags</a></li>
		          </ul>
	       </li>
                <li><a href="/blog/feed.xml">Feed</a></li>                
              </ul>
	      <ul class="nav navbar-nav navbar-right">
	      	<li><a href="https://github.com/melix"><i class="fa fa-github"></i></a></li>
	        <li><a href="https://twitter.com/CedricChampeau"><i class="fa fa-twitter"></i></a>
	      </ul>
            </div>
          </div>
      </div>
      <div class="container">

	<div class="page-header">
		<h1>Blog</h1>
	</div>
  			<a href="/blog/2022/05/gradle-laziness.html"><h1>Gradle quickie: laziness</h1></a>
  			<p>24 May 2022</p>
			<p><em>Tags: </em>
		<a href="/blog/tags/gradle.html">gradle</a> 
	
		<a href="/blog/tags/laziness.html">laziness</a> 
	</p>
			
  			<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Yesterday, I wrote this tweet:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/blog/img/2022-05-24-tweet.png" alt="2022 05 24 tweet">
</div>
</div>
<div class="paragraph">
<p>I got a surprisingly high number of answers, so I thought it would be a good idea to expand a bit on the topic.</p>
</div>
<div class="paragraph">
<p>Gradle <a href="https://docs.gradle.org/current/userguide/lazy_configuration.html">introduced lazy APIs several years ago</a>.
Those APIs are mostly directed at plugin authors but some build authors may have to deal with them too.
Lazy APIs are designed to improve performance, by avoiding to create tasks which would never be invoked during a build.
While lots of users wouldn&#8217;t notice the difference between a build using lazy APIs and a build which doesn&#8217;t, in some ecosystems like Android or with large projects, this makes a dramatic difference.
In other words, while Gradle&#8217;s performance is often praised, it&#8217;s easy to break performance by unintentionally trigerring configuration of tasks which shouldn&#8217;t.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_task_configuration">Task configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The discussion was trigerred when I was doing a code review yesterday.
I saw the following block:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.withType(Test) {
    testLogging {
        showStandardStreams = true
        exceptionFormat = 'full'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This block configures logging for all test tasks of the project.
At first glance, this seems appropriate, but there&#8217;s this gotcha: you should use <code>.configureEach</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.withType(Test).configureEach {
    testLogging {
        showStandardStreams = true
        exceptionFormat = 'full'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t, then <em>all tasks of type Test will always be configured</em>, even if you don&#8217;t call them in a build.
In other words, lazy configuration is about only configuring tasks which are going to be invoked.</p>
</div>
<div class="paragraph">
<p>Unfortunately, there are no warnings about eager configuration, or "unnecessary" configuration in a build.
If you use <a href="https://ge.micronaut.io">Build Scans</a>, you can have insights about configuration and realize that, but casual users wouldn&#8217;t.</p>
</div>
<div class="paragraph">
<p>Similarly, this code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">test {
    testLogging {
        showStandardStreams = true
        exceptionFormat = 'full'
    }
}
----</code></pre>
</div>
</div>
<div class="paragraph">
<p>Will configure the <code>test</code> task (not <em>all</em> test tasks) eagerly: even if the <code>test</code> task isn&#8217;t executed in a build, it would be configured.
Now you see the problem: this configuration pattern has been there basically forever, so it&#8217;s hard to remove.
To do lazy configuration, you have to write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.named('test') {
    testLogging {
        showStandardStreams = true
        exceptionFormat = 'full'
    }
}
----</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, this isn&#8217;t as nice, DSL-wise.
One thing you may wonder is why Gradle&#8217;s DSL default to the lazy version?
In other words, why doesn&#8217;t it call the lazy version instead of the eager one?</p>
</div>
<div class="paragraph">
<p>It&#8217;s because of backwards compatiblity: because this pattern has been present since day one in Gradle, eager configuration is everywhere in older builds.
If you search for configuration blocks in Stack Overflow, it&#8217;s very likely that you&#8217;ll end up copy and pasting <em>eager configuration</em> samples.
But, as the name implies, <em>lazy</em> configuration has a different behavior than <em>eager</em>: in the lazy case, the configuration block is invoked <em>only when the task is needed</em>, either because it&#8217;s going to be executed, or that another task depends on its configuration to configure itself.
In the eager case, configuration is executed immediately: unfortunately there are lots of builds which accidentally depend on this order of execution, so changing from eager to lazy could result in breaking changes!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_should_you_use">What should you use?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The consequence is that there&#8217;s a mix of lazy and eager APIs in Gradle, and making the difference between what is going to trigger configuration or not isn&#8217;t obvious, even for Gradle experts.
Let&#8217;s summarize a few patterns:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you want to configure <em>one particular task</em> by name, you should write:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.named("myTask") {
   // configure the task
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.named("myTask", SomeType) {
   // configure the task
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>If you want to all tasks of a particular type, you should write:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.withType(SomeType).configureEach {
   // configure the task
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>If you want to create a new task, <em>don&#8217;t use create</em>, but <em>register</em> instead:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.register("myTask", SomeType) {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the DSL, the following code that you find in many tutorials would <em>immediately create a task</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">task hello {
   doLast {
       println "Hello!"
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So the correct way to do this is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.register("hello") {
    doLast {
         println "Hello!"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the return type of both calls is <em>different</em>: the eager version will return a <code>Task</code>, while the 2d one returns a <code>TaskProvider</code>.
This is the reason why upgrading plugins isn&#8217;t that trivial, since it&#8217;s a binary breaking change!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_task_collections_and_implicit_dependencies">Task collections and implicit dependencies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In <a href="https://melix.github.io/blog/2022/01/understanding-provider-api.html">a previous blog post</a> I explained that the provider API is the right way to handle implicit inputs.
For example, you can pass directly a <code>TaskProvider</code> as an element of a file collection: Gradle would automatically resolve dependencies and trigger the configuration of that task, include it in the task graph and use its output as an input of the task you&#8217;re invoking.</p>
</div>
<div class="paragraph">
<p>Therefore, understanding lazy APIs means that you should understand <em>when</em> things are executed.
In the example above, the call <code>tasks.withType(Test)</code> by itself does <em>not</em> configure anything.
You can see it as a lazy predicate: it returns a <em>live task collection</em>, it&#8217;s a declaration of intent: "this models all tasks of type `Test`".</p>
</div>
<div class="paragraph">
<p>Therefore, the following blocks of code are strictly equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.withType(Test) {
   // configure
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.withType(Test).each {
    // configure
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">def testTasks = tasks.withType(Test)
testTasks.each {
    // configure
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other words, the last version explains the "magic" behind the traditional Gradle DSL.
The first line is lazy, returns a task collection, and it&#8217;s the fact of calling <code>.each</code> which triggers configuration of all tasks!
Replace <code>.each</code> with <code>.configureEach</code> and you are now lazy!</p>
</div>
<div class="paragraph">
<p>Newer APIs like <code>named</code> are lazy from day one, but are not necessarily user friendly.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_gradle_puzzle">A Gradle puzzle</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In effect, <code>named</code> is lazy in terms of <em>configuration</em>, but <em>eager</em> in terms of lookup: it will <strong>fail</strong> if the task that you&#8217;re looking for doesn&#8217;t exist.
It&#8217;s a bit strange, since in Gradle everything is now supposed to be lazy, so you can&#8217;t know <em>when</em> a task is going to be available or not.
As an illustration, let&#8217;s explore the following script (don&#8217;t write this in your own builds, this is for demonstration purposes!):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.register("hello") {
   doLast {
       println "Hello,"
   }
}

tasks.named("hello") {
   doLast {
        println "World!"
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you run <code>gradle hello</code>, then the output is what you expect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">&gt; Task :hello
Hello,
World!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, <em>invert</em> the position of the 2 tasks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.named("hello") {
   doLast {
        println "World!"
   }
}

tasks.register("hello") {
   doLast {
       println "Hello,"
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and run again. Boom!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">* Where:
Build file '/tmp/ouudfd/build.gradle' line: 1

* What went wrong:
A problem occurred evaluating root project 'ohnoes'.
&gt; Task with name 'hello' not found in root project 'ohnoes'.</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is very unexpected: I think what most people would expect is, if any change, that the <code>World!</code> and <code>Hello</code> outputs would be exchanged.
But because <code>named</code> <em>eagerly</em> searches for a task registed with a particular name, it <em>fails</em> if not found.</p>
</div>
<div class="paragraph">
<p>As a consequence, plugin authors who want to react to other plugins, or react to tasks which <em>may</em> be present or not, tend to use the following API instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.matching { it.name == 'hello' }.configureEach {
    doLast {
        println "World!"
   }
}

tasks.register("hello") {
   doLast {
       println "Hello,"
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s run our <code>hello</code> task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">&gt; Task :hello
World!
Hello,</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yay! No failure anymore, and the output is in the order we expected. Problem solved, right?</p>
</div>
<div class="paragraph">
<p>Well, not so fast.
You&#8217;ve used <code>configureEach</code>, so everything should be lazy, right?
Sorry, nope: the <code>matching</code> API is an <em>old</em>, eager API!
Actually, if you look at what the predicate uses, it becomes obvious:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// T is a Task!
TaskCollection&lt;T&gt; matching(Spec&lt;? super T&gt; var1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because it works on <code>Task</code> instances, it needs to <em>create and configure the tasks</em> so that you can run an arbitrary predicate on them!</p>
</div>
<div class="paragraph">
<p>That&#8217;s why if you have to write things like this, you <strong>must</strong> guard calls to <code>matching</code> with a <code>withType</code> before, which will restrict the set of tasks which will be configured.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.withType(Greeter).matching { it.name == 'hello' }.configureEach {
   messages.add("World!")
}

tasks.register("hello", Greeter) {
   messages.add("Hello,")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course the example is a bit stupid, but it makes sense when you&#8217;re not the one in control of <em>when</em> a task is configured or even if you don&#8217;t know if it will ever be.</p>
</div>
<div class="paragraph">
<p>Unfortunately, <a href="https://github.com/gradle/gradle/issues/16543">Gradle doesn&#8217;t provide an API which is <em>fully lazy</em> and lenient to tasks being present or not</a>.
If you simply want to <em>configure</em> a task, that is not a big deal since you can simply use <code>configureEach</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.configureEach {
    if (it.name == 'hello') { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is fine because the configuration block will be called for each task being configured.
However, this <code>configureEach</code> block is a <em>configurer</em>, not a <em>predicate</em>, so you can&#8217;t use it as an input to another task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">tasks.named("md5") {
    inputFiles.from(tasks.named("userguide"))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above would <em>fail</em> if the <code>userguide</code> task doesn&#8217;t exist <em>before</em> the <code>md5</code> task is configured&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this blog post, I have explained why you should use the new lazy APIs instead of their eager counterparts.
I have also described that while they are more verbose, they make it possible to have faster builds by avoiding configuration of tasks which would not be executed.
However, Gradle doesn&#8217;t warn you if you eagerly configure tasks, and it&#8217;s easy to shoot yourself in the foot.
Some would blame the docs, some would blame the APIs.</p>
</div>
<div class="paragraph">
<p>As a former Gradler, I would blame none of those: the <a href="https://docs.gradle.org/current/userguide/lazy_configuration.html">docs are here</a>, and changing the APIs to be lazy everywhere is either a binary breaking change (return type of methods which <em>create</em> instead of <em>register</em>), or a behavior change (deferred configuration vs immediate configuration).
This makes it particularly complicated to upgrade builds without pissing off a number of users!</p>
</div>
</div>
</div></p>
			<p><a href="/blog/2022/05/gradle-laziness.html#disqus_thread">Comments</a></p>
  			<a href="/blog/2022/05/astro-twitch.html"><h1>Astrophotographie: rendez-vous sur Twitch !</h1></a>
  			<p>03 May 2022</p>
			<p><em>Tags: </em>
		<a href="/blog/tags/astrophotographie.html">astrophotographie</a> 
	
		<a href="/blog/tags/twitch.html">twitch</a> 
	</p>
			
  			<p><div class="sect1">
<h2 id="_nous_ne_sommes_pas_que_des_développeurs">Nous ne sommes pas que des développeurs !</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ma passion, en dehors du développement, c&#8217;est l&#8217;astronomie.
Depuis quelques années, je me suis lancé dans l&#8217;astrophotographie: je ne fais quasiment plus que ça.
Pour un développeur comme moi, c&#8217;est assez intéressant de constater que lorsque je poste sur Twitter une photo que j&#8217;ai faite, j&#8217;ai bien souvent plus de réponses et de likes que sur mes tweets professionnels (ce qui est parfois vexant, lol !).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_des_lives_sur_twitch">Des lives sur Twitch</h2>
<div class="sectionbody">
<div style="font-size: 1.5em; padding: 6px; background-color: lightblue; border: solid; margin: 2em; text-align: center">
<b>Edit</b>: C'est fait ! L'expérience fut enrichissante pour moi, retrouvez le replay sur <a href="https://www.youtube.com/watch?v=Hudtta97gDU">Youtube</a></b>.
</div>
<div class="paragraph">
<p>J&#8217;ai, au final, souvent les mêmes questions qui reviennent:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Qu&#8217;est ce que c&#8217;est ?</p>
</li>
<li>
<p>Quel matériel tu utilises ?</p>
</li>
<li>
<p>Combien de fois ça grossit ?</p>
</li>
<li>
<p>Est-ce que ce sont de vraies couleurs ?</p>
</li>
<li>
<p>Combien de temps de pose ?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>et bien d&#8217;autres !</p>
</div>
<div class="paragraph">
<p>Alors, l&#8217;an dernier, je me suis lancé ce défi de faire un talk dans une conférence de développeurs (Devoxx) sur le sujet des "miracles du logiciel" en termes d&#8217;astrophotographie.
Malheureusement, le talk n&#8217;a pas été retenu, mais j&#8217;ai conservé en tête l&#8217;idée de présenter quelque chose.</p>
</div>
<div class="paragraph">
<p>Alors, envie de savoir comment on fait des photos comme celle-ci ?</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://www.astrobin.com/full/ollbl5/0/"><img src="/blog/img/astro/2021-11-09-flaming-star-nebula.jpg" alt="2021 11 09 flaming star nebula"></a>
</div>
<div class="title">Figure 1. The flaming star nebula</div>
</div>
<div class="paragraph">
<p>Aujourd&#8217;hui, je vous annonce donc un premier live sur Twitch pour parler d&#8217;astrophotographie !
Je dis premier, parce que je pense qu&#8217;il y a de quoi en faire plusieurs avant d&#8217;avoir fait le tour du sujet.</p>
</div>
<div class="paragraph">
<p>Attention, ça sera sans prétention, pas aussi préparé qu&#8217;un talk en conférence.
Ca sera aussi mon tout premier live et donc probablement plein de problèmes techniques, mais il faut bien se lancer un jour !</p>
</div>
<div class="paragraph">
<p>J&#8217;annonce donc le <strong>jeudi 12 mai à 20h</strong> sur <a href="https://www.twitch.tv/melix_fr">ma chaîne Twitch</a>.</p>
</div>
<div class="paragraph">
<p>Le premier sujet sera autour de mon setup photographique: quel matériel j&#8217;utilise, les principes de base de l&#8217;acquisition photo.
Attention, il ne s&#8217;agira pas d&#8217;une présentation générique sur l&#8217;astrophoto, mais bien d&#8217;une présentation spécifique à mon matériel, soupoudrée de détails sur comment ça fonctionne en règle générale.</p>
</div>
<div class="paragraph">
<p>En fonction du succès et/ou de ce que j&#8217;arrive à couvrir, d&#8217;autres lives seront programmés.</p>
</div>
<div class="paragraph">
<p>A bientôt !</p>
</div>
</div>
</div></p>
			<p><a href="/blog/2022/05/astro-twitch.html#disqus_thread">Comments</a></p>
  			<a href="/blog/2022/03/gradle-conditional-dependencies.html"><h1>Conditional dependencies with Gradle</h1></a>
  			<p>21 March 2022</p>
			<p><em>Tags: </em>
		<a href="/blog/tags/gradle.html">gradle</a> 
	
		<a href="/blog/tags/dependencies.html">dependencies</a> 
	</p>
			
  			<p><div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you ever wrote a Gradle plugin for a framework (e.g <a href="https://micronaut.io">Micronaut</a>) or a plugin which needs to add dependencies if the user configures a particular flag, then it is likely that you&#8217;ve faced some ordering issues.</p>
</div>
<div class="paragraph">
<p>For example, imagine that you have this DSL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">micronaut {
    useNetty = true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, <em>at some point in time</em>, you have to figure out if the property <code>useNetty</code> is set in order to transparently add dependencies.
A naive solution is to use the good old <code>afterEvaluate</code> block.
Many plugins do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">afterEvaluate {
    dependencies {
        if (micronaut.useNetty.get()) {
            implementation("io.netty:netty-buffer:4.1.75.Final")
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is that while <em>afterEvaluate</em> seems to fix the problem, it&#8217;s just a dirty workaround which defers the problem to a later stage: depending on the plugins which are applied, which themselves could use <code>afterEvaluate</code>, your block may, or may not, see the "final" configuration state.</p>
</div>
<div class="paragraph">
<p>In a <a href="https://melix.github.io/blog/2022/01/understanding-provider-api.html">previous post</a>, I introduced Gradle&#8217;s provider API.
In this post, we&#8217;re going to show how to use it to properly fix this problem.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_providers_for_dependencies">Using providers for dependencies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s start with the easiest.
It&#8217;s a common requirement of a plugin to provide the ability to override the version of a runtime.
For example, the <code>checkstyle</code> plugin would, by default, use version of checkstyle by convention, but it would still let you override the version if you want to use a different one.</p>
</div>
<div class="paragraph">
<p>Micronaut provides a similar feature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">micronaut {
    version = "3.3.1"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Micronaut dependencies to be added on the user classpath depend on the value of the <code>version</code> in our <code>micronaut</code> extension.
Let&#8217;s see how we can implement this.
Let&#8217;s create our Gradle project (we&#8217;re assuming that you have Gradle 7.4 installed):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mkdir conditional-deps &amp;&amp; cd conditional-deps
$ gradle init --dsl groovy \
   --type java-library \
   --package me.champeau.demo \
   --incubating \
   --test-framework junit-jupiter</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we&#8217;re going to create a folder for our build logic, which will contain our plugin sources:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mkdir -p build-logic/src/main/groovy/my/plugin</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s update the <code>settings.gradle</code> file to <em>include</em> that build logic:</p>
</div>
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">pluginManagement {
    // include our plugin
    includeBuild "build-logic"
}
rootProject.name = 'provider-dependencies'
include('lib')</code></pre>
</div>
</div>
<div class="paragraph">
<p>For now our plugin is an empty shell, so let&#8217;s create its <code>build.gradle</code> file so that we can use a <a href="https://docs.gradle.org/7.4.1/userguide/custom_plugins.html#sec:precompiled_plugins">precompiled script plugin</a>.</p>
</div>
<div class="listingblock">
<div class="title">build-logic/build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">plugins {
    id 'groovy-gradle-plugin'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s define our extension, which is simply about declaring an <em>interface</em>:</p>
</div>
<div class="listingblock">
<div class="title">build-logic/src/main/groovy/my/plugin/MicronautExtension.groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">package my.plugin

import org.gradle.api.provider.Property

interface MicronautExtension {
    Property&lt;String&gt; getVersion()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s now time to create our plugin: precompiled script plugins are a very easy way to create a plugin, simply by declaring a file in <code>build-logic/src/main/groovy</code> which name ends with <code>.gradle</code>:</p>
</div>
<div class="listingblock">
<div class="title">build-logic/src/main/groovy/my.plugin.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">import my.plugin.MicronautExtension

def micronautExtension = extensions.create("micronaut", MicronautExtension) <i class="conum" data-value="1"></i><b>(1)</b>
micronautExtension.version.convention("3.3.0")                              <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create our extension, named "micronaut"</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Assign a default value to the "version" property</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By convention, our plugin id will be <code>my.plugin</code> (it&#8217;s derived from the file name).
Our plugin is responsible for creating the extension, and it assigns a <em>convention</em> value to the <code>version</code> property: this is the value which is going to be used if the user doesn&#8217;t declare anything explicitly.</p>
</div>
<div class="paragraph">
<p>Then we can <em>use</em> the plugin in our main build, that is, in the <code>lib</code> project:</p>
</div>
<div class="listingblock">
<div class="title">lib/build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">plugins {
    // Apply the java-library plugin for API and implementation separation.
    id 'java-library'
    // And now apply our plugin
    id 'my-plugin'
}

micronaut {
   // empty for now
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we look at the <code>lib</code> compile classpath, it will not include any Micronaut dependency for now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./gradlew lib:dependencies --configuration compileClasspath

------------------------------------------------------------
Project ':lib'
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-math3:3.6.1
\--- com.google.guava:guava:30.1.1-jre
     +--- com.google.guava:failureaccess:1.0.1
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.8.0
     +--- com.google.errorprone:error_prone_annotations:2.5.1
     \--- com.google.j2objc:j2objc-annotations:1.3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our goal is to add a dependency which is <em>derived from</em> the version defined in our Micronaut extension, so let&#8217;s do this.
Edit our <code>build-logic</code> plugin:</p>
</div>
<div class="listingblock">
<div class="title">build-logic/src/main/groovy/my.plugin.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">import my.plugin.MicronautExtension

def micronautExtension = extensions.create("micronaut", MicronautExtension)
micronautExtension.version.convention("3.3.0")

dependencies {
    implementation micronautExtension.version.map {
        v -&gt; "io.micronaut:micronaut-core:$v"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s run our dependencies report again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./gradlew lib:dependencies --configuration compileClasspath

&gt; Task :lib:dependencies

------------------------------------------------------------
Project ':lib'
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-math3:3.6.1
+--- io.micronaut:micronaut-core:3.3.0
|    \--- org.slf4j:slf4j-api:1.7.29
\--- com.google.guava:guava:30.1.1-jre
     +--- com.google.guava:failureaccess:1.0.1
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.8.0
     +--- com.google.errorprone:error_prone_annotations:2.5.1
     \--- com.google.j2objc:j2objc-annotations:1.3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Victory! Now we can see our <code>micronaut-core</code> dependency.
How did we do this?</p>
</div>
<div class="paragraph">
<p>Note that instead of using <code>afterEvaluate</code>, what we did is <em>adding a dependency</em>, but instead of using the traditional dependency notation, we used a <em>provider</em>: the actual dependency string is computed <em>only when we need it</em>.
We can check that we can actually configure the version via our extension by editing our build file:</p>
</div>
<div class="listingblock">
<div class="title">lib/build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">micronaut {
   version = "3.3.1" // override the convention
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./gradlew lib:dependencies --configuration compileClasspath

&gt; Task :lib:dependencies

------------------------------------------------------------
Project ':lib'
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-math3:3.6.1
+--- io.micronaut:micronaut-core:3.3.1
|    \--- org.slf4j:slf4j-api:1.7.29
\--- com.google.guava:guava:30.1.1-jre
     +--- com.google.guava:failureaccess:1.0.1
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.8.0
     +--- com.google.errorprone:error_prone_annotations:2.5.1
     \--- com.google.j2objc:j2objc-annotations:1.3</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_maybe_add_maybe_not">Maybe add, maybe not!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous example, we have <em>systematically added</em> a dependency, based on the version defined in the extension.
What if we want to add a dependency if a property is set to a particular value?
For this purpose, let&#8217;s say that we define a <code>runtime</code> property which will tell what runtime to use.
Let&#8217;s add this property to our extension:</p>
</div>
<div class="listingblock">
<div class="title">build-logic/src/main/groovy/my/plugin/MicronautExtension.groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">package my.plugin

import org.gradle.api.provider.Property

interface MicronautExtension {
    Property&lt;String&gt; getVersion()
    Property&lt;String&gt; getRuntime()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s update our plugin to use that property, and add a dependency based on the value of the <em>runtime</em> property:</p>
</div>
<div class="listingblock">
<div class="title">build-logic/src/main/groovy/my.plugin.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">import my.plugin.MicronautExtension

def micronautExtension = extensions.create("micronaut", MicronautExtension)
micronautExtension.version.convention("3.3.0")

dependencies {
    implementation micronautExtension.version.map { v -&gt;
        "io.micronaut:micronaut-core:$v"
    }

    implementation micronautExtension.runtime.map { r -&gt;
        switch(r) {
            case 'netty':                                                   <i class="conum" data-value="1"></i><b>(1)</b>
                return "io.netty:netty-buffer:4.1.75.Final"
            case 'tomcat':
                return "org.apache.tomcat.embed:tomcat-embed-core:10.0.18"  <i class="conum" data-value="2"></i><b>(2)</b>
            default:
                return null                                                 <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Add a dependency if the runtime is set to netty</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Add a dependency if the runtime is set to tomcat</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>But do nothing if the runtime isn&#8217;t set</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The trick, therefore, is to <em>return null</em> in the provider in case no dependency needs to be added.
So let&#8217;s check first that without declaring anything, we don&#8217;t have any dependency added:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./gradlew lib:dependencies --configuration compileClasspath

&gt; Task :lib:dependencies

------------------------------------------------------------
Project ':lib'
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-math3:3.6.1
+--- io.micronaut:micronaut-core:3.3.1
|    \--- org.slf4j:slf4j-api:1.7.29
\--- com.google.guava:guava:30.1.1-jre
     +--- com.google.guava:failureaccess:1.0.1
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.8.0
     +--- com.google.errorprone:error_prone_annotations:2.5.1
     \--- com.google.j2objc:j2objc-annotations:1.3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s switch to use <code>tomcat</code>:</p>
</div>
<div class="listingblock">
<div class="title">lib/build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">micronaut {
   version = "3.3.1"
   runtime = "tomcat"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./gradlew lib:dependencies --configuration compileClasspath

&gt; Task :lib:dependencies

------------------------------------------------------------
Project ':lib'
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-math3:3.6.1
+--- io.micronaut:micronaut-core:3.3.1
|    \--- org.slf4j:slf4j-api:1.7.29
+--- org.apache.tomcat.embed:tomcat-embed-core:10.0.18
|    \--- org.apache.tomcat:tomcat-annotations-api:10.0.18
\--- com.google.guava:guava:30.1.1-jre
     +--- com.google.guava:failureaccess:1.0.1
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.8.0
     +--- com.google.errorprone:error_prone_annotations:2.5.1
     \--- com.google.j2objc:j2objc-annotations:1.3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the dependency on Tomcat is added!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_more_complex_use_cases_are_supported">More complex use cases are supported!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;ve shown how to add a dependency and derive the dependency notation from the version defined in our extension.
We&#8217;ve then seen how we could add a dependency, or not, based on the value of an extension: either return a <em>supported dependency notation</em>, or <em>null</em> if nothing needs to be added.</p>
</div>
<div class="paragraph">
<p>Gradle actually supports more complex cases, that I will let as an exercise to the reader.
For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>adding a dependency provider and configure its rich version (see <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/dsl/DependencyHandler.html#addProvider-java.lang.String-org.gradle.api.provider.Provider-org.gradle.api.Action-">DependencyHandler#addProvider</a>).</p>
</li>
<li>
<p>adding a <em>list</em> of dependencies, instead of a <em>single</em> dependence (see <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/Configuration.html#getDependencies--">Configuration#getDependencies</a> and <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html#addAllLater-org.gradle.api.provider.Provider-">DependencySet#addAllLater</a>).</p>
</li>
<li>
<p>computing a dependency from two or more providers (see <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Provider.html#zip-org.gradle.api.provider.Provider-java.util.function.BiFunction-">Provider#zip</a>).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this post, we&#8217;ve seen how to leverage Gradle&#8217;s provider API to properly implement plugins which need to add dependencies conditionally.
This can either mean that they need to add dependencies which version depend on some user configuration, or even full dependency notations which depend on configuration.
The interest of using the provider API again lies in the fact that it is <em>lazy</em> and therefore is (largely) immune to ordering issues: instead of relying on hooks like <code>afterEvaluate</code> which come with a number of drawbacks (reliability, ordering, interaction with other plugins), we rely on the fact that it&#8217;s only when a value is <em>needed</em> that it is computed.
At this moment, we know that the configuration is complete, so we can guarantee that our dependencies will be correct.</p>
</div>
</div>
</div></p>
			<p><a href="/blog/2022/03/gradle-conditional-dependencies.html#disqus_thread">Comments</a></p>
  			<a href="/blog/2022/02/micronaut-version-catalog.html"><h1>Using the Micronaut Version Catalog</h1></a>
  			<p>08 February 2022</p>
			<p><em>Tags: </em>
		<a href="/blog/tags/gradle.html">gradle</a> 
	
		<a href="/blog/tags/micronaut.html">micronaut</a> 
	
		<a href="/blog/tags/version-catalog.html">version catalog</a> 
	</p>
			
  			<p><div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With the <a href="https://docs.gradle.org/7.4/release-notes.html">release of Gradle 7.4</a>, Micronaut users now have an interesting option to manage their dependencies: using Gradle&#8217;s <a href="https://docs.gradle.org/current/userguide/platforms.html#sub:central-declaration-of-dependencies">version catalogs</a>.
Indeed, for a few releases already, Micronaut has shipped its own version catalog alongside its BOM.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s explore how to use it and what&#8217;s the benefit.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_a_version_catalog">What is a version catalog?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In a nutshell, a version catalog allows centralizing dependency versions in a single place.
Instead a build script, a typical dependency declaration looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">dependencies {
    implementation("org.apache.slf4j:slf4j-api:1.7.25")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With a version catalog, the declaration looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">dependencies {
    implementation(libs.slf4j)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the dependency coordinates are defined in the <code>gradle/libs.versions.toml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-toml hljs" data-lang="toml">[versions]
slf4j = "1.7.25"

[libraries]
slf4j = { module = "org.apache.slf4j", version.ref = "slf4j" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are a couple of advantages in doing so:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>dependency versions are centralized in this TOML file</p>
</li>
<li>
<p>the catalogs create "type safe accessors" which are completed by the IDE (although to my knowledge completion is only supported by IntelliJ IDEA with the Kotlin DSL)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can read a more complete description about version catalogs in <a href="https://melix.github.io/blog/2021/03/version-catalogs.html">this blog post I wrote a few months ago</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_micronaut_version_catalog">The Micronaut version catalog</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition, frameworks like Micronaut can <em>publish</em> version catalogs, which are then usable in your projects.
You can then think of the Micronaut version catalog as a list of dependencies to pick up from: you don&#8217;t have to think about a version to choose, you can simply use the "recommendation" from Micronaut, but you don&#8217;t have to remember the dependency coordinates either.</p>
</div>
<div class="sect2">
<h3 id="_importing_the_micronaut_version_catalog">Importing the Micronaut version catalog</h3>
<div class="paragraph">
<p>Let&#8217;s start with a project that you can generate using the Micronaut CLI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">mn create-app catalog</code></pre>
</div>
</div>
<div class="paragraph">
<p>(alternatively, download the project using <a href="https://launch.micronaut.io/">Micronaut Launch</a>)</p>
</div>
<div class="paragraph">
<p>Open the generated project and update the Gradle version by changing the <code>gradle/gradle-wrapper.properties</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">distributionUrl=https\://services.gradle.org/distributions/gradle-7.4-bin.zip</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, in order to import the Micronaut version catalog, add this to your <code>settings.gradle</code> file:</p>
</div>
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">dependencyResolutionManagement {
    repositories {
        mavenCentral()
    }
    versionCatalogs {
        create("mn") {
            from("io.micronaut:micronaut-bom:${micronautVersion}")
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we&#8217;re creating a new version catalog called <code>mn</code>.
Internally, Gradle will automatically download the catalog which is <a href="https://repo1.maven.org/maven2/io/micronaut/micronaut-bom/3.3.1/">published at the same GAV coordinates as its BOM</a> as a <a href="https://repo1.maven.org/maven2/io/micronaut/micronaut-bom/3.3.1/">TOML file</a> and expose it to your build scripts.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s open our <code>build.gradle</code> file.
By default it defines the following dependencies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">dependencies {
    annotationProcessor("io.micronaut:micronaut-http-validation")
    implementation("io.micronaut:micronaut-http-client")
    implementation("io.micronaut:micronaut-jackson-databind")
    implementation("io.micronaut:micronaut-runtime")
    implementation("jakarta.annotation:jakarta.annotation-api")
    runtimeOnly("ch.qos.logback:logback-classic")
    implementation("io.micronaut:micronaut-validation")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, we can replace this with the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">dependencies {
    annotationProcessor(mn.micronaut.http.validation)
    implementation(mn.micronaut.http.client)
    implementation(mn.micronaut.jackson.databind)
    implementation(mn.micronaut.runtime)
    implementation(mn.jakarta.annotation.api)
    runtimeOnly(mn.logback)
    implementation(mn.micronaut.validation)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What happened here?
Basically, we replaced hardcoded dependency coordinates with references to the <code>mn</code> version catalog.
It&#8217;s particularly interesting if you are using the Kotlin DSL as I mentioned earlier, because in this case, the dependency notations are <em>type-safe</em>: you <em>can&#8217;t</em> make a typo in dependency coordinates, and you get completion:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/blog/img/catalog/catalog-completion.gif" alt="catalog completion">
</div>
</div>
<div class="paragraph">
<p>Nice!</p>
</div>
</div>
<div class="sect2">
<h3 id="_future_work">Future work</h3>
<div class="paragraph">
<p>Version catalogs will probably be enabled by default in future releases of Micronaut, which means that projects created via <a href="https://launch.micronaut.io/">Micronaut Launch</a> or the CLI tool would automatically use the catalog, so you don&#8217;t have to do the conversion described in this blog post. Stay tuned!</p>
</div>
</div>
</div>
</div></p>
			<p><a href="/blog/2022/02/micronaut-version-catalog.html#disqus_thread">Comments</a></p>
	
	<hr />
	
	<p>Older posts are available in the <a href="/blog/archive.html">archive</a>.</p>

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
	<p class="muted credit">All posts on this blog are published with a <em>Creative Commons by-nc-sa</em> license.<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/2.0/fr/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/2.0/fr/88x31.png"/></a></p>
        <p class="muted credit">&copy; 2013 | Mixed with <a href="https://twitter.github.com/bootstrap/">Bootstrap v3.0.3</a> | Baked with <a href="https://jbake.org">JBake v2.6.6</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/blog/js/jquery-1.11.1.min.js"></script>
    <script src="/blog/js/bootstrap.min.js"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
   <script>hljs.highlightAll();</script>
    <script type="text/javascript">
    var disqus_shortname = 'melixblog';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
<script type="text/javascript">
  window.___gcfg = {lang: 'fr'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45962373-1', 'melix.github.io');
  ga('send', 'pageview');

</script>
  </body>
</html>
