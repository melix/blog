<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cédric Champeau's blog: Improved sandboxing of Groovy scripts</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">    

    <!-- Le styles -->
    <link href="/blog/css/bootstrap.min.css" rel="stylesheet">
    <link href="/blog/css/asciidoctor.css" rel="stylesheet">
    <link href="/blog/css/base.css" rel="stylesheet">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
    </head>
  <body>
	<div id="fb-root"></div>
	<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<script src="//platform.linkedin.com/in.js" type="text/javascript">
 lang: en_US
</script>
    <div id="wrap">
	
	<!-- Fixed navbar -->
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
          <div class="container">
	    <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/blog">Cédric Champeau's blog</a>
	    </div>
            <div class="navbar-collapse collapse">
              <ul class="nav navbar-nav">                
                <li><a href="/blog/about.html">About</a></li>
		<li><a href="/blog/projects.html">Projects</a></li>
		<li><a href="/blog/conferences.html">Conferences</a></li>
		<li class="dropdown">
          		<a data-toggle="dropdown" href="#">Topics<b class="caret"></b></a>
		          <ul class="dropdown-menu" role="menu">
				<li><a href="/blog/tags/groovy.html">Groovy</a></li>
				<li><a href="/blog/2013/07/30/deck2pdf_exporting_html5_slide_decks.html">deck2pdf</a></li>
				<li><a href="/blog/tags/jlangdetect.html">JLangDetect</a></li>
		          </ul>
	       </li>
                <li><a href="/blog/feed.xml">Feed</a></li>                
              </ul>
	      <ul class="nav navbar-nav navbar-right">
	      	<li><a href="https://github.com/melix"><i class="fa fa-github"></i></a></li>
	        <li><a href="https://twitter.com/CedricChampeau"><i class="fa fa-twitter"></i></a>
	      </ul>
            </div>
          </div>
      </div>
      <div class="container">
	
	<div class="page-header">
		<h1>Improved sandboxing of Groovy scripts</h1>
	</div>

	<p><em>27 mars 2015</em></p>
	<p><em>Tags: </em>
		<a href="/blog/tags/groovy.html">groovy</a> 
	</em>
		<a href="/blog/tags/sandoxing.html">sandoxing</a> 
	</em>
		<a href="/blog/tags/type-checking.html">type checking</a> 
	</em>
		<a href="/blog/tags/AST.html">AST</a> 
	</em>
		<a href="/blog/tags/secure.html">secure</a> 
	</p>
	<a href="https://twitter.com/share" class="twitter-share-button" data-url="http://melix.github.io/blog/2015/03/sandboxing.html" data-via="CedricChampeau" data-lang="fr">Tweeter</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
	<div class="g-plusone" data-size="medium" data-href="http://melix.github.io/blog/2015/03/sandboxing.html"></div>
        <script id='fbvpgng'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=CedricChampeau&button=compact&url='+encodeURIComponent('http://melix.github.io/blog/2015/03/sandboxing.html');f.title='Flattr';f.height=20;f.width=110;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fbvpgng');</script>
	<script type="IN/Share" data-url="http://melix.github.io/blog/2015/03/sandboxing.html" data-counter="right"></script>
	<div class="fb-like" data-href="http://melix.github.io/blog/2015/03/sandboxing.html" data-layout="button_count" data-action="like" data-show-faces="false" data-share="true"></div>
	<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>One of the most current uses cases of Groovy is scripting. Groovy makes it very easy to execute code dynamically, at runtime. Depending
on the application, scripts can be found in multiple sources: file system, databases, remote services, &#8230; but more importantly, the
designer of the application which executes scripts is not necessarily the one writing those scripts. Moreover, the scripts might run in a
constrained environment (limited memory, file descriptors, time, &#8230;) or your you simply don&#8217;t want to allow users to access the full
capabilities of the language from a script.</p>
</div>
<div class="openblock INFO"><div class="title">What you will learn in this post</div>
<div class="content">
<div class="ulist">
<ul>
<li>
<p>why Groovy is a good fit to write internal DSLs</p>
</li>
<li>
<p>what it implies in terms of security in your applications</p>
</li>
<li>
<p>how you can customize compilation to improve the DSL</p>
</li>
<li>
<p>the meaning of <code>SecureASTCustomizer</code></p>
</li>
<li>
<p>what are type checking extensions</p>
</li>
<li>
<p>how you can rely on type checking extensions to offer proper sandboxing</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>For example, imagine that you want to offer users the ability to evaluate mathematical expressions. One option would be to implement your
own internal DSL, create a parser and eventually an interpreter for those expressions. Obviously this involves a bit of work, but if in
the end you need to improve performance, for example by generating bytecode for the expressions instead of evaluating them, or introduce
caching of those runtime generated classes, then Groovy is probably a very good option.</p>
</div>
<div class="paragraph">
<p>There are lots of options available, described in the <a href="http://docs.groovy-lang.org/latest/html/documentation/index.html#_integrating_groovy_in_a_java_application">documentation</a>
but the most simple example is just using the <code>Eval</code> class:</p>
</div>
<div class="listingblock">
<div class="title">Example.java</div>
<div class="content">
<pre class="prettyprint java language-java"><code>int sum = (Integer) Eval.me("1+1");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code <code>1+1</code> is parsed, compiled to bytecode, loaded and eventually executed by Groovy at runtime. Of course in this example the code is very simple, and you will want to
add parameters, but the idea is that the code which is executed here is arbitrary. This is probably not what you want. For a calculator, you want to allow expressions like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>1+1
x+y
1+(2*x)**y
cos(alpha)*r
v=1+x</code></pre>
</div>
</div>
<div class="paragraph">
<p>but certainly not</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>println 'Hello'
(0..100).each { println 'Blah' }
Pong p = new Pong()
println(new File('/etc/passwd').text)
System.exit(-1)
Eval.me('System.exit(-1)') // a script within a script!</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is where things start to become complicated, and where we start seeing actually multiple needs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>restricting the grammar of the language to a subset of its capabilities</p>
</li>
<li>
<p>preventing users from executing unexpected code</p>
</li>
<li>
<p>preventing users from executing malicious code</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The calculator example is pretty simple, but for more complex DSLs, people might actually start writing problematic code without noticing, especially if the DSL is suffiently elegant to be used
by <em>non developers</em>.</p>
</div>
<div class="paragraph">
<p>I was in this situation a few years ago, when I designed an engine that used Groovy "scripts" written by linguists. One of the problems was that they could unintentionally create infinite loops,
for example. Code was executing on the server, and then you had a thread eating 100% of the CPU and had no choice but restart the application server so I had to find a way to mitigate that
problem without compromising the DSL nor the tooling or the performance of the application.</p>
</div>
<div class="paragraph">
<p>Actually, lots of people have similar needs. During the past 4 years, I spoke to tons of users who had a similar question: <em>How can I prevent users from doing bad things in Groovy scripts?</em></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compilation_customizers">Compilation customizers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At that time, I had implemented my own solution, but I knew that other people also had implemented similar ones. In the end, Guillaume Laforge
suggested to me that I wrote something that would help fixing those issues and make into Groovy core. This happened in Groovy 1.8.0 with
<a href="http://docs.groovy-lang.org/latest/html/documentation/index.html#compilation-customizers">compilation customizers</a>.</p>
</div>
<div class="paragraph">
<p>Compilation customizers are a set of classes that are aimed at tweaking the compilation of Groovy scripts. You can write your own customizer but Groovy ships with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an import customizer, which aims at adding imports transparently to scripts, so that users do not have to add "import" statements</p>
</li>
<li>
<p>an AST (Abstract Syntax Tree) transformation customizer, which allows to add AST transformations transparently to scripts</p>
</li>
<li>
<p>a secure AST customizer, which aims at restricting the grammar and syntactical constructs of the language</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The AST transformation customizer allowed me to solve the infinite loop issue, by applying the <a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/transform/ThreadInterrupt.html">@ThreadInterrupt</a>
transformation, but the <a href="http://docs.groovy-lang.org/latest/html/api/org/codehaus/groovy/control/customizers/SecureASTCustomizer.html">SecureASTCustomizer</a> is probably the one which has
been the most misinterpreted of the whole.</p>
</div>
<div class="paragraph">
<p>I must apologize for this. Back then, I had no better name in mind. The important part of SecureASTCustomizer is <strong>AST</strong>. It was aimed at restricting access to some features of the AST. The
"secure" part is actually not a good name at all, and I will illustrate why. You can even find a blog post from Kohsuke Kawagushi, of Jenkins fame, named
Groovy SecureASTCustomizer is harmful[<a href="http://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/">http://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/</a>]. It is very true. The SecureASTCustomizer has never been designed with sandboxing
in mind. It was designed to restrict the language at compile time, not runtime. So a much better name, in retrospect, would have been <em>GrammarCustomizer</em>. But as you&#8217;re certainly aware, there
are two hard things in computer science: cache invalidation, naming things and off by one errors.</p>
</div>
<div class="paragraph">
<p>So imagine that you think of the secure AST customizer as a way of securing your script, and that you want to use this to prevent a user from calling <code>System.exit</code> from a script. The
documentation says that you can prevent calls on some specific receivers by defining either a blacklist or a whitelist. In terms of securing something, I would always recommand to use a
whitelist, that is to say to list explicitly what is allowed, rather than a blacklist, saying what is disallowed. The reason is that hackers always think of things you don&#8217;t, so let&#8217;s illustrate
this.</p>
</div>
<div class="paragraph">
<p>Here is how a naive "sandbox" script engine could be configured using the <code>SecureASTCustomizer</code>. I am writing the examples of configuration in Java, even though I could write them in Groovy, just
to make the difference between the integration code and the scripts clear.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>public class Sandbox {
    public static void main(String[] args)  {
        CompilerConfiguration conf = new CompilerConfiguration();				<i class="conum" data-value="1"></i><b>(1)</b>
        SecureASTCustomizer customizer = new SecureASTCustomizer();				<i class="conum" data-value="2"></i><b>(2)</b>
        customizer.setReceiversBlackList(Arrays.asList(System.class.getName()));		<i class="conum" data-value="3"></i><b>(3)</b>
        conf.addCompilationCustomizers(customizer);						<i class="conum" data-value="4"></i><b>(4)</b>
        GroovyShell shell = new GroovyShell(conf);						<i class="conum" data-value="5"></i><b>(5)</b>
        Object v = shell.evaluate("System.exit(-1)");						<i class="conum" data-value="6"></i><b>(6)</b>
        System.out.println("Result = " +v);							<i class="conum" data-value="7"></i><b>(7)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>create a compiler configuration</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>create a secure AST customizer</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>declare that the <code>System</code> class is blacklisted as the receiver of method calls</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>add the customizer to the compiler configuration</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>associate the configuration to the script shell, that is, try to create a sandbox</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>execute a nasty script</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>print the result of the execution of the script</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you run this class, when the script is executed, it will throw an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>General error during canonicalization: Method calls not allowed on [java.lang.System]
java.lang.SecurityException: Method calls not allowed on [java.lang.System]</pre>
</div>
</div>
<div class="paragraph">
<p>This is the result of the application of the secure AST customizer, which prevents the execution of methods on the <code>System</code> class. Success! Now we have secured our script! Oh wait&#8230;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_secureastcustomizer_pwned">SecureASTCustomizer pwned!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Secure you say? So what if I do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>def c = System
c.exit(-1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Execute again and you will see that the program exits <strong>without</strong> error and <strong>without</strong> printing the result. The return code of the process is -1, which indicates that the user script has been executed!
What happened? Basically, at compile time, the secure AST customizer is not able to recognize that <code>c.exit</code> is a call on <code>System</code>, because it works at the AST level! It analyzes a method call, and
in this case the method call is <code>c.exit(-1)</code>, then gets the receiver and checks if the receiver is in the whitelist (or blacklist). In this case, the receiver is <code>c</code> and this variable is <strong>declared
with def</strong>, which is equivalent to declaring it as <code>Object</code>, so it will think that <code>c</code> is <code>Object</code>, not <code>System</code>!</p>
</div>
<div class="paragraph">
<p>Actually there are <strong>many</strong> ways to workaround the various configurations that you can make on the secure AST customizer. Just for fun, a few of them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>((Object)System).exit(-1)
Class.forName('java.lang.System').exit(-1)
('java.lang.System' as Class).exit(-1)

import static java.lang.System.exit
exit(-1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and there are <strong>much</strong> more options. The dynamic nature of Groovy just makes it impossible to resolve those cases at compile time. There are solutions though. One option is to rely on the JVM standard
security manager. However this is a system wide solution which is often considered as a hammer. But it also doesn&#8217;t really work for all cases, for example you might not want to prevent creation of
files, but only reads for example&#8230;</p>
</div>
<div class="paragraph">
<p>This limitation - or should I say frustration for lots of us - led several people to create a solution based on <strong>runtime checks</strong>. Runtime checks do not suffer the same problem, because you
will have for example the actual receiver type of a message before checking if a method call is allowed or not. In particular, those implementations are of particular interest:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/jimwhite/Gondor/blob/master/src/org/ifcx/gondor/SecuredScript.java">SecureScript</a> by Jim White</p>
</li>
<li>
<p><a href="http://groovy-sandbox.kohsuke.org/">Groovy Sandbox</a> by Kohsuke Kawagushi</p>
</li>
<li>
<p><a href="https://github.com/simon-temple/groovy-sandbox">Groovy Sandbox</a> by Simon Temple</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However none of those implementations is totally secure or reliable. For example, the version by Kohsuke relies on hacking the internal implementation of call site caching. The problem is that it is
not compatible with the invokedynamic version of Groovy, and those internal classes are going to be removed in future versions of Groovy. The version by Simon, on the other hand, relies on AST transformations
but misses a lot of possible hacks.</p>
</div>
<div class="paragraph">
<p>As a result, with friends of mine Corinne Krych, Fabrice Matrat and Sébastien Blanc, we decided to create a new runtime sandboxing mechanism that would not have the issues of those projects. We started
implementing this during a hackathon in Nice, and <a href="http://greachconf.com/speakers/fabrice-matrat-cedric-champeau-groovy-head-in-the-cloud/">we gave a talk about this last year</a> at the Greach conference.
It relies on AST transformations and heavily rewrites the code in order to perform a check before each method call, property access, increment of variable, binary expression, &#8230;
The <a href="https://github.com/rivieragug/groovy-core/tree/secureruntime">implementation</a> is still incomplete, and not much work has been done because I realized there was still a problem in case
of methods or properties called on "implicit this", like in builders for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>xml {
   cars {				 // cars is a method call on an implicit this: "this".cars(...)
     car(make:'Renault', model: 'Clio')
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As of today I still didn&#8217;t find a way to properly handle this because of the design of the meta-object protocol in Groovy, that here relies on the fact that a receiver throws an exception when the method
is not found before trying another receiver. In short, it means that you cannot know the type of the receiver before the method is actually called. And if it is called, it&#8217;s already too late&#8230;</p>
</div>
<div class="paragraph">
<p>Until earlier this year I had still no perfect solution to this problem, in case the script being executed is using the dynamic features of the language. But now has come the time to explain how you can
significantly improve the situation if you are ready to loose some of the dynamism of the language.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_type_checking">Type checking</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s come back to the root problem of the SecureASTCustomizer: it works on the abstract syntax tree and has no knowledge of the concrete types of the receivers of messages. But since Groovy 2, Groovy has
optional compilation, and in Groovy 2.1, we added <a href="http://docs.groovy-lang.org/latest/html/documentation/#_type_checking_extensions">type checking extensions</a>.</p>
</div>
<div class="paragraph">
<p>Type checking extensions are very powerful: they allow the designer of a Groovy DSL to help the compiler infer types, but it also lets you throw compilation errors when normally it should not. Type
checking extensions are even used internally in Groovy to support the static compiler, for example to implement traits or the
<a href="http://docs.groovy-lang.org/latest/html/documentation/markup-template-engine.html">markup template engine</a>.</p>
</div>
<div class="paragraph">
<p>What if, instead of relying on the information available after parsing, we could rely on information from the type checker? Take the following code that our hacker tried to write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>((Object)System).exit(-1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you activate type checking, this code would not compile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1 compilation error:

[Static type checking] - Cannot find matching method java.lang.Object#exit(java.lang.Integer). Please check if the declared type is right and if the method exists.</pre>
</div>
</div>
<div class="paragraph">
<p>So this code would not compile anymore. But what if the code is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>def c = System
c.exit(-1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can verify that this passes type checking by wrapping the code into a method and running the script with the <code>groovy</code> command line tool:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>@groovy.transform.TypeChecked // or even @CompileStatic
void foo() {
  def c = System
  c.exit(-1)
}
foo()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the type checker will recognize that the <code>exit</code> method is called on the <code>System</code> class and is valid. It will not help us there. But what we know, if this code passes type checking, is that the
compiler recognized the call on the <code>System</code> receiver. The idea, then, is to rely on a type checking extension to disallow the call.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_simple_type_checking_extension">A simple type checking extension</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before we dig into the details about sandboxing, let&#8217;s try to "secure" our script using a traditional type checking extension. Registering a type checking extension is easy: just set the <code>extensions</code>
parameter of the <code>@TypeChecked</code> annotation (or <code>@CompileStatic</code> if you want to use static compilation):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>@TypeChecked(extensions=['SecureExtension1.groovy'])
void foo() {
  def c = System
  c.exit(-1)
}
foo()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The extension will be searched on classpath in source form (there&#8217;s an option to have precompiled type checking extensions but this is beyond the scope of this blog post):</p>
</div>
<div class="listingblock">
<div class="title">SecureExtension1.groovy</div>
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>onMethodSelection { expr, methodNode -&gt;					<i class="conum" data-value="1"></i><b>(1)</b>
   if (methodNode.declaringClass.name=='java.lang.System') {		<i class="conum" data-value="2"></i><b>(2)</b>
      addStaticTypeError("Method call is not allowed!", expr)		<i class="conum" data-value="3"></i><b>(3)</b>
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>when the type checker selects the target method of a call</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>then if the selected method belongs to the <code>System</code> class</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>make the type checker throw an error</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That&#8217;s really all needed. Now execute the code again, and you will see that there&#8217;s a compile time error!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/home/cchampeau/tmp/securetest.groovy: 6: [Static type checking] - Method call is not allowed!
 @ line 6, column 3.
     c.exit(-1)
     ^

1 error</pre>
</div>
</div>
<div class="paragraph">
<p>So this time, thanks to the type checker, <code>c</code> is really recognized as an instance of class <code>System</code> and we can really disallow the call. This is a very simple example, but it doesn&#8217;t really go as
far as what we can do with the secure AST customizer in terms of configuration. The extension that we wrote has <strong>hardcoded</strong> checks, but it would probably be nicer if we could configure it. So let&#8217;s
start working with a bit more complex example.</p>
</div>
<div class="paragraph">
<p>Imagine that your application computes a score for a document and that you allow the users to customize the score. Then your DSL:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>will expose (at least) a variable named <code>score</code></p>
</li>
<li>
<p>will allow the user to perform mathematical operations (including calling methods like <em>cos</em>, <em>abs</em>, &#8230;)</p>
</li>
<li>
<p>should disallow all other method calls</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An example of user script would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>abs(cos(1+score))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such a DSL is easy to setup. It&#8217;s a variant of the one we defined earlier:</p>
</div>
<div class="listingblock">
<div class="title">Sandbox.java</div>
<div class="content">
<pre class="prettyprint java language-java"><code>CompilerConfiguration conf = new CompilerConfiguration();
ImportCustomizer customizer = new ImportCustomizer();
customizer.addStaticStars("java.lang.Math");                        <i class="conum" data-value="1"></i><b>(1)</b>
conf.addCompilationCustomizers(customizer);
Binding binding = new Binding();
binding.setVariable("score", 2.0d);                                 <i class="conum" data-value="2"></i><b>(2)</b>
GroovyShell shell = new GroovyShell(binding,conf);
Double userScore = (Double) shell.evaluate("abs(cos(1+score))");    <i class="conum" data-value="3"></i><b>(3)</b>
System.out.println("userScore = " + userScore);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>add an import customizer that will add <code>import static java.lang.Math.*</code> to all scripts</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>make the <code>score</code> variable available to the script</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>execute the script</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
There are options to cache the scripts, instead of parsing and compiling them each time. Please check the documentation for more details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So far, our script works, but nothing prevents a hacker from executing malicious code. Since we want to use type checking, I would recommand to use the <code>@CompileStatic</code> transformation
transparently:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it will activate type checking on the script, and we will be able to perform additional checks thanks to the type checking extension</p>
</li>
<li>
<p>it will improve the performance of the script</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Adding <code>@CompileStatic</code> transparently is easy. We just have to update the compiler configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>ASTTransformationCustomizer astcz = new ASTTransformationCustomizer(CompileStatic.class);
conf.addCompilationCustomizers(astcz);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if you try to execute the script again, you will face a compile time error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Script1.groovy: 1: [Static type checking] - The variable [score] is undeclared.
 @ line 1, column 11.
   abs(cos(1+score))
             ^

Script1.groovy: 1: [Static type checking] - Cannot find matching method int#plus(java.lang.Object). Please check if the declared type is right and if the method exists.
 @ line 1, column 9.
   abs(cos(1+score))
           ^

2 errors</pre>
</div>
</div>
<div class="paragraph">
<p>What happened? If you read the script from a "compiler" point of view, it doesn&#8217;t know anything about the "score" variable. <strong>You</strong>, as a developer, know that it&#8217;s a variable
of type <code>double</code>, but the compiler cannot infer it. This is precisely what type checking extensions are designed for: you can provide additional information to the compiler,
so that compilation passes. In this case, we will want to indicate that the <code>score</code> variable is of type <code>double</code>.</p>
</div>
<div class="paragraph">
<p>So we will slightly change the way we transparently add the <code>@CompileStatic</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>ASTTransformationCustomizer astcz = new ASTTransformationCustomizer(
        singletonMap("extensions", singletonList("SecureExtension2.groovy")),
        CompileStatic.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will "emulate" code annotated with <code>@CompileStatic(extensions=['SecureExtension2.groovy'])</code>. Of course now we need to write the extension which will recognize the <code>score</code> variable:</p>
</div>
<div class="listingblock">
<div class="title">SecureExtension2.groovy</div>
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>unresolvedVariable { var -&gt;			<i class="conum" data-value="1"></i><b>(1)</b>
   if (var.name=='score') {			<i class="conum" data-value="2"></i><b>(2)</b>
      return makeDynamic(var, double_TYPE)	<i class="conum" data-value="3"></i><b>(3)</b>
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>in case the type checker cannot resolve a variable</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>if the variable name is <code>score</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>then instruct the compiler to resolve the variable dynamically, and that the type of the variable is <code>double</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can find a complete description of the type checking extension DSL in <a href="http://docs.groovy-lang.org/latest/html/documentation/#">http://docs.groovy-lang.org/latest/html/documentation/#</a><em>type_checking_extensions[this section of the documentation],
but you have here an example of _mixed mode compilation</em> : the compiler is not able to resolve the <code>score</code> variable. You, as the designer of the DSL, <strong>know</strong> that the variable is in fact
found in the binding, and is of the <code>double</code>, so the <code>makeDynamic</code> call is here to tell the compiler: "ok, don&#8217;t worry, I know what I am doing, this variable can be resolved dynamically
and it will be of type <code>double</code>". That&#8217;s it!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_first_completed_secure_extension">First completed "secure" extension</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now it&#8217;s time to put this altogether. We wrote a type checking extension which is capable of preventing calls on <code>System</code> on one side, and we wrote another which is able to resolve the <code>score</code>
variable on another. So if we combine both, we have a first, complete, securing type checking extension:</p>
</div>
<div class="listingblock">
<div class="title">SecureExtension3.groovy</div>
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>// disallow calls on System
onMethodSelection { expr, methodNode -&gt;
    if (methodNode.declaringClass.name=='java.lang.System') {
        addStaticTypeError("Method call is not allowed!", expr)
    }
}

// resolve the score variable
unresolvedVariable { var -&gt;
    if (var.name=='score') {
        return makeDynamic(var, double_TYPE)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t forget to update the configuration in your Java class to use the new type checking extension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>ASTTransformationCustomizer astcz = new ASTTransformationCustomizer(
        singletonMap("extensions", singletonList("SecureExtension3.groovy")),
	CompileStatic.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Execute the code again and it still works. Now, try to do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>abs(cos(1+score))
System.exit(-1)</pre>
</div>
</div>
<div class="paragraph">
<p>And the script compilation will fail with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Script1.groovy: 1: [Static type checking] - Method call is not allowed!
 @ line 1, column 19.
   abs(cos(1+score));System.exit(-1)
                     ^

1 error</pre>
</div>
</div>
<div class="paragraph">
<p>Congratulations, you just wrote your first type checking extension that prevents the execution of malicious code!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_improving_configuration_of_the_extension">Improving configuration of the extension</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So far so good, we are able to prevent calls on <code>System</code>, but it is likely that we are going to discover new vulnerabilities, and that we will want to
prevent execution of such code. So instead of hardcoding everything in the extension, we will try to make our extension generic and configurable. This is
probably the trickiest thing to do, because there&#8217;s no direct way to provide context to a type checking extension. Our idea therefore relies on the (ugly)
thread locals to pass configuration data to the type checker.</p>
</div>
<div class="paragraph">
<p>The first thing we&#8217;re going to do is to make the variable list configurable. Here is the code on the Java side of things:</p>
</div>
<div class="listingblock">
<div class="title">Sandbox.java</div>
<div class="content">
<pre class="prettyprint java language-java"><code>public class Sandbox {
    public static final String VAR_TYPES = "sandboxing.variable.types";

    public static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = new ThreadLocal&lt;&gt;();		<i class="conum" data-value="1"></i><b>(1)</b>

    public static void main(String[] args) {
        CompilerConfiguration conf = new CompilerConfiguration();
        ImportCustomizer customizer = new ImportCustomizer();
        customizer.addStaticStars("java.lang.Math");
        ASTTransformationCustomizer astcz = new ASTTransformationCustomizer(
                singletonMap("extensions", singletonList("SecureExtension4.groovy")),			<i class="conum" data-value="2"></i><b>(2)</b>
                CompileStatic.class);
        conf.addCompilationCustomizers(astcz);
        conf.addCompilationCustomizers(customizer);

        Binding binding = new Binding();
        binding.setVariable("score", 2.0d);
        try {
            Map&lt;String,ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;();			<i class="conum" data-value="3"></i><b>(3)</b>
            variableTypes.put("score", ClassHelper.double_TYPE);					<i class="conum" data-value="4"></i><b>(4)</b>
            Map&lt;String,Object&gt; options = new HashMap&lt;String, Object&gt;();					<i class="conum" data-value="5"></i><b>(5)</b>
            options.put(VAR_TYPES, variableTypes);							<i class="conum" data-value="6"></i><b>(6)</b>
            COMPILE_OPTIONS.set(options);								<i class="conum" data-value="7"></i><b>(7)</b>
            GroovyShell shell = new GroovyShell(binding, conf);
            Double userScore = (Double) shell.evaluate("abs(cos(1+score));System.exit(-1)");
            System.out.println("userScore = " + userScore);
        } finally {
            COMPILE_OPTIONS.remove();									<i class="conum" data-value="8"></i><b>(8)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>create a <code>ThreadLocal</code> that will hold the contextual configuration of the type checking extension</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>update the extension to <code>SecureExtension4.groovy</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>variableTypes</code> is a map variable name &#8594; variable type</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>so this is where we&#8217;re going to add the <code>score</code> variable declaration</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>options</code> is the map that will store our type checking configuration</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>we set the "variable types" value of this configuration map to the map of variable types</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>and assign it to the thread local</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>eventually, to avoid memory leaks, it is important to remove the configuration from the thread local</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And now, here is how the type checking extension can use this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>import static Sandbox.*

def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES]				<i class="conum" data-value="1"></i><b>(1)</b>

unresolvedVariable { var -&gt;
    if (typesOfVariables[var.name]) {						<i class="conum" data-value="2"></i><b>(2)</b>
        return makeDynamic(var, typesOfVariables[var.name])			<i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Retrieve the list of variable types from the thread local</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>if an unresolved variable is found in the map of known variables</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>then declare to the type checker that the variable is of the type found in the map</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Basically, the type checking extension, because it is executed when the type checker verifies the script, can access the
configuration through the thread local. Then, instead of using hard coded names in <code>unresolvedVariable</code>, we can just check
that the variable that the type checker doesn&#8217;t know about is actually declared in the configuration. If it is, then we
can tell it which type it is. Easy!</p>
</div>
<div class="paragraph">
<p>Now we have to find a way to explicitly declare the list of allowed method calls. It is a bit trickier to find a proper
configuration for that, but here is what we came up with.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuring_a_white_list_of_methods">Configuring a white list of methods</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The idea of the whitelist is simple. A method call will be allowed if the method descriptor can be found in the whitelist. This whitelist consists of regular expressions, and
the method descriptor consists of the fully-qualified class name of the method, it&#8217;s name and parameters. For example, for <code>System.exit</code>, the descriptor would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java.lang.System#exit(int)</pre>
</div>
</div>
<div class="paragraph">
<p>So let&#8217;s see how to update the Java integration part to add this configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>public class Sandbox {
    public static final String WHITELIST_PATTERNS = "sandboxing.whitelist.patterns";

    // ...

    public static void main(String[] args) {
        // ...
        try {
            Map&lt;String,ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;();
            variableTypes.put("score", ClassHelper.double_TYPE);
            Map&lt;String,Object&gt; options = new HashMap&lt;String, Object&gt;();
            List&lt;String&gt; patterns = new ArrayList&lt;String&gt;();					<i class="conum" data-value="1"></i><b>(1)</b>
            patterns.add("java\\.lang\\.Math#");						<i class="conum" data-value="2"></i><b>(2)</b>
            options.put(VAR_TYPES, variableTypes);
            options.put(WHITELIST_PATTERNS, patterns);						<i class="conum" data-value="3"></i><b>(3)</b>
            COMPILE_OPTIONS.set(options);
            GroovyShell shell = new GroovyShell(binding, conf);
            Double userScore = (Double) shell.evaluate("abs(cos(1+score));System.exit(-1)");
            System.out.println("userScore = " + userScore);
        } finally {
            COMPILE_OPTIONS.remove();
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>declare a list of patterns</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>add all methods of <code>java.lang.Math</code> as allowed</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>put the whitelist to the type checking options map</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then on the type checking extension side:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>import groovy.transform.CompileStatic
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.ast.MethodNode
import org.codehaus.groovy.ast.Parameter
import org.codehaus.groovy.transform.stc.ExtensionMethodNode

import static Sandbox.*

@CompileStatic
private static String prettyPrint(ClassNode node) {
    node.isArray()?"${prettyPrint(node.componentType)}[]":node.toString(false)
}

@CompileStatic
private static String toMethodDescriptor(MethodNode node) {								<i class="conum" data-value="1"></i><b>(1)</b>
    if (node instanceof ExtensionMethodNode) {
        return toMethodDescriptor(node.extensionMethodNode)
    }
    def sb = new StringBuilder()
    sb.append(node.declaringClass.toString(false))
    sb.append("#")
    sb.append(node.name)
    sb.append('(')
    sb.append(node.parameters.collect { Parameter it -&gt;
        prettyPrint(it.originType)
    }.join(','))
    sb.append(')')
    sb
}
def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES]
def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS]								<i class="conum" data-value="2"></i><b>(2)</b>

onMethodSelection { expr, MethodNode methodNode -&gt;
    def descr = toMethodDescriptor(methodNode)										<i class="conum" data-value="3"></i><b>(3)</b>
    if (!whiteList.any { descr =~ it }) {										<i class="conum" data-value="4"></i><b>(4)</b>
        addStaticTypeError("You tried to call a method which is not allowed, what did you expect?: $descr", expr)	<i class="conum" data-value="5"></i><b>(5)</b>
    }
}

unresolvedVariable { var -&gt;
    if (typesOfVariables[var.name]) {
        return makeDynamic(var, typesOfVariables[var.name])
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>this method will generate a method descriptor from a <code>MethodNode</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>retrieve the whitelist of methods from the thread local option map</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>convert a selected method into a descriptor string</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>if the descriptor doesn&#8217;t match any of the whitelist entries, throw an error</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So if you execute the code again, you will now have a very cool error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Script1.groovy: 1: [Static type checking] - You tried to call a method which is not allowed, what did you expect?: java.lang.System#exit(int)
 @ line 1, column 19.
   abs(cos(1+score));System.exit(-1)
                     ^

1 error</pre>
</div>
</div>
<div class="paragraph">
<p>There we are! We now have a type checking extension which handles both the types of the variables that you export in the binding <strong>and</strong>
a whitelist of allowed methods. This is still not perfect, but we&#8217;re very close to the final solution! It&#8217;s not perfect because we only
took care of method calls here, but you have to deal with more than that. For example, properties (like <code>foo.text</code> which is implicitly
converted into <code>foo.getText()</code>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_putting_it_altogether">Putting it altogether</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dealing with properties is a bit more complicated because the type checker doesn&#8217;t have a handler for "property selection" like it does
for methods. We can work around that, and if you are interested in seeing the resulting code, check it out below. It&#8217;s
a type checking extension which is not written exactly as you have seen in this blog post, because it is meant to be precompiled
for improved performance. But the idea is exactly the same.</p>
</div>
<div class="listingblock">
<div class="title">SandboxingTypeCheckingExtension.groovy</div>
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>import groovy.transform.CompileStatic
import org.codehaus.groovy.ast.ClassCodeVisitorSupport
import org.codehaus.groovy.ast.ClassHelper
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.ast.MethodNode
import org.codehaus.groovy.ast.Parameter
import org.codehaus.groovy.ast.expr.PropertyExpression
import org.codehaus.groovy.control.SourceUnit
import org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys
import org.codehaus.groovy.transform.stc.ExtensionMethodNode
import org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport
import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport

import static Sandbox.*

class SandboxingTypeCheckingExtension extends GroovyTypeCheckingExtensionSupport.TypeCheckingDSL {

    @CompileStatic
    private static String prettyPrint(ClassNode node) {
        node.isArray()?"${prettyPrint(node.componentType)}[]":node.toString(false)
    }

    @CompileStatic
    private static String toMethodDescriptor(MethodNode node) {
        if (node instanceof ExtensionMethodNode) {
            return toMethodDescriptor(node.extensionMethodNode)
        }
        def sb = new StringBuilder()
        sb.append(node.declaringClass.toString(false))
        sb.append("#")
        sb.append(node.name)
        sb.append('(')
        sb.append(node.parameters.collect { Parameter it -&gt;
            prettyPrint(it.originType)
        }.join(','))
        sb.append(')')
        sb
    }

    @Override
    Object run() {

        // Fetch white list of regular expressions of authorized method calls
        def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS]
        def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES]

        onMethodSelection { expr, MethodNode methodNode -&gt;
            def descr = toMethodDescriptor(methodNode)
            if (!whiteList.any { descr =~ it }) {
                addStaticTypeError("You tried to call a method which is not allowed, what did you expect?: $descr", expr)
            }
        }

        unresolvedVariable { var -&gt;
            if (isDynamic(var) &amp;&amp; typesOfVariables[var.name]) {
                storeType(var, typesOfVariables[var.name])
                handled = true
            }
        }

        // handling properties (like foo.text) is harder because the type checking extension
        // does not provide a specific hook for this. Harder, but not impossible!

        afterVisitMethod { methodNode -&gt;
            def visitor = new PropertyExpressionChecker(context.source, whiteList)
            visitor.visitMethod(methodNode)
        }
    }

    private class PropertyExpressionChecker extends ClassCodeVisitorSupport {
        private final SourceUnit unit
        private final List&lt;String&gt; whiteList

        PropertyExpressionChecker(final SourceUnit unit, final List&lt;String&gt; whiteList) {
            this.unit = unit
            this.whiteList = whiteList
        }

        @Override
        protected SourceUnit getSourceUnit() {
            unit
        }

        @Override
        void visitPropertyExpression(final PropertyExpression expression) {
            super.visitPropertyExpression(expression)

            ClassNode owner = expression.objectExpression.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER)
            if (owner) {
                if (expression.spreadSafe &amp;&amp; StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(owner, classNodeFor(Collection))) {
                    owner = typeCheckingVisitor.inferComponentType(owner, ClassHelper.int_TYPE)
                }
                def descr = "${prettyPrint(owner)}#${expression.propertyAsString}"
                if (!whiteList.any { descr =~ it }) {
                    addStaticTypeError("Property is not allowed: $descr", expression)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And a final version of the sandbox that includes assertions to make sure that we catch all cases:</p>
</div>
<div class="listingblock">
<div class="title">Sandbox.java</div>
<div class="content">
<pre class="prettyprint java language-java"><code>public class Sandbox {
    public static final String WHITELIST_PATTERNS = "sandboxing.whitelist.patterns";
    public static final String VAR_TYPES = "sandboxing.variable.types";

    public static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = new ThreadLocal&lt;Map&lt;String, Object&gt;&gt;();

    public static void main(String[] args) {
        CompilerConfiguration conf = new CompilerConfiguration();
        ImportCustomizer customizer = new ImportCustomizer();
        customizer.addStaticStars("java.lang.Math");
        ASTTransformationCustomizer astcz = new ASTTransformationCustomizer(
                singletonMap("extensions", singletonList("SandboxingTypeCheckingExtension.groovy")),
                CompileStatic.class);
        conf.addCompilationCustomizers(astcz);
        conf.addCompilationCustomizers(customizer);

        Binding binding = new Binding();
        binding.setVariable("score", 2.0d);
        try {
            Map&lt;String, ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;();
            variableTypes.put("score", ClassHelper.double_TYPE);
            Map&lt;String, Object&gt; options = new HashMap&lt;String, Object&gt;();
            List&lt;String&gt; patterns = new ArrayList&lt;String&gt;();
            // allow method calls on Math
            patterns.add("java\\.lang\\.Math#");
            // allow constructors calls on File
            patterns.add("File#&lt;init&gt;");
            // because we let the user call each/times/...
            patterns.add("org\\.codehaus\\.groovy\\.runtime\\.DefaultGroovyMethods");
            options.put(VAR_TYPES, variableTypes);
            options.put(WHITELIST_PATTERNS, patterns);
            COMPILE_OPTIONS.set(options);
            GroovyShell shell = new GroovyShell(binding, conf);
            Object result;
            try {
                result = shell.evaluate("Eval.me('1')"); // error
                assert false;
            } catch (MultipleCompilationErrorsException e) {
                System.out.println("Successful sandboxing: "+e.getMessage());
            }
            try {
                result = shell.evaluate("System.exit(-1)"); // error
                assert false;
            } catch (MultipleCompilationErrorsException e) {
                System.out.println("Successful sandboxing: "+e.getMessage());
            }
            try {
                result = shell.evaluate("((Object)Eval).me('1')"); // error
                assert false;
            } catch (MultipleCompilationErrorsException e) {
                System.out.println("Successful sandboxing: "+e.getMessage());
            }

            try {
                result = shell.evaluate("new File('/etc/passwd').getText()"); // getText is not allowed
                assert false;
            } catch (MultipleCompilationErrorsException e) {
                System.out.println("Successful sandboxing: "+e.getMessage());
            }

            try {
                result = shell.evaluate("new File('/etc/passwd').text");  // getText is not allowed
                assert false;
            } catch (MultipleCompilationErrorsException e) {
                System.out.println("Successful sandboxing: "+e.getMessage());
            }

            Double userScore = (Double) shell.evaluate("abs(cos(1+score))");
            System.out.println("userScore = " + userScore);
        } finally {
            COMPILE_OPTIONS.remove();
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This post has explored the interest of using Groovy as a platform for scripting on the JVM. It introduced various mechanisms for integration, and showed that this
comes at the price of security. However, we illustrated some concepts like compilation customizers that make it easier to sandbox the environment of execution of
scripts. The current list of customizers available in the Groovy distribution, and the currently available sandboxing projects in the wild, are not sufficient
to guarantee security of execution of scripts in the general case (dependending, of course, on your users and where the scripts come from).</p>
</div>
<div class="paragraph">
<p>We then illustrated how you could, if you are ready to pay the price of loosing some of the dynamic features of the language, properly workaround those limitations
through type checking extensions. Those type checking extensions are so powerful that you can even introduce your own error messages during the compilation of
scripts. Eventually, by doing this and caching your scripts, you will also benefit from dramatic performance improvements in script execution.</p>
</div>
<div class="paragraph">
<p>Eventually, the sandboxing mechanism that we illustrated is <strong>not</strong> a replacement for the <code>SecureASTCustomizer</code>. We recommand that you actually use <strong>both</strong>, because they
work on different levels: the secure AST customizer will work on the grammar level, allowing you to restrict some language constructs (for example preventing the
creation of closures or classes inside the script), while the type checking extension will work after type inference (allowing you to reason on inferred types
rather than declared types).</p>
</div>
<div class="paragraph">
<p>Last but not least, the solution that I described here is incomplete. It is not available in Groovy core. As I will have less time to work on Groovy, I would be very
glad if someone or some people improve this solution and make a pull request so that we can have something!</p>
</div>
</div>
</div></p>

	<a href="https://twitter.com/share" class="twitter-share-button" data-url="http://melix.github.io/blog/2015/03/sandboxing.html" data-via="CedricChampeau" data-lang="fr">Tweeter</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
	<div class="g-plusone" data-size="medium" data-href="http://melix.github.io/blog/2015/03/sandboxing.html"></div>
	<script type="IN/Share" data-url="http://melix.github.io/blog/2015/03/sandboxing.html" data-counter="right"></script>
	<div class="fb-like" data-href="http://melix.github.io/blog/2015/03/sandboxing.html" data-layout="button_count" data-action="like" data-show-faces="false" data-share="true"></div>

<div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'melixblog';
	var disqus_identifier = 'improved-sandboxing';
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

	<hr>
	
		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
	<p class="muted credit">All posts on this blog are published with a <em>Creative Commons by-nc-sa</em> license.<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/fr/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/2.0/fr/88x31.png"/></a></p>
        <p class="muted credit">&copy; 2013 | Mixed with <a href="http://twitter.github.com/bootstrap/">Bootstrap v3.0.3</a> | Baked with <a href="http://jbake.org">JBake v2.3.0</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/blog/js/jquery-1.9.1.min.js"></script>
    <script src="/blog/js/bootstrap.min.js"></script>
    <script src="/blog/js/run_prettify.js"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    <script type="text/javascript">
    var disqus_shortname = 'melixblog';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
<script type="text/javascript">
  window.___gcfg = {lang: 'fr'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45962373-1', 'melix.github.io');
  ga('send', 'pageview');

</script>
<script src="http://cdn.lanyrd.net/badges/person-v1.min.js"></script>
  </body>
</html>
