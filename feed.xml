<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cédric Champeau's blog</title>
    <link>http://melix.github.io/blog/</link>
    <atom:link href="http://melix.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>ven., 18 juil. 2014 12:47:53 +0200</pubDate>
    <lastBuildDate>ven., 18 juil. 2014 12:47:53 +0200</lastBuildDate>

    <item>
      <title>The new Groovy website</title>
      <link>http://melix.github.io/blog/2014/07/new-groovy-website.html</link>
      <pubDate>ven., 18 juil. 2014 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2014/07/new-groovy-website.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last week, we revealed the beta of a &lt;a href=&quot;http://beta.groovy-lang.org&quot;&gt;brand new website for the Groovy language&lt;/a&gt;. This
new website is &lt;a href=&quot;https://github.com/groovy/groovy-website&quot;&gt;open sourced&lt;/a&gt; and already received a few contributions.
In order to make it even easier and as it a fully statically generated site that makes use of Groovy
I wanted to give more technical details on the toolchain and how it is generated.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_a_static_website&quot;&gt;A static website&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the first questions which arised was: &lt;em&gt;why not use Grails/Spring Boot/Ratpack?&lt;/em&gt; In fact, the
new Groovy website is fully statically generated. It offers multiple advantages:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;hosting is much easier, as it only consists of static pages and assets&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;maintenance is simplified, no database to backup for example&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;everything is self contained, pages and data, into a &lt;a href=&quot;https://github.com/groovy/groovy-website&quot;&gt;single repository&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;no need for authentication&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;all content is public&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last but not least, we didn&amp;#8217;t have any requirement for storing anything in a database, or that would
require dynamic generation. Pull requests are enough so far. Eventually, we&amp;#8217;re thinking about a
blog, but even that can be statically generated even if you want to allow users to comment on articles
(this blog is a perfect example). So in short, this decision was motivated by one mantra:
&lt;em&gt;the right tool for the right job&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The documentation, that you can find on &lt;a href=&quot;http://beta.groovy-lang.org/documentation.html&quot;&gt;this page&lt;/a&gt;, had
already started migrating from the aging wiki to . It is generated independently of the
website and integrated into it using iframes (we&amp;#8217;re thinking about source integration though).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_structure_of_the_project&quot;&gt;Structure of the project&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_generator_and_site&quot;&gt;Generator and site&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/groovy/groovy-website&quot;&gt;project&lt;/a&gt; is built using &lt;a href=&quot;http://www.gradle.org&quot;&gt;Gradle 2&lt;/a&gt; and consists of 2 subprojects:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the &lt;a href=&quot;https://github.com/groovy/groovy-website/tree/master/generator&quot;&gt;generator&lt;/a&gt; project contains, as the name says,
the static generator. It makes use of a &lt;a href=&quot;#template-engine&quot;&gt;template engine&lt;/a&gt; and provides the classes used in the model
of the templates.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the &lt;a href=&quot;https://github.com/groovy/groovy-website/tree/master/site&quot;&gt;site&lt;/a&gt; project contains the templates and data. If you&amp;#8217;re
looking into contributing contents, this is likely the place to look at.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Building and testing the site is easy:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;git clone https://github.com/groovy/groovy-website.git          &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
cd groovy-website
./gradlew generate                                              &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;clones the repository&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;generates the website from templates&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The output will be visible in &lt;code&gt;&amp;lt;project directory&amp;gt;/site/build/site&lt;/code&gt;. There&amp;#8217;s also a &lt;code&gt;checkDeadlinks&lt;/code&gt; tasks that we will
use once we get out of the beta phase to ensure that the generated pages do not contain any dead link.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Internally, we use our &lt;a href=&quot;http://ci.groovy-lang.org/viewType.html?buildTypeId=Groovy_Website&amp;amp;guest=1&quot;&gt;CI server&lt;/a&gt; to deploy
changes to the &lt;code&gt;master&lt;/code&gt; branch live. So any commit which is pushed onto the master branch is automatically published
(in general, takes less than 2 minutes).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_adding_contents&quot;&gt;Adding contents&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Even if the site is statically generated, we still have data. In this project, there&amp;#8217;s an important file, named
&lt;a href=&quot;https://github.com/groovy/groovy-website/blob/master/site/src/site/sitemap.groovy&quot;&gt;sitemap.groovy&lt;/a&gt; which handles a lot
of the contents of the website. It is our &quot;low cost&quot; database and as you can see, it&amp;#8217;s a DSL describing the contents
of the website.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For example, you can see the &lt;code&gt;menu&lt;/code&gt; section which looks like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;menu {
    group(&apos;Groovy&apos;) {
        item &apos;Learn&apos;,                       &apos;learn.html&apos;
        item &apos;Documentation&apos;,               &apos;documentation.html&apos;
        item &apos;Download&apos;,                    &apos;download.html&apos;
        item &apos;Community&apos;,                   &apos;community.html&apos;
        item &apos;Ecosystem&apos;,                   &apos;ecosystem.html&apos;
    }

    group(&apos;About&apos;) {
        item &apos;Contributing&apos;,                &apos;contribute.html&apos;
        item &apos;Source code&apos;,                 &apos;https://github.com/groovy/groovy-core&apos;
        item &apos;Books&apos;,                       &apos;learn.html#books&apos;
        item &apos;Sponsors&apos;,                    &apos;sponsors.html&apos;
        item &apos;FAQ&apos;,                         &apos;faq.html&apos;
        item &apos;Search&apos;,                      &apos;search.html&apos;
    }

    // ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is a purely declarative description of the site menus. Actually, the &quot;Groups&quot; are used in the footer of the page,
while the main &lt;code&gt;Groovy&lt;/code&gt; group is used to generate the top navigation bar. Using a simple descriptive DSL is very interesting,
because it decouples templates from the contents of the menu. We make sure that those templates do not contain any element
which is hardcoded and reduce the risks of forgetting to update the footer, for example, if a section is added.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The same file is used to describe the list of downloads:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;downloads {
    // ...
    distribution(&apos;Groovy 2.3&apos;) {
        description {
            yield &apos;Groovy 2.3 is our latest official &apos;
            a(href: &apos;versioning.html&apos;, &apos;version&apos;)
            yield &apos; of Groovy.&apos;
        }

        version(&apos;2.3.4&apos;) {
            stable true
            releaseNotes &apos;https://jira.codehaus.org/secure/ReleaseNote.jspa?projectId=10242&amp;amp;version=20432&apos;
            windowsInstaller &apos;http://dist.codehaus.org/groovy/distributions/installers/windows/nsis/groovy-2.3.4-installer.exe&apos;
        }
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;or the books which are listed on the &lt;a href=&quot;http://beta.groovy-lang.org/learn.html&quot;&gt;learn page&lt;/a&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;books {
    book(&apos;Groovy in Action, 2nd edition&apos;) {
        authors &quot;Dierk König, Guillaume Laforge, Paul King, Cédric Champeau, Hamlet D&apos;Arcy, Erik Pragt, and Jon Skeet&quot;
        cover &apos;img/books/regina.png&apos;
        url &apos;http://www.manning.com/koenig2/&apos;
        description &apos;The undisputed definitive reference on the Groovy programming language, authored by core members of the development team.&apos;
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The same is done for all contents that need regular updates: user groups, events, projects of the ecosystem, &amp;#8230; I think
this DSL provides a very nice way to add contents to the website without caring about where it has to be done. You can
really think of it as a small database, but making use of a Groovy DSL.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In addition, this file also declares the &lt;a href=&quot;https://github.com/groovy/groovy-website/blob/03e3806cf26af6b13d99e6ee7473687e3f36fedd/site/src/site/sitemap.groovy#L62-L74&quot;&gt;mapping between pages in the documentation section&lt;/a&gt;
and &lt;a href=&quot;http://beta.groovy-lang.org/documentation.html&quot;&gt;the documentation page&lt;/a&gt;. Last but not least, it lists the individual
pages that the website contain. Those pages make use of the &lt;a href=&quot;http://beta.groovy-lang.org/docs/latest/html/documentation/markup-template-engine.html&quot;&gt;markup template engine&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_eat_your_own_dog_food&quot;&gt;Eat your own dog food&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In Groovy 2.3, we introduced a new &lt;a href=&quot;http://beta.groovy-lang.org/docs/latest/html/documentation/markup-template-engine.html&quot;&gt;markup template engine&lt;/a&gt;. We decided that the new web site was an excellent showcase of
this template engine, and a real life use case. This template engine has several remarkable features, like static compilation
of templates (even if the model is dynamic), layouts and of course a human readable builder like syntax:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;html {
   head {
    title &apos;Groovy markup template engine in action!&apos;
   }
   body {
    ul {
        features.each { f-&amp;gt; li(f.name) }
    }
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It has already been integrated into &lt;a href=&quot;https://spring.io/blog/2014/05/28/using-the-innovative-groovy-template-engine-in-spring-boot&quot;&gt;Spring Boot&lt;/a&gt;
and &lt;a href=&quot;http://www.ratpack.io/&quot;&gt;Ratpack&lt;/a&gt; will use it in the next version (to be released on August 1st). A hint about its performance can be found &lt;a href=&quot;https://github.com/ratpack/ratpack/pull/370&quot;&gt;here&lt;/a&gt;.
If you are interested in details about how it works, you can find the documentation &lt;a href=&quot;http://beta.groovy-lang.org/docs/latest/html/documentation/markup-template-engine.html&quot;&gt;here&lt;/a&gt;
and you can read my &lt;a href=&quot;http://melix.github.io/blog/2014/02/markuptemplateengine.html&quot;&gt;blog posts&lt;/a&gt; about it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The website subproject is therefore organized accordingly. Inside the &lt;a href=&quot;https://github.com/groovy/groovy-website/tree/master/site/src/site&quot;&gt;main source tree&lt;/a&gt;, you&amp;#8217;ll find the following directories:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;assets: contains static assets, like Javascript, CSS, images, &amp;#8230;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;html: contains pure HTML files which are easier to embed as is than using a markup syntax&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;includes: contains elements of code which are shared among multiple templates&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;layouts: contains template layouts, as defined in the &lt;a href=&quot;http://beta.groovy-lang.org/docs/latest/html/documentation/markup-template-engine.html#_layouts&quot;&gt;documentation&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pages: contains the main pages of the website&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In general, consider &lt;code&gt;pages&lt;/code&gt; as the entry point. A page generally makes use of one layout. As an example, let&amp;#8217;s see how
the &lt;a href=&quot;http://beta.groovy-lang.org/ecosystem.html&quot;&gt;Ecosystem&lt;/a&gt; page is generated. The source file consists of this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;ecosystem.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;layout &apos;layouts/main.groovy&apos;, true,                                             &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    pageTitle: &apos;The Groovy programming language - Ecosystem&apos;,                   &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    mainContent: contents {                                                     &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
      div(id: &apos;content&apos;, class: &apos;page-1&apos;) {
        section(class: &apos;row&apos;) {
          div(class: &apos;row-fluid&apos;) {
            // ... snip side menu ...
            div(class: &apos;col-lg-8 col-lg-pull-0&apos;) {
              include template: &apos;includes/contribute-button.groovy&apos;             &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
              h1 {
                i(class: &apos;fa fa-leaf&apos;) {}
                yield &apos; Ecosystem&apos;
              }
              p {
                yield &apos;&apos;&apos;
                    Beside the language and its API, Groovy gave birth   ...
                    on various themes such as web frameworks, desktop    ...
                    In this section, we will highlight a few of the most ...
                    which leverage Groovy at their core.
              &apos;&apos;&apos;
              }
              hr(class: &apos;divider&apos;)

              ecosys.eachWithIndex { e, index -&amp;gt;                                &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
                def (name, item) = [e.key, e.value]
                article {
                  a(name: &quot;${name}&quot;) {}
                  div(class:&quot;content-heading clearfix media&quot;) {
                    div {
                      if (item.logo) {
                        img class: &quot;pull-${(index % 2 == 0) ? &apos;left&apos; : &apos;right&apos;}&quot;,
                          src: item.logo, alt: name, hspace: &apos;20px&apos;
                      } else {
                        h2(name)
                      }
                      p(item.description)
                    }
                    a(href: item.url, target:&apos;_blank&apos;, &quot;Learn more...&quot;)
                  }
                }
                hr(class: &apos;divider&apos;)
              }
              // ...
            }
          }
        }
      }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;make use of the &lt;code&gt;main&lt;/code&gt; layout&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;the layout requires a &lt;code&gt;pageTitle&lt;/code&gt; variable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;as well as a &lt;code&gt;mainContent&lt;/code&gt; section corresponding to the main page contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;example of use of an &lt;code&gt;include&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;iterates over the &lt;code&gt;ecosys&lt;/code&gt; variable which contains the list of ecosystem projects as found in the sitemap&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As you can see, this template format has the advantage of taking care of generating markup for you. You won&amp;#8217;t hit your
head again on the wall to find an unclosed tag. Everything is embedded, readable and concise.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_lessons_learnt&quot;&gt;Lessons learnt&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Using the &lt;a href=&quot;http://beta.groovy-lang.org/docs/latest/html/documentation/markup-template-engine.html&quot;&gt;markup template engine&lt;/a&gt; for this project was interesting, because it was probably the first &quot;real life&quot; project
to use it intensively. And as such, we discovered usability issues, but also bugs. Hopefully, none of those bugs or
usability features were critical, and everything could be worked around, but expect some fixes in Groovy 2.3.5. It is
also the reason why the project initially used &lt;a href=&quot;http://www.gradle.org&quot;&gt;Gradle 2&lt;/a&gt;: it comes with Groovy 2.3.2 which embeds the &lt;a href=&quot;http://beta.groovy-lang.org/docs/latest/html/documentation/markup-template-engine.html&quot;&gt;markup template engine&lt;/a&gt;,
so it was possible to use it &lt;strong&gt;without&lt;/strong&gt; organizing the project into separate modules like we have. In fact, the early
versions of the site didn&amp;#8217;t use subprojects. It&amp;#8217;s only when we wanted to leverage improvements from Groovy 2.3.4 that
we had to &lt;a href=&quot;https://github.com/groovy/groovy-website/commit/e922701f747dbb78a7e695796c60d2b783f7e7ee&quot;&gt;switch to that architecture&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_a_team_work&quot;&gt;A team work&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the end, I can&amp;#8217;t finish this blog post without mentionning the team work it implied. In particular:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/oodamien&quot;&gt;Damien Vitrac&lt;/a&gt; designed the website and produced HTML sketches. If you think the new site
looks good, thank this guy!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/glaforge&quot;&gt;Guillaume Laforge&lt;/a&gt; designed the site architecture, wrote contents, tweaked the CSS, that is to
say produced almost all contents. He spent countless hours fixing responsiveness issues and digging into front-end dev.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/CedricChampeau&quot;&gt;I streamlined&lt;/a&gt; the process by setting up the Gradle project, designing the sitemap DSL,
the integration of the &lt;a href=&quot;http://beta.groovy-lang.org/docs/latest/html/documentation/markup-template-engine.html&quot;&gt;markup template engine&lt;/a&gt;, CI integration, &amp;#8230; that is to say pretty much all the &quot;backend&quot; stuff.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;You&lt;/strong&gt;, as a community, provided awesome &lt;a href=&quot;https://github.com/groovy/groovy-website/pulls?direction=desc&amp;amp;page=1&amp;amp;sort=created&amp;amp;state=closed&quot;&gt;pull requests&lt;/a&gt; within hours. Keep them coming, we love it!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Each of us have different skills. Guillaume is far better than I am in any kind of web design, styling issues, etc for example, so in the
end, I think the combination works quite good and that the site as it is now is already pretty usable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let us know what you think, and don&amp;#8217;t forget that you can contribute, it&amp;#8217;s easy!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Contributing for the Groovy language: setting up IntelliJ IDEA</title>
      <link>http://melix.github.io/blog/2014/06/contribute-groovy-ide.html</link>
      <pubDate>mar., 24 juin 2014 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2014/06/contribute-groovy-ide.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Often people ask us how you can setup a development environment to contribute on the Groovy project. If you use IntelliJ IDEA, it&amp;#8217;s actually very easy, so I decided to make a video for it. It&amp;#8217;s my first screencast ever, I think I will try to do more in the future, so please excuse my hesitations and enjoy! You&amp;#8217;ll notice that apparently Google Hangouts dislikes my face, but hopefully, the screensharing stuff worked ;-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Here&amp;#8217;s the video:&lt;/p&gt;
&lt;/div&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;//www.youtube.com/embed/EhJa-Z8XDVw&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Of course, you can ask me if you have issues with the setup, but it should really be straightforward!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Groovy on Android, technical details</title>
      <link>http://melix.github.io/blog/2014/06/grooid2.html</link>
      <pubDate>mar., 10 juin 2014 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2014/06/grooid2.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In my previous &lt;a href=&quot;http://melix.github.io/blog/2014/06/grooid.html&quot;&gt;post&lt;/a&gt;, I have introduced how we could now use the &lt;a href=&quot;http://groovy.codehaus.org&quot;&gt;Groovy language&lt;/a&gt; to develop Android applications. In this post, I will give you more details about how it works internally, giving you more hints about what makes it possible.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_compiling_groovy&quot;&gt;Compiling Groovy&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;http://groovy.codehaus.org&quot;&gt;Groovy language&lt;/a&gt; is a JVM language which compiles to bytecode. Even if it has scripting capabilities, it&amp;#8217;s always compiled. This means that in Groovy, you have two options: either a class is compiled to a &lt;code&gt;.class&lt;/code&gt; file and used like any other class file on the JVM, using the &lt;code&gt;groovyc&lt;/code&gt; compiler instead of &lt;code&gt;javac&lt;/code&gt;, or a class can be compiled &lt;strong&gt;at runtime&lt;/strong&gt;, for example if you rely on scripting. In the last case, the source script (or any Groovy source in general, not necessarily scripts) is available at runtime, and you rely on APIs that Groovy provide to compile those sources and execute them while your application is running. This is typical of scripting languages, but you must be aware that in any case, Groovy is &lt;strong&gt;not&lt;/strong&gt; an interpreted language: everything is turned into bytecode.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_a_classic_android_application&quot;&gt;A classic Android application&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Since the Dalvik VM doesn&amp;#8217;t use the same bytecode as the JVM, Android requires a bit of work in order to compile and execute Java programs. A special tool, called &lt;em&gt;dex&lt;/em&gt;, is responsible for converting the JVM bytecode into Dalvik bytecode, and compile it into a &lt;code&gt;classes.dex&lt;/code&gt; file. This is illustrated in the following schema:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;compilation_process_normal.png&quot; alt=&quot;Classic Android compilation process&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In our case, we&amp;#8217;re using the Gradle build tool, which is now the default for Android projects, so Gradle is responsible for this chain. Java sources are compiled into &lt;code&gt;.class&lt;/code&gt; files, then those classes are processed by the &lt;code&gt;dex&lt;/code&gt; tool, which converts bytecode for all classes and packages everything into a &lt;code&gt;classes.dex&lt;/code&gt; file. Some additional steps can be done (such as calling ProGuard to reduce the size of the package), but in the end, an APK is produced, which is the deliverable application. When deployed on the device, there&amp;#8217;s nothing else to do than loading the classes and executing the application.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s see how the process differs in case of a Groovy application.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_an_application_written_in_groovy&quot;&gt;An application written in Groovy&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this case, we have &lt;code&gt;.groovy&lt;/code&gt; files, corresponding to Groovy sources, but we may also have &lt;code&gt;.java&lt;/code&gt; files. In the end, the process looks very similar:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;compilation_process_groovy.png&quot; alt=&quot;Groovy Android compilation process&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This schema exactly illustrates how the &lt;a href=&quot;https://github.com/melix/gr8confagenda&quot;&gt;GR8Conf Agenda&lt;/a&gt; application is compiled. All is done at &lt;strong&gt;compile time&lt;/strong&gt;, and nothing more at runtime. Groovy sources are compiled into JVM bytecode, which is in turn converted into Dalvik bytecode using &lt;code&gt;dex&lt;/code&gt;. There&amp;#8217;s absolutely no difference with Java, apart from the compiler, which is able to process both Groovy and Java sources!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One noticeable difference that some people have already reported to me is that since we embed the Groovy runtime, the number of method descriptors used in the &lt;code&gt;classes.dex&lt;/code&gt; file is significantly higher than with an application written in pure Java. From my early tests, a Groovy application would consume around 8k methods, without optimizations. The &lt;code&gt;classes.dex&lt;/code&gt; file has a limit of 65536 methods, so this is something you have to keep in mind. Anyway, I am not an Android specialist, but there seem to be workarounds available, like the &lt;code&gt;multi-dex&lt;/code&gt; option.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the end, Groovy is not different from any other library you would embed in your application, it&amp;#8217;s &quot;just&quot; an additional jar. I also mentionned the fact that I recommended to use &lt;code&gt;@CompileStatic&lt;/code&gt; on your classes. There&amp;#8217;s a good reason for that. If you don&amp;#8217;t, the classes that you will compile will use the &lt;strong&gt;dynamic runtime&lt;/strong&gt; of Groovy. This is unlikely what you want on a mobile application, especially because on Android, it would use reflection, implying a major performance drop. On a normal JVM, Groovy would use call site caching techniques, like generation of classes at runtime or invokedynamic to improve performance. This is &lt;strong&gt;not&lt;/strong&gt; possible on Android, so places where you use dynamic features of Groovy should be limited to small parts of the application, called not frequently. A good example would be the use of a builder for the UI. Builders are a very nice feature of Groovy, and for a UI, it would only be called once when the activity is loaded.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Using &lt;code&gt;@CompileStatic&lt;/code&gt;, you will ensure that your classes are &lt;strong&gt;statically compiled&lt;/strong&gt;, meaning that all method calls are resolved at compile time, leading to dramatically improved performance, very close, if not equal, to that of Java (depending on how you write your code, as usual, because idiomatic Groovy might not always be the fastest implementation).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In any case, you must recall that the first application that I wrote does not use a single class generated at runtime. Even if you remove all &lt;code&gt;@CompileStatic&lt;/code&gt; annotations, it would use the dynamic runtime, but &lt;strong&gt;without&lt;/strong&gt; creating classes at runtime.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_runtime_scripting&quot;&gt;Runtime scripting&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the difficulties of adapting the &lt;a href=&quot;http://groovy.codehaus.org&quot;&gt;Groovy language&lt;/a&gt; is that, as we said, Groovy is a highly dynamic language. One of its capabilities is executing scripts at runtime. So what if we wanted to type a Groovy script on the device, and execute it directly on it? Is it possible? In fact, yes, it is possible, given that you follow this process:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;compilation_process_runtime.png&quot; alt=&quot;Groovy Android compilation process at runtime&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can have an application, written in Groovy or not, but in the end, &lt;strong&gt;once the application is running&lt;/strong&gt;, you have Groovy source code that you want to execute. Then it needs to compile the classes, call &lt;code&gt;dex&lt;/code&gt; &lt;strong&gt;directly on the device&lt;/strong&gt;, package the result into a &lt;code&gt;jar&lt;/code&gt; file on the local filesystem, then load it using a special classloader. So why this is possible, the process is very complex, not straightforward, but more importantly, it is dramatically slow.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This process is demonstrated in &lt;a href=&quot;https://github.com/melix/grooidshell-example&quot;&gt;this application&lt;/a&gt;, which replicates the behavior of the well-known &lt;a href=&quot;http://beta.groovy-lang.org/docs/groovy-2.3.2/html/documentation/#integ-groovyshell&quot;&gt;GroovyShell&lt;/a&gt; but directly on an Android device. To give you an idea, on my own device, a Samsung Galaxy Note 3, starting the application, written in Groovy, is blazing fast. Then if you hit the &quot;execute&quot; button, the first time, compilation of the little script will take around 3s.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot; style=&quot;text-align: center&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;groovy-scripting.png&quot; alt=&quot;Compiling Groovy at runtime&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Subsequent compilations take much less time (around ~500ms), but the fact of having to dex files and write them to the filesystem is a performance killer. In anycase, this shows that it is possible, and even that you could rely on it for an application that would handle scripts. It would be possible, for example, to cache the jar files in order to avoid recompiling them&amp;#8230;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this post, I gave further details on how Groovy gets running onto an Android device. In a future post, I will give you more details about how you can get started with your own project. I will maybe give &lt;a href=&quot;https://github.com/pledbrook/lazybones&quot;&gt;Lazybones&lt;/a&gt;, a project bootstraping tool, more love in the next days ;-)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Groovy on Android</title>
      <link>http://melix.github.io/blog/2014/06/grooid.html</link>
      <pubDate>jeu., 5 juin 2014 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2014/06/grooid.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Yesterday ended &lt;a href=&quot;http://gr8conf.eu&quot;&gt;GR8Conf Europe&lt;/a&gt;, a &lt;a href=&quot;http://groovy.codehaus.org&quot;&gt;Groovy language&lt;/a&gt; conference in Copenhagen that was once again a successful event.
I want to thank the crew again for this, and of course the &lt;a href=&quot;http://groovy.codehaus.org&quot;&gt;Groovy language&lt;/a&gt; community which is so friendly and always helpful. This year
turned out to be very special for me, because just two days after the announcement by Apple of the &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/index.html&quot;&gt;Swift language&lt;/a&gt;, I was talking about
running Groovy on Android! As Guillaume Laforge &lt;a href=&quot;http://glaforge.appspot.com/article/apple-s-swift-programming-language-inspired-by-groovy&quot;&gt;noticed&lt;/a&gt;, there
are a lot of similarities between the &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/index.html&quot;&gt;Swift language&lt;/a&gt; and &lt;a href=&quot;http://groovy.codehaus.org&quot;&gt;Groovy language&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The timing is almost perfect, because Android users will want to have a language which is as modern as Swift is, but running on Android. And I see no
better candidate than &lt;a href=&quot;http://groovy.codehaus.org&quot;&gt;Groovy language&lt;/a&gt; here.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_the_presentation&quot;&gt;The presentation&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Should you be interested in the slides, you can find them below. Since it was presented at &lt;a href=&quot;http://gr8conf.eu&quot;&gt;GR8Conf Europe&lt;/a&gt;, it gives a bit of history of the changes needed to
have the runtime working on Android too:&lt;/p&gt;
&lt;/div&gt;
&lt;script async class=&quot;speakerdeck-embed&quot; data-id=&quot;e8e58fc0cdee0131f20616308848c4b8&quot; data-ratio=&quot;1.6&quot; src=&quot;//speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For those of you who are new to Groovy, you have to know that this language is derived from Java, meaning that the learning curve is almost 0, but it also
removes a lot of its verbosity and adds a lot of features to it, such as closures (similar to lambdas in Java 8, but Java 8 is not available for Android
developers), builders, runtime and compile-time metaprogramming.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As an example of how Groovylang can be used to reduce the verbosity of Java on Android, I will take a simple example: asynchronous tasks. Asynchronous tasks
are required as soon as a task takes too much time to be executed on the UI thread. That is the case, by default, for any network based operations, in order
to guarantee that the UI remains snappy even if network is slow or unavailable. The problem is that those asynchronous tasks are incredibly verbose. You have
to write a lot of code, that I would tend to name &quot;inner class hell&quot;, just for this. Let&amp;#8217;s imagine that you need to parse a JSON feed, then update the UI
accordingly. Then you would have to write something like this (no kidding):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public class FeedActivity {
    TextView mTextView;

    ...

    void updateFeed() {
    	new FeedTask().execute(&quot;http://path/to/feed&quot;);
    }

    class FeedTask extends AsyncTask&amp;lt;String, Void, String&amp;gt; {
        protected String doInBackground(String... params) {
            DefaultHttpClient httpclient = new DefaultHttpClient(new BasicHttpParams());
            HttpPost httppost = new HttpPost(params[0]);

            InputStream inputStream = null;
            String result = null;
            try {
                HttpResponse response = httpclient.execute(httppost);
                HttpEntity entity = response.getEntity();

                inputStream = entity.getContent();
                // json is UTF-8 by default
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, &quot;UTF-8&quot;), 8);
                StringBuilder sb = new StringBuilder();

                String line = null;
                while ((line = reader.readLine()) != null) {
                    sb.append(line).append(&quot;\n&quot;);
                }
                result = sb.toString();
            } catch (Exception e) {
                // Oops
            } finally {
                try {
                    if (inputStream != null) {
                        inputStream.close();
                    }
                } catch (Exception squish) {
                }
            }
            StringBuilder speakers = null;
            try {
                JSONObject jObject = new JSONObject(result);
                JSONArray jArray = jObject.getJSONArray(&quot;speakers&quot;);
                speakers = new StringBuilder();
                for (int i = 0; i &amp;lt; jArray.length(); i++) {
                    speakers.append(jArray.getString(i));
                    speakers.append(&quot; &quot;);
                }
            } catch (JSONException e) {
                // do something?
            }
            return speakers.toString();
        }

        @Override
        protected void onPostExecute(String s) {
            mTextView.setText(s);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So now, let&amp;#8217;s see the equivalent in Groovy (no kidding either):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;public class FeedActivity {
    TextView mTextView

    ...

    void updateFeed() {
    	Fluent.async {
            def json = new JsonSlurper().parse([:], new URL(&apos;http://path/to/feed&apos;), &apos;utf-8&apos;)
            json.speakers.join(&apos; &apos;)
        } then {
	    mTextView.setText(it)
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I think you can start to see the advantage of using Groovy in your own Android projects. Of course, the &lt;code&gt;Fluent&lt;/code&gt; class that I&amp;#8217;m using here
is a support class which I implemented in my &lt;a href=&quot;https://github.com/melix/gr8confagenda&quot;&gt;first Android project&lt;/a&gt; (which is open sourced btw), but it&amp;#8217;s
really simple and gives an example of how Android users could benefit from Groovification of their APIs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_feeling_the_pain&quot;&gt;Feeling the pain&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is actually a key point of my talk: I hadn&amp;#8217;t written any Android application before this talk, and I definitely wanted to be able to write
an application in Groovy on Android. Why? Because it&amp;#8217;s been some time already that I use Groovy everyday, and there&amp;#8217;s no turning back. I wanted
to feel the pain of the Java developers on Android, so that I can write better tools for them. And that&amp;#8217;s actually where you, as a user, come
in action: there are so many Groovy libraries out there whose sole objective is to ease the pain, make things that shouldn&amp;#8217;t be complicated a breeze.
This is exactly the point. My example with &lt;code&gt;Fluent&lt;/code&gt; is &lt;strong&gt;one&lt;/strong&gt; example of simplification of usages of Android APIs, but you have many more to invent,
especially because &lt;strong&gt;you&lt;/strong&gt; must have been as annoyed as I did by all those asynchronous tasks, XML files (think of builders!), callback hell, etc&amp;#8230;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_the_beginning_of_a_new_era&quot;&gt;The beginning of a new era&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In upcoming posts, I will try to demonstrate that we&amp;#8217;re just at the beginning. Some people are already asking for a {swift} alternative for Android.
It&amp;#8217;s there guys, you have it, so spread the word and let&amp;#8217;s make it happen! I am convinced that it is the beginning of a new era for Android and Groovy.
Google already switched their main build system to Gradle, which is, by the way, using Groovy, so I think it&amp;#8217;s time to move over and show your love!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All you need to get started is explained in the slide deck above, and you can find the source code of the sample android application on GitHub:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/melix/gr8confagenda&quot;&gt;https://github.com/melix/gr8confagenda&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;em&gt;Update 2: build instructions with the Gradle plugin&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can now use a Gradle plugin to integrate Groovy with Android. The plugin can be found here: &lt;a href=&quot;https://github.com/melix/groovy-android-gradle-plugin&quot;&gt;groovy-android-gradle-plugin&lt;/a&gt;. As of version 0.2, the plugin supports the Android plugin 0.10+.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;em&gt;Update: build instructions&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you want to try it by yourself, here&amp;#8217;s how you can do it. First of all, official support for Android will be in Groovy 2.4. Before the first beta,
you&amp;#8217;ll have to build it from sources, and here is the quickest way:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;git clone https://github.com/melix/groovy-core.git --branch master
cd groovy-core
./gradlew -PskipIndy=true install&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then you can clone the sample application:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;cd ..
git clone https://github.com/melix/gr8confagenda.git&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This contains a project that you can open using &lt;a href=&quot;http://developer.android.com/sdk/installing/studio.html&quot;&gt;Android Studio&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you want to use the &lt;a href=&quot;http://groovy.codehaus.org&quot;&gt;Groovy language&lt;/a&gt; in your own Android project, a requirement is that it is using Gradle. If so, you can update your &lt;code&gt;build.gradle&lt;/code&gt; file
as is:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;android {
   ...
   packagingOptions {
        // workaround for http://stackoverflow.com/questions/20673625/android-gradle-plugin-0-7-0-duplicate-files-during-packaging-of-apk
        exclude &apos;META-INF/LICENSE.txt&apos;
        exclude &apos;META-INF/groovy-release-info.properties&apos;
    }
}

repositories {
    mavenLocal()
    jcenter()
}

dependencies {
    compile &apos;org.codehaus.groovy:groovy:2.4.0-SNAPSHOT:grooid&apos;
    // the following dependency is necessary if you want JSON support
    compile (&apos;org.codehaus.groovy:groovy-json:2.4.0-SNAPSHOT&apos;) {
        transitive = false
    }
}

// add support for Groovy to existing configurations
android.applicationVariants.all {
    task &quot;groovy${name}Compile&quot;(type: GroovyCompile) {
        source = javaCompile.source + fileTree(&apos;src/main/java&apos;).include(&apos;**/*.groovy&apos;)
        destinationDir = javaCompile.destinationDir
        classpath = javaCompile.classpath
        groovyClasspath = classpath
        sourceCompatibility = &apos;1.6&apos;
        targetCompatibility = &apos;1.6&apos;
        doFirst {
            def runtimeJars = plugins.findPlugin(com.android.build.gradle.AppPlugin).runtimeJars
            classpath = files(runtimeJars) + classpath
        }
    }
    javaCompile.dependsOn(&quot;groovy${name}Compile&quot;)
    javaCompile.enabled = false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And that&amp;#8217;s all! Now, one option for you is to write support libraries and make them available to the community. Enjoy!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>A fast markup template engine for Groovy (part 2 of 2)</title>
      <link>http://melix.github.io/blog/2014/02/markuptemplateengine_part2.html</link>
      <pubDate>mar., 18 févr. 2014 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2014/02/markuptemplateengine_part2.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this post, I will discuss the implementations details for the markup template engine I have described in a &lt;a href=&quot;/blog/2014/02/markuptemplateengine.html&quot;&gt;previous post&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_compiling_templates&quot;&gt;Compiling templates&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_the_markuptemplateengine_class&quot;&gt;The MarkupTemplateEngine class&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Even if my first implementation of the markup template engine was relying on &lt;code&gt;StreamingMarkupBuilder&lt;/code&gt;, the technique used to compile templates into bytecode is actually the same after all optimizations. It relies on:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a &lt;a href=&quot;http://groovy.codehaus.org/api/groovy/lang/GroovyClassLoader.html&quot;&gt;GroovyClassLoader&lt;/a&gt; to create and cache template classes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a &lt;a href=&quot;http://groovy.codehaus.org/api/org/codehaus/groovy/control/CompilerConfiguration.html&quot;&gt;CompilerConfiguration&lt;/a&gt; to customize compilation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The various template engines that Groovy provide extend the &lt;a href=&quot;http://groovy.codehaus.org/api/groovy/text/TemplateEngine.html&quot;&gt;TemplateEngine&lt;/a&gt; class. All template engines must implement the &lt;code&gt;createTemplate&lt;/code&gt; method which returns an instance of &lt;a href=&quot;http://groovy.codehaus.org/api/groovy/text/Template.html&quot;&gt;Template&lt;/a&gt;. My first idea, here, was therefore to have a template engine which holds a &lt;code&gt;GroovyClassLoader&lt;/code&gt;, and compiles scripts as &lt;code&gt;Template&lt;/code&gt; instances. For thread safety reasons and to avoid compiling the same template again and again, I instead chose a slightly different approach, which is to compile the scripts, and cache the resulting class into a field of the &lt;code&gt;StreamingMarkupBuilderTemplate&lt;/code&gt; class:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    private class StreamingMarkupBuilderTemplate implements Template {
        final Class&amp;lt;BaseTemplate&amp;gt; templateClass;							&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;

        public StreamingMarkupBuilderTemplate(final Reader reader) {
            templateClass = groovyClassLoader.parseClass(
		new GroovyCodeSource(reader, &quot;GeneratedMarkupTemplate&quot; + counter.getAndIncrement(), &quot;&quot;));
        }

        public StreamingMarkupBuilderTemplate(final URL resource) throws IOException {
            templateClass = groovyClassLoader.parseClass(new GroovyCodeSource(resource));
        }

        public Writable make() {
            return make(Collections.emptyMap());							&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
        }

        public Writable make(final Map binding) {
            return DefaultGroovyMethods.newInstance(templateClass,
		new Object[]{MarkupTemplateEngine.this, binding, templateConfiguration});		&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
        }
    }&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;templateClass&lt;/code&gt; corresponds to the user script, compiled as a template class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;make&lt;/code&gt; binds a model to the template&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;make&lt;/code&gt; instantiates a new template and binds the model to it&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;bind&lt;/code&gt; method is very important. It returns a &lt;code&gt;Writable&lt;/code&gt; which will trigger template rendering when &lt;code&gt;writeTo&lt;/code&gt; is called. Therefore, nothing is rendered until the &lt;code&gt;Writable#writeTo&lt;/code&gt; method is called. The only thing that &lt;code&gt;bind&lt;/code&gt; does is instantiating a new template. As we are using a cached class, there&amp;#8217;s no compilation involved anymore, so the template is compiled once for all.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_the_basetemplate_class&quot;&gt;The BaseTemplate class&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As you can see, the user script is compiled into a class which extends &lt;code&gt;BaseTemplate&lt;/code&gt;. This means that the following script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;page.tpl&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;html {
   body {
      p(&quot;I&apos;m a template&quot;)
   }
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;compiles to a class extending &lt;code&gt;BaseTemplate&lt;/code&gt;. If you are familiar with &lt;code&gt;GroovyClassLoader&lt;/code&gt; or &lt;code&gt;GroovyShell&lt;/code&gt;, you should actually know that normally, a script compiles to a class extending &lt;a href=&quot;http://groovy.codehaus.org/api/groovy/lang/Script.html&quot;&gt;Script&lt;/a&gt;. In our case, we don&amp;#8217;t want to extend &lt;code&gt;Script&lt;/code&gt;, because it does things that we don&amp;#8217;t want, such as overriding &lt;code&gt;getProperty&lt;/code&gt; or using a &lt;code&gt;Binding&lt;/code&gt; class, or even having the semantics of a Groovy script. Furthermore, it doesn&amp;#8217;t allow us to have a custom constructor to have private final fields. So the first step of our compilation process is actually to change the super class of the compiled script. The next step is to create a constructor that takes our model and the template configuration as parameters, as seen in the &lt;code&gt;make&lt;/code&gt; method. Last but not least, since the script being compiled defines a &lt;code&gt;run&lt;/code&gt; method (which is abstract in &lt;code&gt;Script&lt;/code&gt;) corresponding to the script body, we will perform additional code transformations on this specific method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;@Override
    public void call(final SourceUnit source, final GeneratorContext context, final ClassNode classNode) throws CompilationFailedException {
        if (classNode.isScriptBody()) {							&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
            classNode.setSuperClass(MarkupTemplateEngine.BASETEMPLATE_CLASSNODE);	&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
            createConstructor(classNode);						&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
            transformRunMethod(classNode, source);					&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;a Groovy script may contain multiple class, so we need to check if the current class is actually the script body&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;we change the super class from &lt;code&gt;Script&lt;/code&gt; to &lt;code&gt;BaseTemplate&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;we create a new constructor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;we perform code modifications on the script body&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_implementing_the_builder&quot;&gt;Implementing the builder&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;transformRunMethod&lt;/code&gt; method is actually an example of how to implement a Groovy DSL using AST transformations. The goal of this method is to alter the AST (abstract syntax tree), so that some method calls in source code, for example, are actually rewritten. It is also the starting point of performance optimizations. This is actually very important. For example, one of the transformations will change:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;p(text)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;into:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;p(getModel().get(&quot;text&quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Technically speaking, there is no need to do such a change: we could rely on &lt;code&gt;BaseTemplate&lt;/code&gt; implementing &lt;code&gt;propertyMissing&lt;/code&gt; to resolve missing variables (here, &lt;code&gt;text&lt;/code&gt;) and delegate the call to its internal &lt;code&gt;model&lt;/code&gt; field. However, this can be particularily slow, especially in builders where there are lots of nested closures, which involve a very long call chain. By doing this change, we transform a so-called &lt;code&gt;DynamicVariable&lt;/code&gt; (&lt;code&gt;text&lt;/code&gt;) into something that can be resolved statically (&lt;code&gt;getModel&lt;/code&gt; is declared in &lt;code&gt;BaseTemplate&lt;/code&gt; and is of type &lt;code&gt;Map&lt;/code&gt;). Slowly, we&amp;#8217;re making a switch towards &lt;strong&gt;statically compilable&lt;/strong&gt; code&amp;#8230; but we&amp;#8217;re not there yet.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In classic builder code, compiling this would work and eventually, when the &lt;code&gt;p&lt;/code&gt; method is called, the meta-object protocol goes into action and eventually calls the &lt;code&gt;methodMissing&lt;/code&gt; method on the &lt;code&gt;BaseTemplate&lt;/code&gt; class if it is defined. So to make our code work, all we have to do is to write that method:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;BaseTemplate.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;    public Object methodMissing(String tagName, Object args) throws IOException {
        Object o = model.get(tagName);
        if (args instanceof Object[]) {
            final Writer wrt = out;
            TagData tagData = new TagData(args).invoke();
            Object body = tagData.getBody();
            writeIndent();
            wrt.write(&apos;&amp;lt;&apos;);
            wrt.write(tagName);
            writeAttributes(tagData.getAttributes());
            if (body != null) {
                wrt.write(&apos;&amp;gt;&apos;);
                writeBody(body);
                writeIndent();
                wrt.write(&quot;&amp;lt;/&quot;);
                wrt.write(tagName);
                wrt.write(&apos;&amp;gt;&apos;);
            } else {
                if (configuration.isExpandEmptyElements()) {
                    wrt.write(&quot;&amp;gt;&amp;lt;/&quot;);
                    wrt.write(tagName);
                    wrt.write(&apos;&amp;gt;&apos;);
                } else {
                    wrt.write(&quot;/&amp;gt;&quot;);
                }
            }
        }
        return this;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We can test that this code works by rendering a simple template:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.text.markup.MarkupTemplateEngine
import groovy.text.markup.TemplateConfiguration

def tplConf = new TemplateConfiguration()
MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, tplConf)

def mkpTemplate = engine.createTemplate &apos;&apos;&apos;
html {
    body {
	p(text)
    }
}
&apos;&apos;&apos;
def model = [text:&apos;It works!&apos;]
mkpTemplate.make(model).writeTo(new PrintWriter(System.out))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What is nice is that we can also rely on the template configuration to perform different transformations. For example, there&amp;#8217;s an optional &lt;code&gt;autoEscape&lt;/code&gt; flag which tells if variables read from the model should be automatically escaped. If the flag is set to false, the following code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;text&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;is transformed into:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;getModel().get(&quot;text&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;but if the flag is set to true, the generated code is:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;yield(getModel().get(&quot;text&quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;where &lt;code&gt;yield&lt;/code&gt; is the method which will escape contents&amp;#8230; So it&amp;#8217;s a very flexible way to perform parametrized transformations of templates! The same technique is used to:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;transform &lt;code&gt;include (template|escaped|unescaped):&apos;path/to/template&apos;&lt;/code&gt; into `include(Groovy|Escaped|Unescaped)(&lt;em&gt;/path/to/template&lt;/em&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;transform &lt;code&gt;unescaped.foo&lt;/code&gt; into &lt;code&gt;getModel().get(&quot;foo&quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;transform &lt;code&gt;&apos;:XXX&apos;()&lt;/code&gt; method calls into &lt;code&gt;methodMissing(&apos;XXX&apos;, ...)&lt;/code&gt;. This gives a way to render tags which have the same name as helper methods like &lt;code&gt;yield&lt;/code&gt;. In that case, the user can write &lt;code&gt;&apos;:yield&apos;()&lt;/code&gt; to create a tag &lt;code&gt;&amp;lt;yield&amp;gt;&lt;/code&gt; instead of calling the &lt;code&gt;yield&lt;/code&gt; method for example.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_statically_compiling_templates&quot;&gt;Statically compiling templates&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_oops_i_did_it_again&quot;&gt;Oops, I did it again!&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Going further towards statically compilable code requires additional trickery. In the previous example, we still have a call (&lt;code&gt;p(...)&lt;/code&gt;) which is &lt;em&gt;unresolved&lt;/em&gt;, goes through the MOP and eventually calls &lt;code&gt;methodMissing&lt;/code&gt;. The same way we converted the &lt;code&gt;text&lt;/code&gt; variable into a dynamic call, we can make it statically compilable. Since the method which would eventually be called would be &lt;code&gt;methodMissing&lt;/code&gt;, instead of going through the MOP, since we know that this particular method will always be called in our case, we can directly make the change, and hardwire it. The resulting code would look like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;methodMissing(&quot;p&quot;, new Object[]{getModel().get(&quot;text&quot;)})&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This change can be made in our transformer, like we did the &lt;code&gt;getModel&lt;/code&gt; change. However, we will see that we have a serious problem with that. Meanwhile, let&amp;#8217;s show how we can trigger static compilation of templates. This can be done easily by injecting the &lt;code&gt;@CompileStatic&lt;/code&gt; annotation through &lt;code&gt;CompilerConfiguration&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;compilerConfiguration.addCompilationCustomizers(new TemplateASTTransformer(tplConfig)); 		&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
compilerConfiguration.addCompilationCustomizers(
                new ASTTransformationCustomizer(CompileStatic.class));					&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;apply the AST transformations to rewrite unresolved variables and method missing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;apply &lt;code&gt;@CompileStatic&lt;/code&gt; to the template&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We can try the template engine using the same code as before:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.text.markup.MarkupTemplateEngine
import groovy.text.markup.TemplateConfiguration

def tplConf = new TemplateConfiguration()
MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, tplConf)

def mkpTemplate = engine.createTemplate &apos;&apos;&apos;
html {
    body {
    p(text)
    }
}
&apos;&apos;&apos;
def model = [text:&apos;It works!&apos;]
mkpTemplate.make(model).writeTo(new PrintWriter(System.out))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And it works! So what is the problem? Actually, there are multiple issues. The first one is that you can&amp;#8217;t call existing methods anymore! For example, we can&amp;#8217;t call the &lt;code&gt;yield&lt;/code&gt; method because it has been converted too:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;yield &apos;Some text&apos;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;gets converted into:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;methodMissing(&quot;yield&quot;, new Object[] {&quot;Some &amp;lt;text to escape&amp;gt;&quot;})&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and eventually generates this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint xml language-xml&quot;&gt;&lt;code&gt;&amp;lt;yield&amp;gt;Some &amp;lt;text to escape&amp;gt;&amp;lt;/yield&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Is it the end of the story? Can&amp;#8217;t we really statically compile our templates and make them super fast? Well, no, of course!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is where all the magic begins. Solving this problem requires being able to make a difference between calls to methods which &lt;strong&gt;exist&lt;/strong&gt; (like &lt;code&gt;yield&lt;/code&gt;) and calls to methods which are not defined (like &lt;code&gt;html&lt;/code&gt;). And guess what, Groovy has a very nice tool whose responsability is &lt;strong&gt;exactly&lt;/strong&gt; this: static type checking and by extension, static compilation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So let&amp;#8217;s start by removing the code which transforms the method calls into &lt;code&gt;methodMissing&lt;/code&gt; calls, and try to compile the following template:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.text.markup.MarkupTemplateEngine
import groovy.text.markup.TemplateConfiguration

def tplConf = new TemplateConfiguration()
MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, tplConf)

def mkpTemplate = engine.createTemplate &apos;&apos;&apos;
html {
    body {
        yield text
    }
}
&apos;&apos;&apos;
def model = [text:&apos;Text &amp;lt;to be escaped&amp;gt;&apos;]
mkpTemplate.make(model).writeTo(new PrintWriter(System.out))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Since we kept static compilation, it will fail, but it will give us interesting information:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;[Static type checking] - Cannot find matching method GeneratedMarkupTemplate6#html(groovy.lang.Closure). Please check if the declared type is right and if the method exists.
 at line: 2, column: 1

[Static type checking] - Cannot find matching method GeneratedMarkupTemplate6#body(groovy.lang.Closure). Please check if the declared type is right and if the method exists.
 at line: 3, column: 5&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What we see is that the two errors are precisely the methods that we want to directly wire to &lt;code&gt;methodMissing&lt;/code&gt;. The &lt;code&gt;yield&lt;/code&gt; method has been recognized, so the type checker did the job for us. It is telling us: &quot;ok guys, there are two method calls I know nothing about. Those are &lt;code&gt;html&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;. Please do something or I can&amp;#8217;t compile it.&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That&amp;#8217;s nice, but how can I help the compiler?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_type_checking_extensions&quot;&gt;Type checking extensions&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Well, this is precisely why type checking extensions were added in Groovy 2.1. They allow the programmer to help the compiler when he knows about a method call that the type checker isn&amp;#8217;t able to resolve. You can give hints and tell &quot;ok, this method exists, and it returns an object of type Foo&quot;. In Groovy 2.2, this mechanism was extended to static compilation, which opens another chapter in the incredible extensibility that Groovy has to offer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Writing type checking extensions require a bit of knowledge of the Groovy AST (abstract syntax tree), so anyone who ever wrote an AST transformation in Groovy should be capable of writing a type checking extension. Actually, it is even easier, and the process is described &lt;a href=&quot;http://docs.codehaus.org/display/GROOVY/Type+checking+extensions&quot;&gt;here&lt;/a&gt;. In our case, we will start leveraging a feature of Groovy 2.2 will allows us to mix dynamic code with statically compiled code. That is to say that the only thing that our extension is going to do is saying &quot;when you don&amp;#8217;t know what a method call does, perform a dynamic invocation&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When we added this to Groovy 2.2, we really didn&amp;#8217;t want to make &quot;mixed&quot; mode a first class citizen in static compilation, because it defeats the idea of catching typos, which is one of the things people expect most from a type checking system. So this &quot;mixed&quot; mode is actually activated by type checking extensions. This means that the only method calls which will be made dynamic will be those that the programmer knows about, and really wants to convert to dynamic calls. It is an important difference, because we want the developper to be &lt;strong&gt;aware&lt;/strong&gt; of what he is doing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That said, how can we implement that? It&amp;#8217;s actually pretty easy. The first thing to do is to write the code which will help the compiler:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;methodNotFound { receiver, name, argList, argTypes, call -&amp;gt;	&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    if (call.lineNumber &amp;gt; 0) {					&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
        if (call.implicitThis) {				&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
            return makeDynamic(call, OBJECT_TYPE)		&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;react to the &lt;code&gt;methodNotFound&lt;/code&gt; event, thrown by the type checker&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;make sure the event is called on user code, that is to say code for which there&amp;#8217;s an associated line number&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;make sure that only calls which are on an &quot;implicit this&quot; are made dynamic (see below)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;instruct the compiler to perform a dynamic call here&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Point 3 is actually important. We said that we wanted the developper to be aware of which calls he want to make dynamic. This is the kind of guards that you might want to add. In builder-style code, only method calls for which there&amp;#8217;s no explicit receiver should be considered as method creating tags. For example, if you write &lt;code&gt;this.foo&lt;/code&gt;, there is an &lt;strong&gt;explicit&lt;/strong&gt; &lt;code&gt;this&lt;/code&gt; receiver, and we don&amp;#8217;t want to convert that call. Instead, we want to let the compiler report an error.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now that the extension is written, we still have to load it. There are two ways of loading type checking extensions: using scripts (Groovy 2.1) or precompiled type checking extensions (Groovy 2.2+). In my case, I wanted to use precompiled type checking extensions, to avoid paying the cost of compiling the type checking extension at runtime. This can be done by wrapping the extension script into a class extending &lt;code&gt;GroovyTypeCheckingExtensionSupport.TypeCheckingDSL&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;class MarkupTemplateTypeCheckingExtension extends GroovyTypeCheckingExtensionSupport.TypeCheckingDSL {

    @Override
    Object run() {
	methodNotFound { receiver, name, argList, argTypes, call -&amp;gt;
		...
	}
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then the extension can be loaded by slightly changing the way we activate &lt;code&gt;@CompileStatic&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;compilerConfiguration.addCompilationCustomizers(
        new ASTTransformationCustomizer(
            Collections.singletonMap(&quot;extensions&quot;,&quot;groovy.text.markup.MarkupTemplateTypeCheckingExtension&quot;), &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
            CompileStatic.class));									     &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;create the map of arguments for the &lt;code&gt;@CompileStatic&lt;/code&gt; AST transformation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;apply &lt;code&gt;@CompileStatic&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_improving_performance&quot;&gt;Improving performance&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;With the type checking extension, we&amp;#8217;ve now instructed the compiler to perform &lt;strong&gt;dynamic&lt;/strong&gt; calls when it finds tag methods. All other calls, which were resolved statically, are made static. This is nice, but we are still paying the price of the meta-object protocol here, and there&amp;#8217;s no reason to go through a dynamic path were we want the target method to be &lt;code&gt;methodMissing&lt;/code&gt; in any case. So, how can we solve that?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock warning&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;icon-warning&quot; title=&quot;Warning&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
Before going further, you have to be warned. What I am going to show you is things that I wouldn&amp;#8217;t recommand for beginners in AST transformations. We&amp;#8217;re going to update the AST &lt;strong&gt;just before it is going to generate bytecode&lt;/strong&gt;. This is very late in the compilation process, meaning that you are walking along a thin rope without net! Traditional AST transformations run much earlier in the compilation process, and the compiler will do a lot of things for you (like resolving methods, variables, &amp;#8230;). Here, it is so late that all those things have already been done, so you have to do it all yourself!
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now let the fun begin! The idea is quite simple actually. Instead of relying on &lt;code&gt;makeDynamic&lt;/code&gt;, we will transform the calls into direct calls to &lt;code&gt;methodMissing&lt;/code&gt;. The type checking extension API doesn&amp;#8217;t let you do this (it&amp;#8217;s not meant to transform the AST), so you have to do it yourself. This involves multiple steps:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;when we start visiting a method, create an empty list of method calls that will need to be transformed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;when an unresolved call is found and that it matches our criteria, put that call into the list&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;after the method has been visited, trigger a transformer which will transform all calls in the list&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The first step requires an extra block:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;beforeVisitMethod {		&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
   newScope {			&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      builderCalls = []		&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;we&amp;#8217;re entering a new method body&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;newScope&lt;/code&gt; pushes a &quot;type checking scope&quot; on stack, where you can put user data&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;add the &lt;code&gt;builderCalls&lt;/code&gt; method to this scope&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then you can add the method calls to be transformed this way:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;methodNotFound { receiver, name, argList, argTypes, call -&amp;gt;
    if (call.lineNumber &amp;gt; 0) {
        if (call.implicitThis) {
            currentScope.builderCalls &amp;lt;&amp;lt; call
            return makeDynamic(call, OBJECT_TYPE)
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And triggering the AST transformation can be done in an &lt;code&gt;afterVisitMethod&lt;/code&gt; block:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;afterVisitMethod { mn -&amp;gt;							&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
   scopeExit {									&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      new BuilderMethodReplacer(context.source, builderCalls).visitMethod(mn)	&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;when we exit a method body&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;pop the current scope from stack&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;trigger an AST transformation which will visit this method knowing which calls need to be transformed&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Of course, we still miss the transformation code. For that, we need a class which extends &lt;a href=&quot;http://groovy.codehaus.org/api/org/codehaus/groovy/ast/ClassCodeExpressionTransformer.html&quot;&gt;ClassCodeExpressionTransformer&lt;/a&gt; :&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;    private static class BuilderMethodReplacer extends ClassCodeExpressionTransformer {

        private static final MethodNode METHOD_MISSING = ClassHelper.make(BaseTemplate).getMethods(&apos;methodMissing&apos;)[0]		&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;

        private final SourceUnit unit;
        private final Set&amp;lt;MethodCallExpression&amp;gt; callsToBeReplaced;

        BuilderMethodReplacer(SourceUnit unit, Collection&amp;lt;MethodCallExpression&amp;gt; calls) {
            this.unit = unit
            this.callsToBeReplaced = calls as Set;
        }

        @Override
        protected SourceUnit getSourceUnit() {
            unit
        }

        @Override
        void visitClosureExpression(final ClosureExpression expression) {
            super.visitClosureExpression(expression)
        }

        @Override
        public Expression transform(final Expression exp) {
            if (callsToBeReplaced.contains(exp)) {									&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
                def args = exp.arguments instanceof TupleExpression ? exp.arguments.expressions : [exp.arguments]
                args*.visit(this)
                // replace with direct call to methodMissing
                def call = new MethodCallExpression(									&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
                        new VariableExpression(&quot;this&quot;),
                        &quot;methodMissing&quot;,
                        new ArgumentListExpression(
                                new ConstantExpression(exp.getMethodAsString()),
                                new ArrayExpression(
                                        OBJECT_TYPE,
                                        [* args]
                                )
                        )
                )
                call.implicitThis = true
                call.safe = exp.safe
                call.spreadSafe = exp.spreadSafe
                call.methodTarget = METHOD_MISSING									&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
                call													&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
            } else if (exp instanceof ClosureExpression) {
                exp.code.visit(this)
                super.transform(exp)
            } else {
                super.transform(exp)
            }
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;find the method which will eventually be called, &lt;code&gt;methodMissing&lt;/code&gt; and keep a handle on it&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;when an expression is visited, we check if it is a method call which should be replaced&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;create a new method call&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;link the call to its target method (very important if you don&amp;#8217;t want to crash the compiler!)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;return the new method call&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And we&amp;#8217;re done! Of course, I didn&amp;#8217;t say it was trivial nor easy, yet, it is possible, and now, all methods supposed to create a tag are directly wired to &lt;code&gt;methodMissing&lt;/code&gt;, meaning that they are now statically compiled!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_more_things_to_fix&quot;&gt;More things to fix&amp;#8230;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You may think that all problems are solved, but in fact, there are still issues with this code. Imagine the following template:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;p(text.toUpperCase())&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you compile it, it will fail with:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;Cannot find matching method java.lang.Object#toUpperCase(). Please check if the declared type is right and if the method exists.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The reason is that we compile the template statically. While we instructed the compiler that &lt;code&gt;text&lt;/code&gt; is in fact &lt;code&gt;getModel().get(&quot;text&quot;)&lt;/code&gt;, it is still unable to know what is the return type of this call. Then, it assumes that it returns an &lt;code&gt;Object&lt;/code&gt;, and if you try to call &lt;code&gt;toUpperCase&lt;/code&gt; on an &lt;code&gt;Object&lt;/code&gt;, the method doesn&amp;#8217;t exist&amp;#8230; This can easily be solved, by making all unresolved method calls dynamic. This means that the template compilation will never throw such errors anymore, but it will instead make a dynamic call. Problem solved.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Well, almost.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What if I do this?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;p(((String)text).toUpperCase())&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then, by adding a cast, the static compiler is able to resolve the method call. Instead of doing a dynamic call, like it would with our extension, it will perform a direct method call, which will be faster! This means that if you add types, by casting, to your template, rendering can be made faster.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is an interesting idea, but it is not really user friendly. So the last thing I added to the type checking extension is actually an optional, &quot;type checked&quot; mode. If this mode is activated, then the programmer is supposed to tell which are the types of the elements found into the binding. Here, the developper would have to declare that &lt;code&gt;text&lt;/code&gt; is of type String:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.text.markup.MarkupTemplateEngine
import groovy.text.markup.TemplateConfiguration

def tplConf = new TemplateConfiguration()
MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, tplConf)

def mkpTemplate = engine.createTypeCheckedModelTemplate &apos;&apos;&apos;				&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
p {
   yield text.toUpperCase()								&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
}
&apos;&apos;&apos;, [text:&apos;String&apos;]
def model = [text:&apos;Text &amp;lt;to be escaped&amp;gt;&apos;]						&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
mkpTemplate.make(model).writeTo(new PrintWriter(System.out))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;use &lt;code&gt;createTypeCheckedModelTemplate&lt;/code&gt; instead of &lt;code&gt;createTemplate&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;you can use &lt;code&gt;text.toUpperCase()&lt;/code&gt; without an explicit cast&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;because the model was declared using a simple map&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This mode is actually very interesting if you want to report template errors at &lt;em&gt;template compilation&lt;/em&gt; time. Instead of having an error when the template is rendered, the error will occur at compile time. So, for example, if we change the model declaration from:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;[text:&apos;String&apos;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;[text:&apos;Integer&apos;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;template compilation will now fail with:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;[Static type checking] - Cannot find matching method java.lang.Integer#toUpperCase(). Please check if the declared type is right and if the method exists.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What is really interesting is that you can declare &quot;complex&quot; models, like:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;[persons:&apos;List&amp;lt;Person&amp;gt;&apos;, posts:[List&amp;lt;Post&amp;gt;]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and have the template statically compiled! The implementation details of that mode are a bit complex, but you can take a look at the &lt;a href=&quot;https://github.com/melix/groovy-core/commit/30096837f8494d64d249a3341efca7ea66bb816f&quot;&gt;commit&lt;/a&gt; if you want to have some hint (don&amp;#8217;t hesitate to ask me if you want me to explain how it works).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_and_more_features&quot;&gt;And more features!&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last but not least, the template engine implements automatic indent and automatic new lines. The first one is quite easy to implement, as it only requires wrapping the supplied &lt;code&gt;Writer&lt;/code&gt; into an &lt;code&gt;IndentWriter&lt;/code&gt;. But adding automatic new lines is a bit trickier, because we want to rely on the layout of the source code to actually add behavior! Let me explain that again with examples. If you have:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;div {
  p(&apos;text&apos;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;we want to render:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint html language-html&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Text&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;But if we have:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;div {  p(&apos;text&apos;) }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We want to render:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint html language-html&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;Text&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The problem is that our templates are actually Groovy code&amp;#8230; And new lines are not significant. They are not even visible in the AST, so how can we implement such a feature?! The answer relies in each AST node&amp;#8230; They all carry line and column number information. So, by comparing, in a &lt;code&gt;ClosureExpression&lt;/code&gt;, the line number of the closure itself with the line number of its first code statement, we can determine if there was a new line in source code! The same way, we can check if the last line number of the closure is greater than the line number of the last statement, and if so, introduce a new line&amp;#8230; So, in the first example, the code is actually transformed into:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;div {
  newLine()
  p(&apos;text&apos;)
  newLine()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And that&amp;#8217;s it!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this (long) blog post, I have demonstrated various techniques that allowed me to transform a slow, dynamic builder based template engine into a fast, statically compiled, template engine with optional user model type checking and unique features like automatic new line insertions. It goes far beyond what the &lt;code&gt;StreamingMarkupBuilder&lt;/code&gt; has to offer and demonstrates that compile time metaprogramming can be used in Groovy to provide advanced features. Of course, no one would expect you to create such code from the beginning. If you &lt;a href=&quot;https://github.com/melix/groovy-core/commits/markup-template-engine&quot;&gt;take a look at the branch commits&lt;/a&gt;, you will definitely see that I went step by step. And eventually, I will issue a pull request when I think that the code is ready for prime time. I am not sure yet this should make into core groovy, or instead if it should go into an external project. Ideas are welcome!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I still have to make some changes, like not reporting errors if the type checking mode is not active (and always going through dynamic mode in that case) and probably write more benchmarks, but I&amp;#8217;m really looking forward to read what you think. Oh yes, one last thing: congratulations if you read that post throughfully!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>

  </channel> 
</rss>
