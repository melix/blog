<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cédric Champeau's blog</title>
    <link>https://melix.github.io/blog/</link>
    <atom:link href="https://melix.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Mon, 24 Jan 2022 12:58:19 +0100</pubDate>
    <lastBuildDate>Mon, 24 Jan 2022 12:58:19 +0100</lastBuildDate>

    <item>
      <title>Understanding Gradle plugins: the provider API</title>
      <link>https://melix.github.io/blog/2022/01/understanding-provider-api.html</link>
      <pubDate>Mon, 24 Jan 2022 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2022/01/understanding-provider-api.html</guid>
      	<description>
	&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last week, a colleague of mine pinged me about a problem he was facing in a new Micronaut module, with &lt;a href=&quot;https://github.com/JetBrains/gradle-grammar-kit-plugin&quot;&gt;Jetbrains&apos; Grammar-Kit plugin&lt;/a&gt;, a plugin which integrates with &lt;a href=&quot;https://jflex.de/manual.html&quot;&gt;JFlex&lt;/a&gt;.
We discovered a couple of issues:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the plugin is adding repositories transparently to the build, in particular Jitpack.io and an internal Jetbrains mirror, which is a very bad practice as it is introducing a security risk, and could also lead to build reproducibility problems&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the plugin isn&amp;#8217;t compatible with Gradle&amp;#8217;s lazy configuration API, making the build slower than it could be, by forcing the creation of tasks which do not necessarily need to be called&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last but not least, we also discovered that the JFlex API itself has problems: it&amp;#8217;s using shared mutable state (here &lt;em&gt;static state&lt;/em&gt;) for configuration, making it inherently not thread safe.
Because what we had to do was pretty simple (take a jflex file and generate a lexer from it), we took advantage of this to write our own Gradle plugin to handle calls to JFlex.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Therefore, the question I got from my colleague was legitimate:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;How do I link the task to run in the right phase, create a proper output dir, and add it to the java compile source set? Is there a good example plugin that does source generation that I could look at?&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this blog post we&amp;#8217;re going to answer those questions and show how Gradle elegantly solves all the above problems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_anatomy_of_a_plugin&quot;&gt;Anatomy of a plugin&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In Gradle, a plugin essentially consists in registering a number of tasks (things which execute actions, like compiling sources), or so-called extensions (exposed to the user in the form of a DSL for configuring the build).
There isn&amp;#8217;t a difference between what a plugin can do and what you can do in a build script, however, as soon as you have things which go beyond &lt;em&gt;configuration&lt;/em&gt;, it&amp;#8217;s a good idea to move things into a plugin.
The nice thing is that creating a plugin in Gradle is quite straightforward, and doesn&amp;#8217;t even require you to publish the plugin on Maven Central or the Gradle Plugin Repository: everything can be local to your project.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In our case, we want to create a task which is going to invoke the JFlex library to parse some &lt;code&gt;.jflex&lt;/code&gt; files and generate &lt;code&gt;.java&lt;/code&gt; files, so let&amp;#8217;s do it!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First of all, we&amp;#8217;re going to create a directory for our plugin, a &lt;code&gt;jflex-plugin&lt;/code&gt; directory at the root of our existing project.
We&amp;#8217;re also going to create 2 files in that directory:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;flex-plugin/settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;rootProject.name = &apos;jflex-plugin&apos;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;flex-plugin/build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;plugins {
    id &apos;java-gradle-plugin&apos;
}

repositories {
    mavenCentral()
}

dependencies {
    implementation &apos;de.jflex:jflex:1.8.2&apos;
}

gradlePlugin {
    plugins {
        jflex {
            id = &apos;io.micronaut.internal.jflex&apos;
            implementationClass = &apos;io.micronaut.internal.jflex.JFlexPlugin&apos;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What does this already tell us?
First of all, that our plugin is an independent Gradle project: it lives in the same repository as our main project, but it&amp;#8217;s really an independent build.
Second, it defines a &lt;code&gt;java-gradle-plugin&lt;/code&gt;, which is the Gradle way of saying &quot;this is a plugin for Gradle, written in Java&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This plugin has an implementation dependency on &lt;code&gt;jflex&lt;/code&gt;, and it declares the &lt;code&gt;id&lt;/code&gt; of the plugin, as well as its implementation class.
This is all the boilerplate you have to write to create a plugin, really.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Because our main build is going to use this plugin, we also have to edit the main build &lt;code&gt;settings.gradle&lt;/code&gt; file to &lt;em&gt;include&lt;/em&gt; that plugin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;includeBuild &quot;jflex-plugin&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This makes it possible to apply our JFlex plugin in our project:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;plugins {
    id &apos;java-library&apos;
    id &apos;io.micronaut.internal.jflex&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We use the plugin id that we have defined in our plugin descriptor.
This is how Gradle knows how to wire things together: by using this plugin request, it will automatically trigger the &lt;code&gt;jflex-plugin&lt;/code&gt; build.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
It wouldn&amp;#8217;t bother building the plugin if it wasn&amp;#8217;t used at all, which would be the case, for example, if we had multiple subprojects and that only one of them uses the plugin: depending on what we build, we may need to build the plugin or not.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_the_provider_api&quot;&gt;The provider API&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For the sake of learning, we&amp;#8217;ll start our implementation with what is most &quot;natural&quot; to developers: if you are familiar with Maven, you&amp;#8217;ll think of a Mojo.
If you are familiar with Ant, it&amp;#8217;s a task.
Similarly, in Gradle, the unit which is responsible for executing an action is called a task.
In our case, we want a task which is going to read JFlex files and generate sources.
Here&amp;#8217;s its skeleton:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;jflex-plugin/src/main/java/io/micronaut/internal/jflex/JFlexTask.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;@CacheableTask                                                  &lt;b&gt;(1)&lt;/b&gt;
public abstract class JFlexTask extends DefaultTask {           &lt;b&gt;(2)&lt;/b&gt;

    @InputDirectory                                             &lt;b&gt;(3)&lt;/b&gt;
    @PathSensitive(PathSensitivity.RELATIVE)
    public abstract DirectoryProperty getSourceDirectory();

    @OutputDirectory                                            &lt;b&gt;(4)&lt;/b&gt;
    public abstract DirectoryProperty getOutputDirectory();

    @TaskAction                                                 &lt;b&gt;(5)&lt;/b&gt;
    public void generateSources() {
      // call JFlex library
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;This annotation tells Gradle that the result of executing this task can be cached&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;every Gradle task needs to extend the &lt;code&gt;DefaultTask&lt;/code&gt; type&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the &lt;em&gt;input&lt;/em&gt; of our task is a directory containing JFlex files&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the &lt;em&gt;output&lt;/em&gt; of our task is going to be a directory containing generated Java files&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this is the main task action, which is going to call JFlex&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s explore a bit how this task is defined.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First, note how our task is defined &lt;em&gt;abstract&lt;/em&gt;: this is because we will let Gradle generate boilerplate code for us, in particular how to &lt;em&gt;inject&lt;/em&gt; the input and output properties.
We&amp;#8217;ll see later more reasons why it&amp;#8217;s interesting to let Gradle to this for you, but for now the obvious reason is that it reduces the amount of code you have to write: you don&amp;#8217;t need to know how to create a &lt;code&gt;DirectoryProperty&lt;/code&gt;: Gradle will do it for you.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Second, note how we are using &lt;code&gt;DirectoryProperty&lt;/code&gt; as the type for our input and output properties.
This is a very important Gradle type, which belongs to the so-called &quot;provider API&quot; or, as you can sometimes read, the &quot;lazy API&quot;.
Most of the ordering problems that earlier versions of Gradle had are fixed by this API, so use it!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One thing we can notice is that it&amp;#8217;s &lt;em&gt;strongly typed&lt;/em&gt;: to declare an input directory, we don&amp;#8217;t define the property as a &lt;em&gt;File&lt;/em&gt; or &lt;em&gt;Path&lt;/em&gt;: it&amp;#8217;s a &lt;em&gt;directory&lt;/em&gt;, which helps both Gradle and users understand what you are supposed to give as an input: if the property is set to a regular file, then Gradle can provide a reasonable error message explaining that it expected a directory instead.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s time to introduce how you could use this type in a build script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;tasks.register(&quot;generateLexer&quot;, JFlexTask) {
    sourceDirectory.set(layout.projectDirectory.dir(&apos;src/main/jflex&apos;)) &lt;b&gt;(1)&lt;/b&gt;
    outputDirectory.set(layout.buildDirectory.dir(&apos;generated/jflex&apos;))  &lt;b&gt;(2)&lt;/b&gt;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;set the input directory to &lt;code&gt;src/main/jflex&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set the output directory to &lt;code&gt;build/generated/jflex&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It may sound a bit complicated to declare, especially if you were used to the following syntax:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;tasks.register(&quot;generateLexer&quot;, JFlexTask) {
    sourceDirectory = file(&quot;src/main/jflex&quot;)
    outputDirectory = file(&quot;build/generated/jflex&apos;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;code&gt;register&lt;/code&gt; is the new &lt;code&gt;create&lt;/code&gt;: you should never use &lt;em&gt;create&lt;/em&gt; anymore, as it eagerly creates tasks, which means configuring them &lt;em&gt;even if they won&amp;#8217;t participate in the task graph&lt;/em&gt;, while &lt;em&gt;register&lt;/em&gt; is lazy: if a task needs to be executed, and only if, it&amp;#8217;s going to be configured.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Interestingly, this syntax &lt;code&gt;outputDirectory = file(&quot;build/generated/jflex&apos;)&lt;/code&gt; is still valid with our properties and would lead to the same result if executed.
It&amp;#8217;s simpler, so why should you bother with the more complex syntax?
To understand this, let&amp;#8217;s focus on the output directory, which makes it more obvious what is going on: compare &lt;code&gt;build/generated/jflex&lt;/code&gt; with &lt;code&gt;layout.buildDirectory.dir(&apos;generated/jflex&apos;)&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the 1st case, the output directory is &lt;em&gt;hardcoded&lt;/em&gt; to the &lt;code&gt;build/generated/jflex&lt;/code&gt; directory.
In the 2d case, the output directory is &lt;em&gt;derived from&lt;/em&gt; the location of the build directory.
It means that if, for some reason, your build is configured to use a different output directory than the conventional &lt;code&gt;build&lt;/code&gt; directory, say &lt;code&gt;target&lt;/code&gt; (as in Maven).
In the 1st case, the output directory of the task would be &lt;code&gt;build/generated/jflex&lt;/code&gt;, so it would be writing to the wrong directory.
In the 2d case, the output would be correctly wired to &lt;code&gt;target/generated/jflex&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Some smart Gradle users might think they could workaround the problem by using &lt;code&gt;file(&quot;$buildDir/generated/jflex&quot;)&lt;/code&gt; instead.
That&amp;#8217;s better, but not sufficient, because the result depends on &lt;em&gt;when&lt;/em&gt; this is called: if the build directory is changed &lt;em&gt;after&lt;/em&gt; the task is configured, then you&amp;#8217;d get the wrong result, which is why lots of users start to randomly add &lt;code&gt;afterEvaluate&lt;/code&gt; to workaround such problems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Outcome #1&lt;/strong&gt;: The provider API solves ordering issues and avoids spurious calls to &lt;code&gt;afterEvaluate&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_convention_plugins&quot;&gt;Convention plugins&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the beginning of this blog post, I mentioned that what we want to avoid users to create tasks directly in their build scripts: this is a sign that the code should be moved to a &lt;em&gt;plugin&lt;/em&gt;.
This is exactly what we&amp;#8217;re going to do, so instead of asking the user to declare the task, we&amp;#8217;re going to do it for them.
It&amp;#8217;s time to create our plugin class:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;jflex-plugin/src/main/java/io/micronaut/internal/jflex/JFlexPlugin.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public class JFlexPlugin implements Plugin&amp;lt;Project&amp;gt; {                                  &lt;b&gt;(1)&lt;/b&gt;
    @Override
    public void apply(Project project) {
        project.getPluginManager().apply(JavaPlugin.class);                            &lt;b&gt;(2)&lt;/b&gt;
        JavaPluginExtension javaExt = project.getExtensions()
           .getByType(JavaPluginExtension.class);                                      &lt;b&gt;(3)&lt;/b&gt;
        TaskProvider&amp;lt;JFlexTask&amp;gt; generateLexer = project.getTasks()
            .register(&quot;generateLexer&quot;, JFlexTask.class, task -&amp;gt; {                      &lt;b&gt;(4)&lt;/b&gt;
               task.setGroup(LifecycleBasePlugin.BUILD_GROUP);
               task.setDescription(&quot;Generates lexer files from JFlex grammar files.&quot;);
               task.getSourceDirectory().convention(
                    project.getLayout().getProjectDirectory().dir(&quot;src/main/jflex&quot;)    &lt;b&gt;(5)&lt;/b&gt;
               );
               task.getOutputDirectory().convention(
                    project.getLayout().getBuildDirectory().dir(&quot;generated/jflex&quot;)     &lt;b&gt;(6)&lt;/b&gt;
               );
        });
        // Register the output of the JFlex task as generated sources
        javaExt.getSourceSets()
                .getByName(SourceSet.MAIN_SOURCE_SET_NAME)
                .getJava()
                .srcDir(generateLexer);                                                &lt;b&gt;(7)&lt;/b&gt;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Declare a &lt;em&gt;project scoped&lt;/em&gt; plugin&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This plugin will contribute Java sources, so it &lt;em&gt;depends on&lt;/em&gt; the Java plugin, let&amp;#8217;s apply it&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Java plugin defines a Java extension that we&amp;#8217;re going to need&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Registers our &lt;code&gt;generateLexer&lt;/code&gt; task&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Defines the conventional (&lt;em&gt;default&lt;/em&gt;) location of JFlex source files&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Defines the conventional (&lt;em&gt;default&lt;/em&gt;) location of generated sources&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Defines that the output of the task are Java files which need to be compiled&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I recommend writing plugins in plain Java, but you could use Groovy or Kotlin.
It makes things a bit more verbose, but they are clearer and &quot;DSL magic&quot; free.
Let&amp;#8217;s explore what the plugin is doing.
First of all, it&amp;#8217;s a &lt;em&gt;project plugin&lt;/em&gt;, which basically means it&amp;#8217;s a plugin which is supposed to be applied on a &lt;em&gt;project&lt;/em&gt; build file, so typically a &lt;code&gt;build.gradle&lt;/code&gt; file.
There are other kinds of plugins in Gradle, which I won&amp;#8217;t cover in this post.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For the most part, the plugin does &lt;em&gt;exactly&lt;/em&gt; what we had in the build script: it registers a task, gives it a description, but more importantly, it sets the &lt;em&gt;conventional&lt;/em&gt; values of inputs and outputs.
Note how I used the &lt;code&gt;convention&lt;/code&gt; method to set the input directory, instead of the &lt;code&gt;set&lt;/code&gt; method that we used in the build script: while using both would work, there&amp;#8217;s a semantic difference between the two: in a plugin, you most likely want to set the convention value, which is the value which is used by default, if the user says nothing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Our plugin does one more thing, that we didn&amp;#8217;t cover yet: &lt;em&gt;wiring&lt;/em&gt; the task in the &quot;lifecycle&quot;, as my colleague asked.
The notion of &quot;lifecyle&quot; doesn&amp;#8217;t really make sense in Gradle, and most likely comes from the Maven mindset, where things are defined via a &quot;lifecyle&quot;.
I already covered this topic &lt;a href=&quot;http://melix.github.io/blog/2018/09/gradle-lifecycle.html&quot;&gt;in this blog post&lt;/a&gt;, but here&amp;#8217;s the major difference: in Gradle, &lt;em&gt;everything&lt;/em&gt; declares its inputs, and the tool is responsible for wiring things properly, so that you don&amp;#8217;t have to execute redundant work.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Here, the legitimate question is: my plugin generates some sources, but they need to be compiled, and therefore available to my production code, how can I do that?
This is where the &lt;code&gt;JavaPluginExtension&lt;/code&gt; comes into play.
In fact, our plugin doesn&amp;#8217;t work independently: it assumes that we&amp;#8217;re programming Java, and it assumes that we can compile Java sources.
For this, we can actually make the assumption &lt;em&gt;explicit&lt;/em&gt;, by requiring that the &lt;code&gt;JavaPlugin&lt;/code&gt; is applied.
When this plugin is applied, it defines a &lt;code&gt;JavaPluginExtension&lt;/code&gt;, which declares source sets.
In particular, it defines the Java source sets (&lt;code&gt;main&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;), which are the sources which are compiled.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The shift in mindset is, therefore, not to wonder how to compile the generated sources and put them &quot;on the classpath&quot;, like &lt;a href=&quot;https://melix.github.io/blog/2021/10/gradle-quickie-dependson.html&quot;&gt;you&amp;#8217;d do in Maven&lt;/a&gt;, but simply explain that there&amp;#8217;s another directory of sources to consider.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is exactly what our plugin is doing:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;javaExt.getSourceSets()
    .getByName(SourceSet.MAIN_SOURCE_SET_NAME)
    .getJava()
    .srcDir(generateLexer);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This says &quot;please add the output of the &lt;code&gt;generateLexer&lt;/code&gt; task as a source directory&quot;.
Which is semantically much more powerful.
The magic is that because the &lt;code&gt;generateLexer&lt;/code&gt; task defines an output directory, now we just said that this output directory contains Java classes.
And &lt;em&gt;any&lt;/em&gt; task which requires Java sources will automatically trigger the execution of our &lt;code&gt;generateLexer&lt;/code&gt; task: we don&amp;#8217;t have to define the relationship explicitly!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Outcome #2&lt;/strong&gt;: Gradle models relationships using domain objects which are shared between plugins. It can &lt;em&gt;infer&lt;/em&gt; dependencies thanks to those objects.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In other words, &lt;em&gt;because&lt;/em&gt; the input of the Java compilation task is a &lt;em&gt;source set&lt;/em&gt;, and that source set defines that as an input, it has a directory which is generated by the &lt;code&gt;generateLexer&lt;/code&gt; task, Gradle knows that before compiling, it needs to call that &lt;code&gt;generateLexer&lt;/code&gt; task.
Any other task using the source set as an input will do the same: it avoids duplication of code and hard wiring!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_using_the_worker_api&quot;&gt;Using the worker API&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At this stage, we&amp;#8217;re pretty much done with the wiring, but we still miss the actual implementation of the task.
This could be left as an exercise to the reader, but there&amp;#8217;s actually an interesting aspect of the Gradle APIs to cover.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you remember, I mentioned in the introduction of the blog post that the JFlex API uses a mix of static state and instance state to configure itself.
This isn&amp;#8217;t nice, as it basically means that the API is not thread-safe: if, for some reason, we have multiple tasks generating sources (for example if we have multiple jflex directories, or different projects having jflex sources), then we can&amp;#8217;t safely generate sources in parallel!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is quite problematic, but Gradle provides a simple workaround for this: the &lt;a href=&quot;https://docs.gradle.org/current/userguide/worker_api.html&quot;&gt;worker API&lt;/a&gt;.
The worker API allows a number of things, but in particular it permits executing code in a different process, or, more lightweight, in an isolated classloader.
The second option is good for us, because &lt;em&gt;static state&lt;/em&gt; in Java is only as static as it is in a given classloader: if 2 &quot;identical&quot; classes are loaded in 2 different classloaders, then they both have their independent static state.
We&amp;#8217;re going to use this to properly isolate execution of our code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As a consequence, executing JFlex will be slightly more complicated, but as usual in programming, it&amp;#8217;s only &lt;em&gt;one level of indirection&lt;/em&gt;.
Instead of having our task directly invoke JFlex, we need to create a class which is going to invoke JFlex.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To use the worker API, we need to inject the so-called &lt;code&gt;WorkerExecuter&lt;/code&gt; in our task:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;jflex-plugin/src/main/java/io/micronaut/internal/jflex/JFlexTask.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;@CacheableTask
public abstract class JFlexTask extends DefaultTask {

    @InputDirectory
    @PathSensitive(PathSensitivity.RELATIVE)
    public abstract DirectoryProperty getSourceDirectory();

    @OutputDirectory
    public abstract DirectoryProperty getOutputDirectory();

    @Inject
    protected abstract WorkerExecutor getWorkerExecutor();

    @TaskAction
    public void generateSources() {
        // We&apos;re using classloader isolation, because the JFlex API
        // uses static state!
        getWorkerExecutor()
                .classLoaderIsolation()
                .submit(JFlexAction.class, params -&amp;gt; {
                    params.getSourceDirectory().set(getSourceDirectory());
                    params.getSourceFiles().from(getSourceDirectory());
                    params.getOutputDirectory().set(getOutputDirectory());
                });
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Note again how you don&amp;#8217;t need to care &lt;em&gt;how&lt;/em&gt; to get a &lt;code&gt;WorkerExecuter&lt;/code&gt;: just tell Gradle you need it and voilà!
When using the worker API, the task action basically becomes an empty shell, which just configures how actual execution should happen.
In this case, we declare &lt;em&gt;classloader isolation&lt;/em&gt;, as well as the inputs of the &lt;em&gt;action&lt;/em&gt;, which is going to be executed in isolation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The action class basically consists of calling the JFlex API:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;jflex-plugin/src/main/java/io/micronaut/internal/jflex/JFlexAction.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public abstract class JFlexAction implements WorkAction&amp;lt;JFlexAction.Parameters&amp;gt; {
    public interface Parameters extends WorkParameters {
        DirectoryProperty getSourceDirectory();
        ConfigurableFileCollection getSourceFiles();
        DirectoryProperty getOutputDirectory();
    }

    @Override
    public void execute() {
        OptionUtils.setDefaultOptions();
        Path sourcePath = getParameters().getSourceDirectory().getAsFile().get().toPath();
        File outputDirectory = getParameters().getOutputDirectory().getAsFile().get();
        OptionUtils.setDir(outputDirectory);
        Options.dump = false;
        Options.encoding = StandardCharsets.UTF_8;
        Options.no_backup = true;
        getParameters().getSourceFiles()
                .getAsFileTree()
                .getFiles()
                .forEach(jflexFile -&amp;gt; generateSourceFileFor(jflexFile, outputDirectory, sourcePath));
    }

    private void generateSourceFileFor(File jflexFile, File outputDirectory, Path sourcePath) {
        String relativePath = sourcePath.relativize(jflexFile.getParentFile().toPath()).toString();
        OptionUtils.setDir(new File(outputDirectory, relativePath));
        new LexGenerator(jflexFile).generate();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The action declares its inputs with the &lt;code&gt;WorkParameters&lt;/code&gt; interface and the code which is going to be executed in an isolated classloader lives in the &lt;code&gt;execute&lt;/code&gt; method.
You can see how it uses static state (&lt;code&gt;OptionsUtils.setDefaultOptions()&lt;/code&gt;, &lt;code&gt;Options.dump&lt;/code&gt;, &amp;#8230;).
The worker API lets us workaround what should probably be considered as a &lt;em&gt;bug&lt;/em&gt; in JFlex!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Outcome #3&lt;/strong&gt;: The Gradle Worker API lets you isolate your task code in classloaders or even separate worker processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_more_about_the_provider_api&quot;&gt;More about the provider API&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Before closing this blog post, I want to give you a bit more insights about the provider API.
I already mentioned that one of the main advantages is that it solves ordering issues, by being fully lazy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the most interesting aspects of this API is &lt;em&gt;value derivation&lt;/em&gt;.
To understand this concept, let&amp;#8217;s imagine a &lt;em&gt;Greeter&lt;/em&gt; task which is responsible for saying hello:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;abstract class Greeter extends DefaultTask {
    @Input
    public abstract Property&amp;lt;String&amp;gt; getUser()

    @Input
    public abstract Property&amp;lt;String&amp;gt; getIntro()

    @Input
    public abstract Property&amp;lt;String&amp;gt; getOutro()

    @TaskAction
    public void sayHello() {
        String user = getUser().get();
        String intro = getIntro().get();
        String outro = getOutro().get();
        System.out.println(intro + user + outro);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;we can register a task which says hello in English by doing this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;tasks.register(&quot;sayHello&quot;, Greeter) {
   intro = &quot;Hello, &quot;
   user = &quot;Cédric&quot;
   outro = &quot;!&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And another one which says hello in French:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;tasks.register(&quot;direBonjour&quot;, Greeter) {
   intro = &quot;Bonjour &quot;
   user = &quot;Cédric&quot;
   outro = &quot; !&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s a bit annoying that we have to repeat the user declaration in both tasks, and the rule &quot;in french, exclamation mark must be preceeded with a space&quot; doesn&amp;#8217;t need to be known to the user.
To avoid this redundancy, we&amp;#8217;re going to write a plugin which makes all this more convenient.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First, we&amp;#8217;re going to create an &lt;em&gt;extension&lt;/em&gt;, which is going to hold what is &lt;em&gt;relevant&lt;/em&gt; for user configuration: the name of the person to greet and what outro we want to use.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;interface GreetingExtension {
    Property&amp;lt;String&amp;gt; getUser()
    Property&amp;lt;String&amp;gt; getOutro()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Again we don&amp;#8217;t have to provide an implementation for this, Gradle knows how to create a &lt;code&gt;Property&amp;lt;String&amp;gt;&lt;/code&gt;. This extension simply needs to be created by our plugin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;GreetingExtension extension = project.getExtensions().create(&quot;greeting&quot;, GreetingExtension.class);
extension.getOutro().convention(&quot;!&quot;);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s interesting to see that our DSL will only expose &quot;user&quot; and &quot;outro&quot;, but not the intro, which is actually dependent on the languag.
We can also set a conventional value on the extension itself.
The plugin can then register both tasks for us:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;tasks.register(&quot;sayHello&quot;, Greeter.class, task -&amp;gt; {
   task.getIntro().convention(&quot;Hello, &quot;);
   task.getUser().convention(extension.getUser());
   task.getOutro().convention(extension.getOutro());
});
tasks.register(&quot;direBonjour&quot;, Greeter.class, task -&amp;gt; {
   task.getIntro().convention(&quot;Bonjour &quot;);
   task.getUser().convention(extension.getUser());
   task.getOutro().convention(extension.getOutro().map(o -&amp;gt; &quot; &quot; + o));
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now you see the interest of using the provider API: for the english case, the task is going to use the outro value &lt;em&gt;directly&lt;/em&gt;, while for the french version, by default, it&amp;#8217;s going to compute a &lt;em&gt;derived&lt;/em&gt; value.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The user will configure the tasks via the extension:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;greeting {
    user = &quot;Cédric&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Calling &lt;code&gt;sayHello&lt;/code&gt; will output:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Hello, Cédric!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;While calling &lt;code&gt;direBonjour&lt;/code&gt; will output:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Bonjour Cédric !&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Should the user configure a different outro, the outputs would be different:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;greeting {
    user = &quot;Cédric&quot;
    outro = &quot;!!!&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;results in this english version:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Hello, Cédric!!!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;While the french one is:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Bonjour Cédric !!!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;BUT, because we defined the &lt;em&gt;convention value&lt;/em&gt; of outro of the french task as a derived value, it is still possible for the user to override it completely:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;greeting {
    user = &quot;Cédric&quot;
    outro = &quot;!!!&quot;
}
tasks.named(&quot;direBonjour&quot;) {
    outro = &quot; !&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then executing &lt;code&gt;direBonjour&lt;/code&gt; would print:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Bonjour Cédric !&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Outcome #4&lt;/strong&gt;: The provider API lets precisely define how to compute a value from another property, in a lazy manner, and provides an elegant way to supply default, or conventional values.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can read more about lazy configuration and the provider API in the &lt;a href=&quot;https://docs.gradle.org/current/userguide/lazy_configuration.html&quot;&gt;Gradle documentation&lt;/a&gt;, but in a nutshell, the derivation logic is &lt;em&gt;exactly&lt;/em&gt; what the &lt;code&gt;layout.buildDirectory.dir(&quot;...&quot;)&lt;/code&gt; is doing: it defines a directory which is &lt;em&gt;derived from&lt;/em&gt; the existing build directory value.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this blog post, we&amp;#8217;ve leveraged a real world use case, integrating lexer generation via JFlex, to explain how to properly write a Gradle plugin which:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;uses the lazy provider API, making it immune to configuration ordering problems&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;explains how Gradle&amp;#8217;s &quot;task dependencies&quot; are &lt;em&gt;implicit&lt;/em&gt;, avoiding hardcoding relationships between tasks, and making it much more robust to arbitrary configuration changes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;doesn&amp;#8217;t rely on arbitrary ordering (e.g, like in Maven, &quot;&lt;em&gt;all&lt;/em&gt; sources of &lt;em&gt;all&lt;/em&gt; generators must be generated before you can compile &lt;em&gt;anything&lt;/em&gt;&quot;) but instead knows that &lt;em&gt;only&lt;/em&gt; if you need to compile the main source set, &lt;em&gt;then&lt;/em&gt; you need to generate JFlex sources&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uses the worker API, letting us working around a bug in the JFlex library regarding shared mutable state&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In addition, we&amp;#8217;ve seen the basics of the provider API, which allows plugins to define default values as well as computing derived values for inputs or outputs in a lazy manner.
We&amp;#8217;ve also hinted at how plugins can expose configuration mechanisms which reduce the API surface, while making it convenient to refactor, therefore dramatically reducing the cost of maintenance of builds.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Eventually, the &lt;em&gt;user facing code&lt;/em&gt; of using our JFlex plugin is a &lt;em&gt;single line&lt;/em&gt; in a build script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;plugins {
    id &quot;io.micronaut.internal.jflex&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There is &lt;em&gt;no configuration&lt;/em&gt; (because we use the convention values) and &lt;em&gt;no imperative code&lt;/em&gt; (because the build logic of creating tasks is deferred to a &lt;em&gt;plugin&lt;/em&gt;).
As a bonus, because we used a &lt;em&gt;separate build&lt;/em&gt; and &lt;a href=&quot;https://docs.gradle.org/current/userguide/composite_builds.html&quot;&gt;composite builds&lt;/a&gt;, if we want to publish this plugin to the Gradle plugin portal later, it would be just about adding some configuration to the &lt;code&gt;jflex-plugin&lt;/code&gt; module.
There is effectively no need to publish a plugin, either to a local repository, or a remote one, to be able to use plugins in Gradle!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The full code is actually available in the upcoming &lt;a href=&quot;https://github.com/micronaut-projects/micronaut-toml&quot;&gt;Micronaut TOML module&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Composition over inheritance: Gradle vs Maven</title>
      <link>https://melix.github.io/blog/2021/12/composition-in-gradle.html</link>
      <pubDate>Wed, 1 Dec 2021 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2021/12/composition-in-gradle.html</guid>
      	<description>
	&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In general, when I read comments about Maven vs Gradle, I realize that people focus on the cosmetics (XML vs Groovy/Kotlin) when it&amp;#8217;s from my point of view the least interesting aspect of the comparison.
In this article, I want to focus on one particular aspect which differentiates the 2 build tools: the famous &lt;strong&gt;composition over inheritance&lt;/strong&gt; paradigm.
In different aspects (POM files, lifecycle), Apache Maven is using &lt;em&gt;inheritance&lt;/em&gt;, while Gradle is using &lt;em&gt;composition&lt;/em&gt;.
It is a particularly important difference which completely changes the way we think about building software.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_inheritance_in_maven_builds&quot;&gt;Inheritance in Maven builds&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A typical Maven project is built with a &lt;em&gt;pom.xml&lt;/em&gt; file, which declares everything the module needs:
- the dependencies
- the build plugins and their configuration&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Very quickly, it turns out that there are &lt;em&gt;common things&lt;/em&gt; that you want to share between modules:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;they would use the same compiler options&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;they would use the same plugins and configuration&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;they would apply a number of common dependencies&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;etc.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s imagine that we have a project which consists of 3 modules:
- a &lt;code&gt;library&lt;/code&gt; module, pure Java
- an &lt;code&gt;application&lt;/code&gt; module which uses the &lt;code&gt;library&lt;/code&gt; and the &lt;a href=&quot;https://micronaut.io&quot;&gt;Micronaut Framework&lt;/a&gt;
- and a &lt;code&gt;documentation&lt;/code&gt; module which provides a user manual for the application using &lt;a href=&quot;https://asciidoctor.org&quot;&gt;Asciidoctor&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The idiomatic way to solve the problem of sharing the configuration of the &lt;code&gt;library&lt;/code&gt; and &lt;code&gt;application&lt;/code&gt; modules (which are both Java) in Maven is to define a so-called &quot;parent POM&quot; which declares all of these common things, for example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint xml language-xml&quot;&gt;&lt;code&gt;&amp;lt;project xmlns=&quot;https://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;example-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;

    &amp;lt;name&amp;gt;Common Config&amp;lt;/name&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;junit.jupiter.version&amp;gt;5.8.1&amp;lt;/junit.jupiter.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit-jupiter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${junit.jupiter.version}&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.0.0-M5&amp;lt;/version&amp;gt;
            &amp;lt;/plugin&amp;gt;

            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;${java.version}&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To simplify things, we could call this a &quot;convention&quot;: by convention, all modules which will use this parent POM will apply all those plugins and dependencies (note, there are subtleties if you use &lt;code&gt;&amp;lt;pluginManagement&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A &quot;child POM&quot; like our application pom only has to declare the parent to &quot;inherit&quot; from it:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint xml language-xml&quot;&gt;&lt;code&gt;&amp;lt;project xmlns=&quot;https://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;example-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;artifactId&amp;gt;application&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;library&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This model works really well when all modules have a lot in common.
The inheritance model also makes it simple to override things (child values override parent values).
In the example above, we don&amp;#8217;t have to specify the &lt;code&gt;groupId&lt;/code&gt; and &lt;code&gt;version&lt;/code&gt; of our module because it will be inherited from the parent.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, this model comes with a number of drawbacks:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;as soon as you have different modules which share different set of dependencies, or use different sets of plugins, you have to create different parents and have an inheritance model between parents. Unfortunately this is the case here, since only our &lt;code&gt;library&lt;/code&gt; and &lt;code&gt;application&lt;/code&gt; modules have something in common. It won&amp;#8217;t be a surprise for many that you have to &lt;em&gt;exclude dependencies&lt;/em&gt; just because they came through parent poms&amp;#8230;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;you can only have a &lt;em&gt;single&lt;/em&gt; parent, meaning that you cannot inherit from a framework parent POM &lt;em&gt;and&lt;/em&gt; from your own conventions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it&amp;#8217;s not great for performance, because you end up configuring a lot of things which will never be necessary for your particular &quot;child&quot; module.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;overriding values is sometimes much more complicated and you have to start relying on obscure syntaxes like &lt;code&gt;combine.children=&quot;append&quot;&lt;/code&gt; (see &lt;a href=&quot;https://www.baeldung.com/maven-plugin-override-parent&quot;&gt;this excellent blog post&lt;/a&gt; for details).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Those limitations are quickly reached when you are using a framework like &lt;a href=&quot;https://micronaut.io&quot;&gt;Micronaut&lt;/a&gt; or &lt;a href=&quot;https://spring.io/projects/spring-boot&quot;&gt;Spring Boot&lt;/a&gt;.
Because those frameworks are built with developer productivity in mind, they come with their own &quot;parent POMs&quot; which makes the lives of developers easier by avoiding copy and paste of hundreds of lines of XML.
They also need to provide this parent POM because they would come with their own Maven plugin which works around the limitations of the lifecycle model.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;But then, we have a problem: on one side, you have this &quot;parent POM&quot; which is provided by the framework, and on the other side, you have your own &quot;parent POM&quot; which is providing, say, the company-specific conventions (like checkstyle configuration, coordinates of Maven repositories for publication, etc.).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In order to be able to use both conventions, you have to create a new parent POM, and you have no choice but writing your company convention parent POM inheriting from the framework POM: obviously you can&amp;#8217;t change the framework POM itself!
This is problematic, because it means that &lt;strong&gt;for every release of the framework, you have to update your company convention parent POM&lt;/strong&gt;.
This is also problematic for another aspect: not all the modules of your multi-project build are &quot;Spring Boot&quot; or &quot;Micronaut&quot; applications.
Some of them may be simple Java libraries which are used by your app, but do &lt;em&gt;not&lt;/em&gt; require the framework. As a consequence, you have to create &lt;em&gt;multiple&lt;/em&gt; parents, and duplicate the configuration in each of those POM files.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This inheritance problem surfaces in different places in Maven.
Another one is, as I mentioned, the &quot;lifecycle&quot; which works in phases.
Basically, in Maven everything is executed linearly: if you want to do &lt;em&gt;install&lt;/em&gt;, then you &lt;em&gt;have to&lt;/em&gt; execute everything which is &lt;em&gt;before&lt;/em&gt; that phase, which includes, for example, &lt;em&gt;test&lt;/em&gt;.
This may sound reasonable, but this model completely falls apart: this is no surprise that &lt;em&gt;every single plugin&lt;/em&gt; has to implement their own &lt;code&gt;-DskipTest&lt;/code&gt; variant, in order to avoid doing work which shouldn&amp;#8217;t be done.
I had &lt;a href=&quot;https://lists.apache.org/list?&lt;a href=&quot;mailto:users@maven.apache.org&quot;&gt;users@maven.apache.org&lt;/a&gt;:2021-9&quot;&gt;an interesting use case when implementing the GraalVM native Maven plugin&lt;/a&gt;, which requires to configure the surefire plugin to pass extra arguments.
Long story short: this isn&amp;#8217;t possible with Maven.
Consequence: the only workaround is the multiplication of Maven profiles, which a user has to understand, maintain, and remember.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_composition_in_gradle_builds&quot;&gt;Composition in Gradle builds&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle builds use a very different model: &lt;strong&gt;composition&lt;/strong&gt;.
In a nutshell, in a Gradle project you don&amp;#8217;t explain &lt;em&gt;how to build&lt;/em&gt;, but &lt;em&gt;what you build&lt;/em&gt;: that is, you would say &quot;this is a library&quot;, or &quot;this is a CLI application&quot; or &quot;this is a documentation module&quot;.
Because a library exposes an API and an application doesn&amp;#8217;t, those are &lt;em&gt;different things&lt;/em&gt;, so their conventions, and capabilities, are different.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The way you &quot;say&quot; this is in a Gradle build is by &lt;em&gt;applying plugins&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A typical Java library would apply the &lt;code&gt;java-library&lt;/code&gt; plugin, while an application would apply the &lt;code&gt;application&lt;/code&gt; plugin and a documentation project would apply, say, the &lt;code&gt;asciidoctor&lt;/code&gt; plugin.
What do a Java library project and a documentation project have in common? Barely nothing.
A Java Library has Java sources, a number of dependencies, code quality plugins applied, etc.
The documentation module, on its side, is a set of markdown or asciidoc files, and resources.
The layout of the projects is different, the &lt;em&gt;conventions&lt;/em&gt; are different, and the set of plugins are different.
Java projects may share the same conventions for source layout, but they are obviously different for the docs.
In addition, there&amp;#8217;s &lt;em&gt;no reason&lt;/em&gt; to let the user declare &quot;implementation&quot; dependencies on the documentation project: it doesn&amp;#8217;t make sense so it should be an error to do so.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;On the other hand all those modules may share a number of things:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;they are all published to a Maven repository&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;they need to use the same Java toolchain&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;they need to comply to security policies of your company&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The way Gradle solves this problem is by &lt;em&gt;composing plugins&lt;/em&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a plugin can &quot;apply&quot; another plugin&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;each plugin is guaranteed to be applied only once, even if several plugins use it&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a plugin can &quot;react&quot; to the application of other plugins, allowing fine-grained customizations&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So in the example above, the &lt;code&gt;application&lt;/code&gt; use case can be easily solved:
first, you&amp;#8217;d have your own &quot;convention plugin&quot; which defines your company conventions (e.g apply the &lt;code&gt;checkstyle&lt;/code&gt; plugin with a number of rules).
Then, you&amp;#8217;d have the Micronaut application plugin which is already written for you.
Finally, your application module would simply &lt;em&gt;apply both plugins&lt;/em&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;plugins {
   id &apos;com.mycompany.conventions&apos; version &apos;1.0.0&apos;
   id &apos;io.micronaut.application&apos; version &apos;3.0.0&apos;
}

micronaut {
    version &apos;3.2.0&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What becomes &lt;em&gt;more interesting&lt;/em&gt; is that you can (and you actually &lt;em&gt;should&lt;/em&gt;)  create your own &quot;component types&quot; which apply a number of plugins.
In the example above, we could replace the use of the 2 plugins with a single one:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;plugins {
   id &apos;com.mycompany.micronaut-application&apos; version &apos;3.0.0&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Note how we moved the configuration of the &lt;code&gt;micronaut&lt;/code&gt; version to our convention plugin.
I&amp;#8217;m not going to explain how to write a custom Gradle plugin in this blog post, but the &lt;em&gt;code&lt;/em&gt; of this plugin would very much look like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;plugins {
    id &apos;com.mycompany.conventions&apos; version &apos;1.0.0&apos;
    id &apos;io.micronaut.application&apos; version &apos;3.0.0&apos;
}

micronaut {
    version &apos;3.2.0&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Does it look familiar? Yes it does, this is &lt;em&gt;exactly&lt;/em&gt; what we had in the beginning: composition is slowly happening!
I encourage you to take a look at &lt;a href=&quot;https://docs.gradle.org/current/userguide/structuring_software_products.html&quot;&gt;this documentation&lt;/a&gt; for further details about writing your own convention plugins.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Interestingly, as I said, Gradle plugins are allowed to &lt;em&gt;react&lt;/em&gt; to the presence of other plugins.
This makes it particularly neat for defining dynamically more tasks depending on the context.
For example, a plugin can do:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;pluginManager.withPlugin(&apos;io.micronaut.application&apos;) {
    // configure the Micronaut application plugin
}
pluginManager.withPlugin(&apos;io.micronaut.library&apos;) {
    // configure the Micronaut library plugin
}
pluginManager.withPlugin(&apos;io.spring.boot&apos;) {
    // configure the Spring Boot plugin
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Which is very resilient to the fact that the plugins may be applied in any order and that they can combine with each other to provide higher level constructs.
It also makes it possible to &lt;em&gt;give choice&lt;/em&gt; to users regarding their preferences: you provide a single convention plugin which is aware of what to do if the user prefers to use Spring Boot over Micronaut.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the end, &lt;code&gt;com.mycompany.micronaut-application&lt;/code&gt; is defined as a combination of the &lt;code&gt;io.micronaut.application&lt;/code&gt;, &lt;code&gt;your.company.conventions&lt;/code&gt; plugins.
Instead of declaring &lt;em&gt;how to build&lt;/em&gt; your company application, you simply described &lt;em&gt;what it is&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is only touching the surface of the Gradle world here, but when I read that Gradle is &quot;just Ant on steroids&quot;, &lt;strong&gt;nothing could be more wrong&lt;/strong&gt;.
Gradle in this case is much superior, because it focuses on &lt;em&gt;convention over configuration&lt;/em&gt;, while providing better constructs than Maven does for it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;But let&amp;#8217;s come back to our multi-project example: each of the modules would apply a different convention plugin (which is also why it&amp;#8217;s important that the &lt;em&gt;allprojects&lt;/em&gt; pattern dies):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;library&lt;/code&gt; would apply the &lt;code&gt;com.mycompany.library&lt;/code&gt; plugin&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;application&lt;/code&gt; would apply the &lt;code&gt;com.mycompany.application&lt;/code&gt; plugin&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;docs&lt;/code&gt; would apply the &lt;code&gt;com.mycompany.docs&lt;/code&gt; plugin&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;com.mycompany.library&lt;/code&gt; plugin would, for example, apply the &lt;code&gt;java-library&lt;/code&gt; and &lt;code&gt;com.mycompany.java-conventions&lt;/code&gt; plugin.
The &lt;code&gt;com.mycompany.application&lt;/code&gt; plugin would, for example, apply the &lt;code&gt;io.micronaut.application&lt;/code&gt; and &lt;code&gt;com.mycompany.java-conventions&lt;/code&gt; plugin (knowing that the &lt;code&gt;io.micronaut.application&lt;/code&gt; plugin applied the &lt;code&gt;application&lt;/code&gt; plugin and more, such as the GraalVM plugin)
The &lt;code&gt;com.mycompany.docs&lt;/code&gt; plugin would, for example, apply the &lt;code&gt;org.asciidoctor.jvm.convert&lt;/code&gt; plugin and the &lt;code&gt;com.mycompany.docs&lt;/code&gt; plugin.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You&amp;#8217;ll notice how those actually combine together, making it easier to maintain and upgrade builds: should you change the company conventions, all you have to do is release a new version of the convention plugin.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this quickie, I have explained a major difference in how Maven and Gradle envision build configuration.
While both of them are designed with &lt;em&gt;convention over configuration&lt;/em&gt; in mind, the inheritance model of Maven makes it difficult to build conventions on top of each other without duplication.
On the other hand, Gradle uses a &lt;em&gt;composition&lt;/em&gt; model which makes it possible to design your own conventions while being aware of other plugins being applied by the user: Gradle builds are more lenient and more maintainable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As a complement, you might be interested in:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;reading the &lt;a href=&quot;https://docs.gradle.org/current/userguide/structuring_software_products.html&quot;&gt;structuring large projects&lt;/a&gt; documentation from the Gradle docs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;watching my &lt;a href=&quot;https://www.youtube.com/watch?v=MaansFoPHKg&amp;amp;feature=youtu.be&quot;&gt;10 mins video&lt;/a&gt; about authoring Gradle builds&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;following my former team mate Jendrik who created &lt;a href=&quot;https://www.youtube.com/playlist?list=PLWQK2ZdV4Yl2k2OmC_gsjDpdIBTN0qqkE&quot;&gt;a series of videos about modern Gradle&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Multi-repository development made easy</title>
      <link>https://melix.github.io/blog/2021/11/multirepo-dev-made-easy.html</link>
      <pubDate>Thu, 4 Nov 2021 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2021/11/multirepo-dev-made-easy.html</guid>
      	<description>
	&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_are_you_working_in_a_multi_repository_setup&quot;&gt;Are you working in a multi-repository setup?&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In general, things start getting messy as soon as you have a feature which requires changes to more than one repository.
For example, you may have a &lt;code&gt;core&lt;/code&gt; repository, and a &lt;code&gt;module&lt;/code&gt; repository, and the feature that you&amp;#8217;re working on for &lt;code&gt;module&lt;/code&gt; requires API changes in &lt;code&gt;module&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If so, it&amp;#8217;s likely that you&amp;#8217;ve been annoyed by the fact that to be able to test the changes to &lt;code&gt;module&lt;/code&gt;, you minimally had to publish a local snapshot to your local Maven repository.
While this can kind of work locally, it&amp;#8217;s easy to miss publishing from time to time, and therefore thinking that a change works when it actually relies on an outdated dependency.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Things get more complicated as soon as CI is involved, or that you want to share the results of work in progress, for example for review, with your colleagues:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;did you ever had to explain that they had to checkout &lt;code&gt;core/some-branch&lt;/code&gt;, publish to Maven local, then checkout &lt;code&gt;module/some-feature-branch&lt;/code&gt; and test it?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;did you ever realize late that you forgot to push changes to &lt;code&gt;master&lt;/code&gt; so that they could try?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;did you ever complain that to make this happen on CI, you actually had to &lt;em&gt;eagerly merge&lt;/em&gt; your feature branch to &lt;code&gt;core&lt;/code&gt;, just so that the other repository, on a &lt;em&gt;feature branch&lt;/em&gt;, could see it?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;did you ever want to see if your modules simply do not break with latest &lt;em&gt;master&lt;/em&gt;, without having to change anything to your build scripts?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you answered yes to any of those questions, then I&amp;#8217;m glad to say &lt;strong&gt;there&amp;#8217;s a solution!&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The underlying problem is that using Maven SNAPSHOTs to deal with multi-repository development is not a good enough.
It cannot model the complexity of multi-repository development, with features being developed concurrently on different branches.
Using SNAPSHOTs (binary dependencies) to coordinate projects leads to hard to diagnose bugs, broken integration processes.
You typically have to eagerly push changes, or wait for snapshots to be published on a shared repository, just so that you can actually verify that integration with other modules work.
Those problems do not happen in a a &lt;em&gt;single repository&lt;/em&gt; world, because all changes are integrated at once.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I faced this very same problem with Micronaut:I&amp;#8217;m currently working on a feature which involves changes to multiple repositories at once:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/micronaut-projects/micronaut-core/&quot;&gt;Micronaut Core&lt;/a&gt;, with additional public APIs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/micronaut-projects/micronaut-aot/&quot;&gt;Micronaut AOT&lt;/a&gt;, the new module I&amp;#8217;m actively working on&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/micronaut-projects/micronaut-gradle-plugin/&quot;&gt;the Micronaut Gradle Plugin&lt;/a&gt;, which integrates the AOT module&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;and a local test project which uses the modified Gradle plugin&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That&amp;#8217;s, minimally 4 different projects, and a change to any of them is a pain to deal with.
With my experience with Gradle, I &lt;em&gt;knew&lt;/em&gt; there was a better way.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_a_plugin_to_make_it_easier&quot;&gt;A plugin to make it easier!&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Today, I&amp;#8217;m happy to announce a new Gradle plugin which aims at making multi-repository development a breeze: &lt;a href=&quot;https://melix.github.io/includegit-gradle-plugin&quot;&gt;Included Git repositories plugin&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This plugin lets you &lt;em&gt;import Git repositories&lt;/em&gt; as source dependencies, without having to change your dependency declarations.
What does that mean?
In the example above, it means that I can explain, when I&amp;#8217;m working on &lt;code&gt;module&lt;/code&gt;, that it needs to build against &lt;code&gt;core/some-branch&lt;/code&gt;: Gradle will then automatically checkout the project, build the branch and &lt;em&gt;substitute&lt;/em&gt; any binary dependency corresponding to &lt;code&gt;core&lt;/code&gt; with the source dependency.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In a nutshell, the configuration would look like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;gitRepositories {
	include(&apos;core&apos;) {
		uri = &apos;git@github.com:mycompany/core.git&apos;
		branch = &apos;some-branch&apos;
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That&amp;#8217;s it! No need to change your build scripts to update dependency coordinates, Gradle will do the magic!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It completely changes the way of thinking about multi-repository development, because CI, or colleagues, would not have to care about instructions about how to build your particular branch: everything is known upfront.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Of course, you&amp;#8217;re going to tell that well, that&amp;#8217;s cool but it still requires you to push your changes to the remote repository so that you can test things &lt;em&gt;locally&lt;/em&gt;.
Well, a good multi-repository development story must integrate both the &lt;em&gt;local&lt;/em&gt; and &lt;em&gt;remote&lt;/em&gt; experience.
This is why this plugin actually makes it a breeze to support this pattern.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There are actually 2 ways you can handle this.
The first one is to explain to Gradle that instead of checking out the sources, it can simply use a local copy instead.
In this case, the plugin will simply &lt;em&gt;ignore&lt;/em&gt; whatever you declared in the &lt;code&gt;gitRepositories&lt;/code&gt; block for the repository, and use whatever is available locally.
For this you&amp;#8217;d set a &lt;code&gt;local.git.&amp;lt;repoName&amp;gt;&lt;/code&gt; Gradle property (in your &lt;code&gt;gradle.properties&lt;/code&gt; file) pointing to your local copy.
In the example above, I would for example add a &lt;code&gt;local.git.core&lt;/code&gt; property pointing to my local copy of &lt;code&gt;core&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Alternatively, if you keep things organized into checkout directories like I do, it&amp;#8217;s likely that you have all your &lt;code&gt;micronaut&lt;/code&gt; related projects in a single &lt;code&gt;micronaut-projects&lt;/code&gt; directory.
In this case, by setting the &lt;code&gt;auto.include.git.dirs&lt;/code&gt; Gradle property to the &lt;code&gt;micronaut-projects&lt;/code&gt; directory, the plugin will automatically map directory names in that &lt;code&gt;micronaut-projects&lt;/code&gt; directory to included Git repository names.
So if I have:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;gitRepositories {
	include(&apos;micronaut-core&apos;) {
		uri = &apos;git@github.com:mycompany/core.git&apos;
		branch = &apos;some-branch&apos;
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and a &lt;code&gt;micronaut-core&lt;/code&gt; directory under &lt;code&gt;micronaut-projects&lt;/code&gt;, then it will automatically be used instead of cloned from remote.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Those options make it extremely convenient to develop locally, and only push changes when ready.
On CI, builds would checkout the dependents automatically, and you&amp;#8217;d have nothing to configure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_more_complex_use_cases&quot;&gt;More complex use cases&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The very same mechanism can be used to create &quot;integration&quot; builds on CI.
For example, it makes it very simple to have builds which would automatically build against the latest state of &lt;code&gt;master&lt;/code&gt;, instead of having to wait for &lt;code&gt;SNAPSHOT&lt;/code&gt; to be published, and more importantly, without having to change any build file.
As a bonus, it also works for &lt;em&gt;transitive dependencies&lt;/em&gt;: for example if you have A --depends on-&amp;#8594; B --depends on-&amp;#8594; C, then you may want to make sure that if &lt;code&gt;C&lt;/code&gt; is changed, &lt;code&gt;A&lt;/code&gt; still works. How do you do this with snapshots, if there&amp;#8217;s no direct dependency between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;? This plugin makes it very simple to test: just declare a Git repository for C and you&amp;#8217;re done!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_need_your_help&quot;&gt;Need your help!&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I think this plugin has potential to dramatically change how we develop in the multi-repository world.
The plugin is in very early stages, and I will need your help: report bugs, improve the documentation, improve testing, etc.
It will also be interesting to get your user stories so that we, collectively, can improve it to support more scenarios.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Plugin documentation: &lt;a href=&quot;https://melix.github.io/includegit-gradle-plugin&quot;&gt;https://melix.github.io/includegit-gradle-plugin&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Plugin development home: &lt;a href=&quot;https://github.com/melix/includegit-gradle-plugin&quot;&gt;https://github.com/melix/includegit-gradle-plugin&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Plugin on Gradle plugin portal: &lt;a href=&quot;https://plugins.gradle.org/plugin/me.champeau.includegit&quot;&gt;https://plugins.gradle.org/plugin/me.champeau.includegit&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>A Gradle quickie: properly using dependsOn</title>
      <link>https://melix.github.io/blog/2021/10/gradle-quickie-dependson.html</link>
      <pubDate>Wed, 6 Oct 2021 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2021/10/gradle-quickie-dependson.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Today I&amp;#8217;d like to share a small example of what &lt;em&gt;not to do&lt;/em&gt; with Gradle.
Some of you may already know that I recently joined the &lt;a href=&quot;https://micronaut.io/&quot;&gt;Micronaut team at Oracle&lt;/a&gt;, and part of my job is to improve the build experience, be it for Micronaut itself or Micronaut users.
Today I&amp;#8217;m going to focus on an example I found in the Micronaut build itself.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;TL/DR&lt;/strong&gt;: If you use &lt;code&gt;dependsOn&lt;/code&gt;, you&amp;#8217;re likely doing it wrong.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_when_should_you_use_dependson&quot;&gt;When should you use dependsOn?&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In a nutshell, Gradle works by computing a graph of task dependencies.
Say that you want to build a JAR file: you&amp;#8217;re going to call the &lt;code&gt;jar&lt;/code&gt; task, and Gradle is going to determine that to build the jar, it needs to compile the classes, process the resources, etc&amp;#8230;
Determining the &lt;em&gt;task dependencies&lt;/em&gt;, that is to say what other tasks need to be executed, is done by looking up at 3 different things:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;the task &lt;code&gt;dependsOn&lt;/code&gt; dependencies. For example, &lt;code&gt;assemble.dependsOn(jar)&lt;/code&gt; means that if you run &lt;code&gt;assemble&lt;/code&gt;, then the &lt;code&gt;jar&lt;/code&gt; task must be executed before&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the task &lt;em&gt;transitive dependencies&lt;/em&gt;, in which case we&amp;#8217;re not talking about tasks, but &quot;publications&quot;. For example, when you need to compile project &lt;code&gt;A&lt;/code&gt;, you need on classpath project &lt;code&gt;B&lt;/code&gt;, which implies running &lt;em&gt;some&lt;/em&gt; tasks of &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;and last but not least, the &lt;em&gt;task inputs&lt;/em&gt;, that is to say, what it needs to execute its work&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In practice, it&amp;#8217;s worth noting that 2. is a subset of 3. but I added it for clarity.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now let&amp;#8217;s look at this snippet:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint gradle language-gradle&quot;&gt;&lt;code&gt;task docFilesJar(type: Jar, description: &apos;Package up files used for generating documentation.&apos;) {
    archiveVersion = null
    archiveFileName = &quot;grails-doc-files.jar&quot;
    from &quot;src/main/template&quot;
    doLast {
        copy {
            from docFilesJar.archivePath
            into &quot;${buildDir}/classes/groovy/main&quot;
        }
    }
}

jar.dependsOn docFilesJar&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First, let&amp;#8217;s realize that this snippet is &lt;em&gt;years old&lt;/em&gt;. I mean, very years old, copied from Grails, which was using early releases of Gradle.
Yet, there&amp;#8217;s something interesting in what it does, which is a &lt;strong&gt;typical mistake I see in all builds I modernize&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s tempting, especially when you&amp;#8217;re not used to Gradle, to think the same way as other build tools do, like Maven or Ant.
You&amp;#8217;re thinking &quot;there&amp;#8217;s a task, jar, which basically packages everything it finds in &lt;code&gt;classes/groovy/main&lt;/code&gt;, so if I want to add more stuff to the jar task, let&amp;#8217;s put more stuff in &lt;code&gt;classes/groovy/main&lt;/code&gt;&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;This is wrong!&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is wrong for different reasons, most notably:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;when the &lt;code&gt;docsFilesJar&lt;/code&gt; task is going to be executed, it will contribute more files to the &quot;classes&quot; directory, but, wait, those are not classes that we&amp;#8217;re putting in there, right? It&amp;#8217;s just a jar, resources. Shouldn&amp;#8217;t we use &lt;code&gt;resources/groovy/main&lt;/code&gt; instead? Or is it &lt;code&gt;classes/groovy/resources&lt;/code&gt;? Or what? Well, you &lt;strong&gt;shoudn&amp;#8217;t care&lt;/strong&gt; because it&amp;#8217;s not your concern where the Java compile task is going to put its output!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it breaks &lt;em&gt;cacheability&lt;/em&gt;: Gradle has a &lt;em&gt;build cache&lt;/em&gt;, and multiple tasks contributing to the same output directory is the typical example of what would break caching. In fact, it breaks all kinds of up-to-date checking, that is to say the ability for Gradle to understand that it doesn&amp;#8217;t need to execute a task when nothing changed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it&amp;#8217;s opaque to Gradle: the code above executes a copy in a &lt;code&gt;doLast&lt;/code&gt; block. Nothing tells Gradle that the &quot;classes&quot; have additional output.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;imagine another task which needs the &lt;code&gt;classes&lt;/code&gt; only. Depending on when it executes, it &lt;em&gt;may&lt;/em&gt; or may not, include the &lt;code&gt;docsFileJar&lt;/code&gt; that it doesn&amp;#8217;t care about. This makes builds non-reproducible (note that this is exactly the reason why Maven build cannot be trusted and that you need to run &lt;code&gt;clean&lt;/code&gt;, because any &quot;goal&quot; can write to any directory at any time, making it impossible to infer who contributed what).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it requires to declare an &lt;em&gt;explicit dependency&lt;/em&gt; between the &lt;code&gt;jar&lt;/code&gt; task and the &lt;code&gt;docsFileJar&lt;/code&gt; task, to make sure that if we execute &lt;code&gt;jar&lt;/code&gt;, our &quot;docs jar&quot; file is present&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it doesn&amp;#8217;t tell &lt;em&gt;why&lt;/em&gt; there&amp;#8217;s a dependency: is it because you want to &lt;em&gt;order&lt;/em&gt; things, or is it because you require an &lt;em&gt;artifact&lt;/em&gt; produced by the dependent task? Something else?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it&amp;#8217;s easy to forget about those: because you may run &lt;code&gt;build&lt;/code&gt; often, you might think that your build works, because &lt;code&gt;jar&lt;/code&gt; is part of the task graph, and &lt;em&gt;by accident&lt;/em&gt;, the &lt;code&gt;docsFileJar&lt;/code&gt; would be executed before&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it creates accidental extra work: most often a &lt;code&gt;dependsOn&lt;/code&gt; will trigger too much work. Gradle is a smart build tool which can compute &lt;em&gt;precisely&lt;/em&gt; what it needs to execute for each specific task. By using &lt;code&gt;dependsOn&lt;/code&gt;, you&amp;#8217;re a bit using a hammer and forcing it to integrate something in the graph which wasn&amp;#8217;t necessarily needed. In short: you&amp;#8217;re doing too much work.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it&amp;#8217;s difficult to get rid of them: when you see a &lt;code&gt;dependsOn&lt;/code&gt;, because it doesn&amp;#8217;t tell &lt;em&gt;why&lt;/em&gt; it&amp;#8217;s needed, it&amp;#8217;s often hard to get rid of such dependencies when optimizing builds&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_use_implicit_dependencies_instead&quot;&gt;Use implicit dependencies instead!&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The answer to our problem is actually simpler to reason about: reverse the logic.
Instead of thinking &quot;where should I put those things so that it&amp;#8217;s picked up by jar&quot;, think &quot;let&amp;#8217;s tell the &lt;code&gt;jar&lt;/code&gt; task that it also needs to pick up my resources&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All in all, it&amp;#8217;s about &lt;em&gt;properly declaring your task inputs&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Instead of patching up the output of another task (seriously, forget about this!), every single task must be thought as a function which takes inputs and produces an output: it&amp;#8217;s &lt;strong&gt;isolated&lt;/strong&gt;.
So, what are the inputs of our &lt;code&gt;docsFileJar&lt;/code&gt;? The resources we want to package. What are its outputs? The &lt;code&gt;jar&lt;/code&gt; itself. There&amp;#8217;s &lt;em&gt;nothing&lt;/em&gt; about where we should put the jar, we let Gradle pick a reasonable place for us.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then what are the inputs of the &lt;code&gt;jar&lt;/code&gt; task itself? Well, it&amp;#8217;s regular inputs &lt;strong&gt;plus&lt;/strong&gt; our jar. It&amp;#8217;s easier to reason about, and as bonus, it&amp;#8217;s even shorter to write!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So let&amp;#8217;s rewrite the code above to:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;task docFilesJar(type: Jar, description: &apos;Package up files used for generating documentation.&apos;) {
    archiveVersion = null
    archiveFileName = &quot;grails-doc-files.jar&quot;
    from &quot;src/main/template&quot;
}

jar {
    from docFilesJar
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Can you spot the difference? We got rid of the &lt;code&gt;copy&lt;/code&gt; in the &lt;code&gt;docFilesJar&lt;/code&gt; task, we don&amp;#8217;t want to do this. What we want, instead, is to say &quot;when you build the jar, also pick this &lt;code&gt;docsFileJar&lt;/code&gt;. And that&amp;#8217;s what we&amp;#8217;re doing by telling &lt;code&gt;from docsFileJar&lt;/code&gt;. Gradle is smart enough to know that when it will need to execute the &lt;code&gt;jar&lt;/code&gt; task, first, it will need to build the &lt;code&gt;docsFilesJar&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There are several advantages to this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the dependency becomes &lt;em&gt;implicit&lt;/em&gt;: if we don&amp;#8217;t want to include the jar anymore, we just have to remove it from the specification of the inputs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it doesn&amp;#8217;t pollute the outputs of other tasks&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;you can execute the &lt;code&gt;docsFileJar&lt;/code&gt; independently of &lt;code&gt;jar&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All in all, it&amp;#8217;s about isolating things from each other and reducing the risks of breaking a build accidentally!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_all_things_lazy&quot;&gt;All things lazy!&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The modified code isn&amp;#8217;t 2021 compliant. The code above works, but it has one drawback: the &lt;code&gt;docFilesJar&lt;/code&gt; and &lt;code&gt;jar&lt;/code&gt; tasks are going to be configured (instantitated) even if we call something that doesn&amp;#8217;t need it. For example, imagine that you call &lt;code&gt;gradle compileJava&lt;/code&gt;: there&amp;#8217;s no reason to configure the &lt;code&gt;jar&lt;/code&gt; tasks there because we won&amp;#8217;t execute them.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For this purpose, to make builds faster, Gradle provides a &lt;em&gt;lazy API&lt;/em&gt; instead:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;tasks.register(&apos;docFilesJar&apos;, Jar) {
    description = &apos;Package up files used for generating documentation.&apos;
    archiveVersion = null
    archiveFileName = &quot;grails-doc-files.jar&quot;
    from &quot;src/main/template&quot;
}

tasks.named(&apos;jar&apos;, Jar) {
    from docFilesJar
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As a conclusion:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;avoid using explicit &lt;code&gt;dependsOn&lt;/code&gt; &lt;em&gt;as much as you can&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I tend to say that the only reasonable use case for &lt;code&gt;dependsOn&lt;/code&gt; is for lifecycle tasks (lifecycle tasks are tasks which goal is only there to &quot;organize the build&quot;, for example &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;assemble&lt;/code&gt;, &lt;code&gt;check&lt;/code&gt;: they don&amp;#8217;t do anything by themselves, they just bind a number of dependents together)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if you find use cases which are not lifecycle tasks and cannot be expressed by &lt;em&gt;implicit task dependencies&lt;/em&gt; (e.g declaring inputs instead of &lt;code&gt;dependsOn&lt;/code&gt;), then report it to the Gradle team&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Frequently asked questions about version catalogs</title>
      <link>https://melix.github.io/blog/2021/03/version-catalogs-faq.html</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2021/03/version-catalogs-faq.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This post is a follow up to my &lt;a href=&quot;/blog/2021/03/version-catalogs.html&quot;&gt;version catalogs intro blog post&lt;/a&gt; and answers some frequently asked questions.
Ideally, this should be part of the Gradle docs itself but we don&amp;#8217;t have a good place for this kind of docs yet (I&amp;#8217;m working on it!), so in the meantime, here you go!
This blog post will be updated as I&amp;#8217;m seeing more questions.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot; class=&quot;title&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_version_catalogs_faq&quot;&gt;Version catalogs FAQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_can_i_use_a_version_catalog_to_declare_plugin_versions&quot;&gt;Can I use a version catalog to declare plugin versions?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_can_i_use_the_version_catalog_in_buildsrc&quot;&gt;Can I use the version catalog in buildSrc?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_but_how_can_i_use_the_catalog_in_em_plugins_em_defined_in_code_buildsrc_code&quot;&gt;But how can I use the catalog in &lt;em&gt;plugins&lt;/em&gt; defined in &lt;code&gt;buildSrc&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_can_i_use_version_catalogs_in_production_code&quot;&gt;Can I use version catalogs in production code?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_should_i_use_a_platform_or_a_catalog&quot;&gt;Should I use a platform or a catalog?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_did_you_choose_toml_and_not_yaml&quot;&gt;Why did you choose TOML and not YAML?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_my_ide_is_red_everywhere_missing_dependency_class_error&quot;&gt;My IDE is red everywhere, MISSING_DEPENDENCY_CLASS error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_can_t_i_have_nested_aliases_with_the_same_prefix&quot;&gt;Why can&amp;#8217;t I have nested aliases with the same prefix?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_can_t_i_use_an_alias_with_dots_directly&quot;&gt;Why can&amp;#8217;t I use an alias with dots directly?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_should_i_use_code_commons_lang3_code_as_an_alias_or_code_commonslang3_code&quot;&gt;Should I use &lt;code&gt;commons-lang3&lt;/code&gt; as an alias or &lt;code&gt;commonsLang3&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_should_i_use_the_settings_api_or_the_toml_file&quot;&gt;Should I use the settings API or the TOML file?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_can_t_i_use_excludes_or_classifiers&quot;&gt;Why can&amp;#8217;t I use excludes or classifiers?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_how_do_i_tell_gradle_to_use_a_specific_em_artifact_em&quot;&gt;How do I tell Gradle to use a specific &lt;em&gt;artifact&lt;/em&gt;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_where_should_i_report_bugs_or_feature_requests&quot;&gt;Where should I report bugs or feature requests?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_version_catalogs_faq&quot;&gt;Version catalogs FAQ&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_can_i_use_a_version_catalog_to_declare_plugin_versions&quot;&gt;Can I use a version catalog to declare plugin versions?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;No.The initial implementation of the version catalogs had, in TOML files, a dedicated section for plugins:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[plugins]
id.of.my.awesome.plugin=&quot;1.2.3&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, after community feedback and for &lt;a href=&quot;https://github.com/gradle/gradle/issues/16078&quot;&gt;consistency reasons&lt;/a&gt;, we removed this feature from the initial release.
This means that &lt;em&gt;currently&lt;/em&gt;, you have to use the &lt;code&gt;pluginManagement&lt;/code&gt; section of the settings file to deal with your plugin versions, and this cannot use, in particular, the TOML file to declare plugin versions:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;pluginManagement {
    plugins {
        id(&quot;me.champeau.jmh&quot;) version(&quot;0.6.3&quot;)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It may look surprising that you can&amp;#8217;t use &lt;code&gt;version(libs.plugins.jmh)&lt;/code&gt; for example in the &lt;code&gt;pluginManagement&lt;/code&gt; block, but it&amp;#8217;s a chicken and egg problem: the &lt;code&gt;pluginManagement&lt;/code&gt; block has to be evaluated &lt;em&gt;before&lt;/em&gt; the catalogs are defined, because &lt;em&gt;settings plugins&lt;/em&gt; may contribute more catalogs or enhance the existing catalogs. Therefore, the &lt;code&gt;libs&lt;/code&gt; extension doesn&amp;#8217;t exist when this block is evaluated.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The limitation of not being able to deal with plugin versions in catalogs will be lifted in one way or another in the future.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_can_i_use_the_version_catalog_in_buildsrc&quot;&gt;Can I use the version catalog in buildSrc?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Yes you can. Not only in &lt;code&gt;buildSrc&lt;/code&gt;, but basically in any included build too. You have several options, but the easiest is to include the TOML catalog in your &lt;code&gt;buildSrc/settings.gradle(.kts)&lt;/code&gt; file:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;buildSrc/settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencyResolutionManagement {
    versionCatalogs {
        lib {
            from(files(&quot;../gradle/libs.versions.toml&quot;))
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_but_how_can_i_use_the_catalog_in_em_plugins_em_defined_in_code_buildsrc_code&quot;&gt;But how can I use the catalog in &lt;em&gt;plugins&lt;/em&gt; defined in &lt;code&gt;buildSrc&lt;/code&gt;?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The solution above lets you use the catalogs in the build scripts of &lt;code&gt;buildSrc&lt;/code&gt; itself, but what if you want to use the catalog(s) in the plugins that &lt;code&gt;buildSrc&lt;/code&gt; defines, or precompiled script plugins?
Long story short, currently, you can do it using a &lt;em&gt;type unsafe&lt;/em&gt; API only.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First you need to access the version catalogs extension to your plugin/build script, for example in Groovy:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def catalogs = project.extensions.getByType(VersionCatalogsExtension)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;or in Kotlin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint kotlin language-kotlin&quot;&gt;&lt;code&gt;val catalogs = extensions.getByType&amp;lt;VersionCatalogsExtension&amp;gt;()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;then you can access the version catalogs in your script, for example writing:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint kotlin language-kotlin&quot;&gt;&lt;code&gt;pluginManager.withPlugin(&quot;java&quot;) {
    val libs = catalogs.named(&quot;libs&quot;)
    dependencies.addProvider(&quot;implementation&quot;, libs.findDependency(&quot;lib&quot;).get())
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Note that this API doesn&amp;#8217;t provide any static accessor but is nevertheless safe, using the &lt;code&gt;Optional&lt;/code&gt; API.
There&amp;#8217;s a reason why you cannot access type-safe accessors in plugins/precompiled script plugins, you will find more details on this &lt;a href=&quot;https://github.com/gradle/gradle/issues/15383&quot;&gt;issue&lt;/a&gt;.
In a nutshell, that&amp;#8217;s because &lt;code&gt;buildSrc&lt;/code&gt; plugins (precompiled or not) are &lt;em&gt;plugins&lt;/em&gt; which can be applied to any kind of project and we don&amp;#8217;t know what the &lt;em&gt;target project catalogs&lt;/em&gt; will be: there&amp;#8217;s no inherent reason why they would be the same.
In the future we will probably provide a way to explain that, at your own risk, expect the target catalog model to be the same.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_can_i_use_version_catalogs_in_production_code&quot;&gt;Can I use version catalogs in production code?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;No, you can&amp;#8217;t. Version catalogs are only accessible to build scripts/plugins, not your production code.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_should_i_use_a_platform_or_a_catalog&quot;&gt;Should I use a platform or a catalog?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You should probably use both, look at our &lt;a href=&quot;https://docs.gradle.org/7.0/userguide/platforms.html#sub:platforms-vs-catalog&quot;&gt;docs&lt;/a&gt; for a complete explanation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_did_you_choose_toml_and_not_yaml&quot;&gt;Why did you choose TOML and not YAML?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;or XML (or pick your favorite format). The rationale is described in the &lt;a href=&quot;https://github.com/gradle/gradle/files/5646826/2020-12-05-Central.declaration.of.dependencies.Shared.externally.pdf&quot;&gt;design document&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_my_ide_is_red_everywhere_missing_dependency_class_error&quot;&gt;My IDE is red everywhere, MISSING_DEPENDENCY_CLASS error&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you are seeing this error:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/blog/img/missing-dependency.png&quot; alt=&quot;missing dependency&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;upgrade to the latest IntelliJ IDEA 2021.1, which fixes this problem.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_can_t_i_have_nested_aliases_with_the_same_prefix&quot;&gt;Why can&amp;#8217;t I have nested aliases with the same prefix?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Imagine that you want to have 2 aliases, say &lt;code&gt;junit&lt;/code&gt; and &lt;code&gt;junit-jupiter&lt;/code&gt; and that both represent distinct dependencies: Gradle won&amp;#8217;t let you do this and you will have to rename your aliases to, say &lt;code&gt;junit-core&lt;/code&gt; and &lt;code&gt;junit-jupiter&lt;/code&gt;.
That&amp;#8217;s because Gradle will map those aliases to &lt;em&gt;accessors&lt;/em&gt;, that is to say &lt;code&gt;libs.getJunit()&lt;/code&gt; and &lt;code&gt;libs.getJUnit().getJupiter()&lt;/code&gt;.
The problem is that you can&amp;#8217;t have an accessor which is both a &lt;em&gt;leaf&lt;/em&gt; (represents a dependency notation) and a &lt;em&gt;node&lt;/em&gt; (that is to say an intermediate node to access a real dependency).
The reason we can&amp;#8217;t do this is that we&amp;#8217;re using lazy accessors of type &lt;code&gt;Provider&amp;lt;MinimalExternalDependency&amp;gt;&lt;/code&gt; for leaves and that type &lt;em&gt;cannot&lt;/em&gt; be extended to provide accessors for &quot;children&quot; dependencies.
In other words, the type which represents a &lt;em&gt;node with children&lt;/em&gt; provides accessors which return &lt;code&gt;Provider&amp;lt;...&amp;gt;&lt;/code&gt; for dependencies, but a provider itself cannot have children.
A potential workaround for this would be to support, in the future, an explicit call to say &quot;I&amp;#8217;m stopping here, that&amp;#8217;s the dependency I need&quot;, for example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;dependencies {
    testImplementation(libs.junit.get())
    // or
    testImplemementation(libs.junit.peek()) // because `get()` might be confusing as it would return a `Provider` on which you can call `get()` itself
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For now the team has decided to restrict what you can do by preventing having aliases which have &quot;name clashes&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_can_t_i_use_an_alias_with_dots_directly&quot;&gt;Why can&amp;#8217;t I use an alias with dots directly?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You will have noticed that if you declare an alias like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
junit-jupiter = &quot;...&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;then Gradle will generate the following accessor: &lt;code&gt;libs.junit.jupiter&lt;/code&gt; (basically the dashes are transformed to dots).
The question is, why can&amp;#8217;t we just write:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
junit.jupiter = &quot;...&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And the reason is: tooling support. The previous declaration is actually equivalent to writing:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
   [junit]
   jupiter = &quot;...&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;but technically, it&amp;#8217;s undecidable where the &quot;nesting hierarchy&quot; stops, which would prevent tools from providing good completion (for example, where you can use &lt;code&gt;{ module = &quot;...&quot;}&lt;/code&gt;.
It also makes it harder for tooling to automatically patch the file since they wouldn&amp;#8217;t know where to look for.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As a consequence, we&amp;#8217;ve decided to keep the format simple and implement this mapping strategy.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_should_i_use_code_commons_lang3_code_as_an_alias_or_code_commonslang3_code&quot;&gt;Should I use &lt;code&gt;commons-lang3&lt;/code&gt; as an alias or &lt;code&gt;commonsLang3&lt;/code&gt;?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Problably neither one nor the other :) By choosing &lt;code&gt;commons-lang3&lt;/code&gt;, you&amp;#8217;re implicitly creating a &lt;em&gt;group of dependencies&lt;/em&gt; called &lt;code&gt;commons&lt;/code&gt;, which will include a number of dependencies, including &lt;code&gt;lang3&lt;/code&gt;.
The question then is, does that &lt;code&gt;commons&lt;/code&gt; group make sense? It&amp;#8217;s rather abstract, no? Does it actually say it&amp;#8217;s &quot;Apache Commons&quot;?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A better solution would therefore be to use &lt;code&gt;commonsLang3&lt;/code&gt; as the alias, but then you&amp;#8217;d realize that you have chosen a version in the alias name, so why not &lt;code&gt;commonsLang&lt;/code&gt; directly?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Therefore:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
commonsLang = { module=&quot;org.apache.commons:commons-lang3:3.3.1&quot; }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This means that the dashes should be limited to grouping of dependencies, so that they are organized in &quot;folders&quot;.
This can make it practical when you have lots of dependencies, but it also makes them less discoverable by completion, since you&amp;#8217;d have to know in which subtree to look at.
Proper guidance on what to use will be discussed later, based on your feedback and practices.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_should_i_use_the_settings_api_or_the_toml_file&quot;&gt;Should I use the settings API or the TOML file?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle comes with both a settings API to declare the catalog, or a convenience TOML file.
I would personally say that most people should only care about the TOML file as it covers 80% of use cases.
The settings API is great as soon as you want to implement &lt;em&gt;settings plugins&lt;/em&gt; or, for example, if you want to use your own, existing format to declare a catalog, instead of using the TOML format.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_can_t_i_use_excludes_or_classifiers&quot;&gt;Why can&amp;#8217;t I use excludes or classifiers?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By design, version catalogs talk about &lt;em&gt;dependency coordinates&lt;/em&gt; only.
The choice of applying excludes is on the consumer side: for example, for a specific project, you might need to exclude a transitive dependency because you don&amp;#8217;t use the code path which exercises this dependency, but this might not be the case for all places.
Similarly, a classifier falls into the category of &lt;em&gt;variant selectors&lt;/em&gt; (see &lt;a href=&quot;https://docs.gradle.org/current/userguide/variant_model.html&quot;&gt;the variant model&lt;/a&gt;): for the same dependency coordinates, one might want classifier X, another classifier Y, and it&amp;#8217;s not necessarily allowed to have both in the same graph.
Therefore, classifiers need to be declared on the &lt;em&gt;dependency declaration site&lt;/em&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;dependencies {
   implementation(variantOf(libs.myLib) { classifier(&apos;test-fixtures&apos;) })
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The rationale being this limitation is that the use of classifiers is an artifact of the poor &lt;code&gt;pom.xml&lt;/code&gt; modeling, which doesn&amp;#8217;t assign semantics to classifiers (we don&amp;#8217;t know what they represent), contrary to Gradle Module Metadata.
Therefore, a consumer should only care about the dependency coordinates, and the right variant (e.g classifier) should be selected automatically by the dependency resolution engine.
We want to encourage this model, rather than supporting &lt;em&gt;adhoc&lt;/em&gt; classifiers which will eventually require more work for all consumers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_how_do_i_tell_gradle_to_use_a_specific_em_artifact_em&quot;&gt;How do I tell Gradle to use a specific &lt;em&gt;artifact&lt;/em&gt;?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Similarly to classifiers or excludes, &lt;em&gt;artifact selectors&lt;/em&gt; belong to the dependency declaration site. You need to write:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencies {
    implementation(libs.myLib) {
        artifact {
            name = &apos;my-lib&apos; // note that ideally this will go away, see https://github.com/gradle/gradle/issues/16768
            type = &apos;aar&apos;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_where_should_i_report_bugs_or_feature_requests&quot;&gt;Where should I report bugs or feature requests?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As usual, on our &lt;a href=&quot;https://github.com/gradle/gradle/issues&quot;&gt;issue tracker&lt;/a&gt;. There&amp;#8217;s also the dedicated &lt;a href=&quot;https://github.com/gradle/gradle/issues/15352&quot;&gt;epic&lt;/a&gt; where you will find the initial specification linked, which explains a lot of the design process.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>

  </channel> 
</rss>
